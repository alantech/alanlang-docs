{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Alan Programming Language","text":""},{"location":"#a-gpgpu-native-programming-language-for-the-rest-of-us","title":"A GPGPU-native programming language for the rest of us.","text":"Hello, GPU<pre><code>export fn main {\n  // Create a buffer of memory on the GPU\n  let b = GBuffer([1.i32, 2.i32, 3.i32, 4.i32]);\n  // Map the values into a new buffer on the GPU\n  let out = b.map(fn (val: gi32) = val + 2);\n  // Read the results back to RAM and print them\n  out.read{i32}.print;\n}\n</code></pre> <p>Get Started with Alan</p>"},{"location":"#why-alan","title":"Why Alan?","text":"<p>Utilizing GPUs for general-purpose computing (GPGPU) has been a difficult ask for developers, with various unsatisfying trade-offs. You must either:</p> <ul> <li>Tie yourself to a singular GPU vendor with a low-level C++-like language like CUDA or ROCm</li> <li>Choose a platform to target (Windows, Mac, Linux, Web) which chooses the framework to use (DirectX, Metal, Vulkan, WebGPU) and requires you write part of your program in a specific shading language (HLSL, MSL, GLSL, WGSL)</li> <li>Use a wrapper library, generally only in interpreted languages, that exposes some but not all of the GPGPU power, with trade-offs and a not-quite-native syntax, like PyTorch or GPU.js.</li> </ul> <p>Alan is being designed from the ground up around the idea of GPGPU as a first-class citizen in a higher-level typed language like Nim or Crystal that compiles to native code, or can compile to Javascript for use on the Web.</p> <p>This means that CPU code written in idiomatic Alan should have roughly the same performance as idiomatic Rust code (the default target language for Alan), while GPU code written in Alan can mix and match CPU and GPU types as desired, and Alan will generate the necessary WGSL shader for you, even when mixing in branching logic like conditionals -- something not even GPU.js can do as it has no ability to alter the behavior of the JS interpreter to follow both branches of a conditional statement for AST generation.</p> <p>Get to Know Alan</p>"},{"location":"#learn-alan","title":"Learn Alan","text":"<p>Ready to learn more about Alan? Checkout the basic tutorial to become dangerous with Alan, dig into the built-in types, functions, and operators automatically available to every Alan module, deep dive into the standard library of Alan, or read some articles on Alan for projects that have used it or interesting patterns to take for yourself.</p>"},{"location":"built_ins/","title":"Built-ins","text":"<p>The Built-in Types, Functions, and Operators that are automatically available in every Alan module.</p>"},{"location":"built_ins/#types","title":"Types","text":"<p>There are two kinds of built-in types: intrinsic types and constructed types. The intrinsic types are the types declared to exist by the Alan compiler and are interpreted by it to produce the types (and automatically generated functions) that you actually use in your code.</p> <p>In some ways, the intrinsic types are a kind of compile-time interpreted language that directs the compiler and generating types is a side-effect. There are more of these intrinsic types than you might expect because of compile-time computation and the necessity to bridge the Alan type system to the Rust (and sorta Javascript) type system.</p> <p>Of these intrinsic types, there is a core that you should be aware of, and secondary ones only necessary for writing your own bindings into the host language or for more complex types, and even of the core you should be aware of, they are often syntactic concepts in other languages that are part of the type system, here.</p> <p>The constructed types are those that are built on top of these intrinsic types and there are many of these that you might have expected to be intrinsic that are constructed, including all of the run-time integers, floats, bools, and strings.</p>"},{"location":"built_ins/#intrinsic-types","title":"Intrinsic Types","text":"<p>There are a few sub-groups we can divide the intrinsic types into: the meta types, the host types, the type types, and the compute types.</p>"},{"location":"built_ins/#meta-types","title":"Meta Types","text":"<p>The Meta types are types that are generally not used directly, but represent features of the language syntax itself.</p> <ul> <li><code>Type</code> is the first and most core type in the language. It isn't used directly, but holds onto the name and actual type when you use the <code>type typename = typdef;</code> syntax.</li> <li><code>Generic</code> is similar to <code>Type</code> in that it is not used directly, but is used when you use the <code>type typename{genericarg1, genericarg2} = genericdef;</code> syntax to define a generic type.</li> <li><code>Int{T}</code> represents any integer value in the type system itself, such as the length of a fixed-length buffer type. You can pass another type into it to attempt to cast to an integer (compilation will fail if it cannot).</li> <li><code>Float{T}</code> represents floating-point numbers in the type system. You can pass another type into it to attempt to cast to a float (compilation will fail if it cannot).</li> <li><code>Bool{T}</code> represents <code>true</code> an <code>false</code> in the type system. It is used quite a bit for conditional compilation. You can pass another type into it to attempt to cast to a boolean (compilation will fail if it cannot).</li> <li><code>String{T}</code> represents string values in the type system. It is useful for compile-time environmental variable compilation configuration and embedding the contents of a text file into the code. It has also been used as a way to provide a \"tag\" to a generic type that functions accepting that generic type can use to alter their behavior at runtime. You can pass any type into it and produce a string representation of that type.</li> <li><code>Group{G}</code> is a type that represents parenthesis <code>()</code> in the type system syntax. It can be used outside of that, but it is kinda pointless to do so.</li> <li><code>Unwrap{T}</code> is a type that unwraps a provided type. If it's a group it removes the grouping, and if it's a named type it provides the definition of that type directly where it sits. Useful for \"mixin\" style type building, where instead of needing the base type to be specifically called out as a sub-type, it's just baked into the new derivative type. It can also allow mutating the original type by re-assigning back to the same type name.</li> <li><code>Function{I, O}</code> is the only meta type that can and is used directly in several cases, most commonly when writing a function that accepts another function as an argument, but it is also automatically constructed when you write a function.</li> <li><code>AnyOf{A, B, ...}</code> is a type where all types within can be computed and it is up to the compiler to choose the one to use. It is generally used internally during automatic generic argument inference of function calls, and is intended to be used for integer type inference in the future.</li> </ul>"},{"location":"built_ins/#host-types","title":"Host Types","text":"<p>The Host types are types that are involved in bridging Alan to the host language, allowing you to call native functions, declare native types, and require native 3rd party libraries.</p> <ul> <li><code>Binds{T, ...}</code> is the first built-in type that you do use directly. It's a generic type whose first argument is the string name of the type in the host language (Rust or Javascript) that you are compiling to. Extra arguments to the generic type are the types to provide to the generic arguments of the type assuming it is a generic type.</li> <li><code>Call{N, F}</code> takes a \"callable\" type as the first argument and a <code>Function{I, O}</code> declaration on how to \"call\" it as the second type. A <code>String</code> refers to a standard function, while rest of the \"callable\" types are defined below.</li> <li><code>Infix{O}</code> is the first \"callable\" type. It takes a <code>String</code> representation of an infix operator in the host language, which the compiler will turn into <code>(A op B)</code>, with <code>A</code> and <code>B</code> being the two arguments (it will be a compile-time error if the <code>Function{I, O}</code> does not specify exactly two arguments) and <code>op</code> is the operator symbol. Parentheses are always used to avoid needing to clarify operator precedence rules in the host language.</li> <li><code>Prefix{O}</code> is the next \"callable\" type. It takes a <code>String</code> representation of a prefix operator in the host language, which the compiler will turn into <code>(op A)</code>, with <code>A</code> bing the singular argument (which will compile-time fail if the <code>Function{I, O}</code> is not a single-argument function) and <code>op</code> is the operator symbol. Parentheses are always used to avoid needing to clarify operator precedence rules in the host language.</li> <li><code>Method{F}</code> is another \"callable\" type. It takes a <code>String</code> representation of a method call. The first argument of the <code>Function{I, O}</code> is the variable the method will be called on, and all remaining arguments are the arguments of the method call. It is a compile-time error if the <code>Function{I, O}</code> definition does not include any input types.</li> <li><code>Property{P}</code> is another \"callable\" type. It takes a <code>String</code> representation of the property name to call. The first and only allowed argument of the <code>Function{I, O}</code> definition is the variable the property will be accessed from.</li> <li><code>Cast{T}</code> is a Rust-only \"callable\" type that is used for type casting from one type to another. The <code>Function{I, O}</code> must have only one input type and that input type must similarly be specially marked as <code>Own{T}</code> or <code>Deref{T}</code> for the <code>Cast{T}</code> to function correctly.</li> <li><code>Own{T}</code> is a Rust-only, function-argument-only type that indicates that the function should take full ownership of the variable away from the calling function. Alan does not have an ownership model, and while it will be able to determine if the variable is never used again and optimize the implementation of these calls in the future, right now what this means is that the Alan compiler will <code>.clone()</code> the argument and then pass that to the function, so try to avoid this when possible.</li> <li><code>Deref{T}</code> is a Rust-only, function-argument-only type that indicates that the function should derefernce the referenced variable (all arguments in Alan are pass-by-reference by default). This avoids the <code>.clone()</code>, but many types cannot be safely de-referenced like this. Alan will trust you that it is safe to do this, and may generate invalid Rust code, so also try to avoid this when possible.</li> <li><code>Mut{T}</code> is a function-argument-only type that indicates that the argument will be mutated by the function in question. This is actually the only function-argument-only type that is also used in pure Alan code to indicate that the passed in argument may be mutated by the function body. (It can also be specified on Javascript functions for documentation purposes, but all arguments in Javascript are actually mutable references).</li> <li><code>Dependency{N, V}</code> is a type used to define a 3rd party dependency, with <code>N</code> usually being the name of the dependency and <code>V</code> usually being the version of the dependency, but the specific meanings depend on the type the dependency type is embedded within.</li> <li><code>Rust{D}</code> is a wrapper around the <code>Dependency{N, V}</code> type indicating that this is a native Rust dependency. If it is present when compiling to Javascript, it will cause a compilation error. The dependency's <code>N</code> is a string that specifies the name of the Rust crate, and <code>V</code> is either a Cargo version or a <code>git</code> URL to get the crate. Unlike in the standard <code>Cargo.toml</code> format, appending a hashtag (<code>#</code>) followed by a string you can specify the branch, tag, or commit SHA that should be checked out from the <code>git</code> URL.</li> <li><code>Nodejs{D}</code> is a wrapper around the <code>Dependency{N, V}</code> type indicating that it is a Node.js dependency. The dependency's <code>N</code> is a string that specifes the name of the Node module, and <code>V</code> is either an NPM version or a <code>git</code> URL to get the module. Similarly to the <code>Rust{D}</code> logic for <code>git</code> URLs, the hashtag (<code>#</code>) approach may also be used to determine the branch, tag, or commit SHA to use.</li> <li><code>Import{N, D}</code> pulls the named resource <code>N</code> from the dependency <code>D</code>. If <code>D</code> is a <code>String</code>, then it is assumed to be the filename of an Alan source file, which is then loaded and the <code>N</code> resource is extracted from it. If it is a bare <code>Dependency{N, V}</code> that is assumed to be an Alan dependency, which currently fails because dependency resolution for Alan has not yet been defined. If it is a <code>Rust{D}</code> dependency, then the <code>N</code> value is assumed to exist in the Rust crate specified, and similarly if it is a <code>Node{D}</code>, the <code>N</code> value is assumed to exist in the Node module. There is no checking done for this declaration, so invalide code may be generated if this is incorrect.</li> <li><code>From{D}</code> is a \"magic\" alternative to <code>Import{N, D}</code> that automatically figures out the <code>N</code> value that should be used based on the context in which it is invoked. Specifically if you are using the <code>type typename = ...</code> syntax or the <code>fn funcname ...</code> syntax, it will extract <code>typename</code> or <code>funcname</code> for you and then invoke <code>Import{N, D}</code> with it. Any other usage will result in a compile-time error.</li> </ul>"},{"location":"built_ins/#type-types","title":"Type types","text":"<p>The \"Type\" types are the types that are used to describe and build your own types out of other types. There are only surprisingly few of them.</p> <ul> <li><code>Tuple{A, ...}</code> defines a tuple type, AKA a product type, a type where all sub-types must have a value defined for. The sub-values defined in the tuple are accessed with <code>.0</code>, <code>.1</code>, etc with the number corresponding to its location in the tuple.</li> <li><code>Field{L, V}</code> defines a field type, which is a label <code>L</code> which must be a <code>String</code> and the value type <code>V</code>. Combine this with the <code>Tuple{A, ...}</code> type to get classic C-style structs. These fields may be accessed either with the numeric index or <code>.fieldname</code>.</li> <li><code>Either{A, ..}</code> defines an either type, AKA a sum type, a type where only one sub-type is defined at a time. This can be paired with the <code>Field{L, V}</code> type to get a Tagged Union. The access is the same as with tuples (<code>.0</code>, etc or <code>.fieldname</code>) but as the value may not exist a special <code>Maybe{T}</code> type is returned (which is actually <code>Either{T, ()}</code>) that has special functions to inspect and access.</li> <li><code>Buffer{T, S}</code> defines a buffer type, a fixed-length array where all values are of type <code>T</code> and there are an <code>Int</code> <code>S</code> number of entries in the buffer. It works similarly to a <code>Tuple</code> where all subtypes are the same type, except you also gain access to array access syntax since the return type is guaranteed to match in all cases. Using the <code>.0</code>, etc syntax checks the index at compile-time, so the value <code>T</code> type is accessed directly, while using the array access syntax <code>[0]</code>, where the number can be specified at runtime, returns a <code>Maybe{T}</code> that must be checked if it exists before being used.</li> <li><code>Array{T}</code> defines an array type, which is a variable-length array where all values are of type <code>T</code>. It may only use array access syntax to access the values, so all values are extracted as <code>Maybe{T}</code>.</li> </ul>"},{"location":"built_ins/#compute-types","title":"Compute types","text":"<p>The Compute types are types that compute some value based on the input types given to them. Currently, Alan allows for conditional compile-time execution but it does not support loops at compile-time. This may change in the future, but it will certainly be done in a way to prevent infinite looping if added (the type system is pretty expressive, already, and an actual type generated by looping may be too difficult to understand).</p> <ul> <li><code>Prop{T, P}</code> extracts the sub-type from a <code>Tuple{A, ...}</code> or <code>Either{A, ...}</code> (in the <code>T</code> generic argument) by specifying the numeric integer index in the <code>P</code> generic argument, or if the desired type is wrapped in a <code>Field{L, V}</code> by setting <code>P</code> to the <code>String</code> matching the <code>L</code> generic argument to get the <code>V</code> value type. It is partway between a \"Type\" type and a Compute type as it returns the sub-type tree that is to be selected, but it is a compile-time failure if that is not possible, making it a compute type in that sense, and it is generally only useful for more complex generic functions.</li> <li><code>Len{A}</code> extracts the length of the inner type as an <code>Int</code>. For <code>Buffer</code>, <code>Tuple</code>, and <code>Either</code> this extracts the number of elements defined by the type. For <code>Array</code> this is a compile-time failure, and for everything else it is <code>1</code>.</li> <li><code>Size{T}</code> returns the size of the type in bytes if possible, and a compile-time failure otherwise. It currently fails in some situations that it should be able to calculate a value, so it would be best to avoid it when possible.</li> <li><code>FileStr{F}</code> returns a <code>String</code> of the file specified in the <code>F</code> argument, useful for embedding large text strings in the code in a legible way. If the file doesn't exist, this is a compile-time failure.</li> <li><code>Concat{A, B}</code> returns the <code>String</code> concatenation of two other <code>String</code>s, and fails if they are not a <code>String</code>.</li> <li><code>Env{K}</code> reads the environment variable <code>K</code> at compile-time and returns the value as a <code>String</code>. It is a compile-time failure if the value does not exist.</li> <li><code>EnvExists{K}</code> returns a <code>Bool</code> indicating if the environment variable key exists.</li> <li><code>Fail{M}</code> defines a failure type. The <code>M</code> must be a <code>String</code> that is the failure message. If this type is ever evaluated this message is emitted by the compiler for the developer. It is therefore only useful within conditional types.</li> <li><code>If{C, A, B}</code> is a conditional type. <code>C</code> must be a <code>Bool</code> while <code>A</code> and <code>B</code> can be any type. <code>A</code> is selected if <code>C</code> is <code>true</code>, otherwise <code>B</code> is selected.</li> <li><code>If{C, T}</code> is a variant of the conditional type above, except it expects a two-element <code>Tuple</code> instead of two distinct types. The zero index element of the <code>Tuple</code> is the <code>true</code> path, and the one index element is the <code>false</code> path.</li> <li><code>Env{K, D}</code> a variant of the <code>Env</code> type that accepts a default <code>String</code> as a second argument in case the <code>K</code> key does not exist. Logically equivalent to <code>type Env{K, D} = If{EnvExists{K}, Env{K}, D};</code> but a limitation in the compiler prevents overloading an intrinsic type with a user-defined type, so it is provided as another intrinsic type at the moment.</li> <li><code>Neg{A}</code> negates the provided value. It may only be an <code>Int</code> or a <code>Float</code>. All other types are a compile-time error.</li> <li><code>Add{A, B}</code> adds <code>A</code> to <code>B</code>. They must both be <code>Int</code> or <code>Float</code>. Any other type or a mismatch of types is a compile-time failure.</li> <li><code>Sub{A, B}</code> subtracts <code>B</code> from <code>A</code>. They must both be <code>Int</code> or <code>Float</code>. Any other type or a mismatch of types is a compile-time failure.</li> <li><code>Mul{A, B}</code> multiplies <code>A</code> and <code>B</code>. They must both be <code>Int</code> or <code>Float</code>. Any other type or a mismatch of types is a compile-time failure.</li> <li><code>Div{A, B}</code> divides <code>A</code> by <code>B</code>. They must both be <code>Int</code> or <code>Float</code>. Any other type or a mismatch of types is a compile-time failure.</li> <li><code>Mod{A, B}</code> performs the modulus (remainder) of <code>A</code> by <code>B</code>. They must both be <code>Int</code> only. Any other type is a compile-time failure.</li> <li><code>Pow{A, B}</code> raises <code>A</code> to the power of <code>B</code>. They must both be <code>Int</code> or both be <code>Float</code>. Any other type or a mismatch of types is a compile-time failure.</li> <li><code>Min{A, B}</code> returns the minimum of <code>A</code> and <code>B</code>. They must both be <code>Int</code> or both be <code>Float</code>. Any other type or a mismatch of types is a compile-time failure.</li> <li><code>Max{A, B}</code> returns the maximum of <code>A</code> and <code>B</code>. They must both be <code>Int</code> or both be <code>Float</code>. Any other type or a mismatch of types is a compile-time failure.</li> <li><code>Not{A}</code> performs a boolean or bitwise NOT. <code>A</code> must be <code>Int</code> or <code>Bool</code>. Any other type is a compile-time failure.</li> <li><code>And{A, B}</code> performs a boolean or bitwise AND. They must both be <code>Int</code> or both be <code>Bool</code>. Any other type or a mismatch of types is a compile-time failure.</li> <li><code>Or{A, B}</code> performs a boolean or bitwise OR. They must both be <code>Int</code> or both be <code>Bool</code>. Any other type or a mismatch of types is a compile-time failure.</li> <li><code>Xor{A, B}</code> performs a boolean or bitwise XOR. They must both be <code>Int</code> or both be <code>Bool</code>. Any other type or a mismatch of types is a compile-time failure.</li> <li><code>Nand{A, B}</code> performs a boolean or bitwise NAND. They must both be <code>Int</code> or both be <code>Bool</code>. Any other type or a mismatch of types is a compile-time failure.</li> <li><code>Nor{A, B}</code> performs a boolean or bitwise NOR. They must both be <code>Int</code> or both be <code>Bool</code>. Any other type or a mismatch of types is a compile-time failure.</li> <li><code>Xnor{A, B}</code> performs a boolean or bitwise XNOR. They must both be <code>Int</code> or both be <code>Bool</code>. Any other type or a mismatch of types is a compile-time failure.</li> <li><code>Eq{A, B}</code> returns a <code>Bool</code> if <code>A</code> and <code>B</code> are the same. Only returns <code>true</code> if both are the same <code>Int</code>, <code>Float</code>, <code>Bool</code>, or <code>String</code> value, <code>false</code> otherwise.</li> <li><code>Neq{A, B}</code> returns a <code>Bool</code> if <code>A</code> and <code>B</code> are the not the same. Only returns <code>false</code> if both are the <code>Int</code>, <code>Float</code>, <code>Bool</code>, or <code>String</code> values that differ, <code>true</code> otherwise.</li> <li><code>Lt{A, B}</code> returns <code>true</code> if both are <code>Int</code> or <code>Float</code> and <code>A</code> is less than <code>B</code>, returns <code>false</code> otherwise.</li> <li><code>Lte{A, B}</code> returns <code>true</code> if both are <code>Int</code> or <code>Float</code> and <code>A</code> is less than or equal to <code>B</code>, returns <code>false</code> otherwise.</li> <li><code>Gt{A, B}</code> returns <code>true</code> if both are <code>Int</code> or <code>Float</code> and <code>A</code> is greater than <code>B</code>, returns <code>false</code> otherwise.</li> <li><code>Gte{A, B}</code> returns <code>true</code> if both are <code>Int</code> or <code>Float</code> and <code>A</code> is greater than or equal to <code>B</code>, returns <code>false</code> otherwise.</li> </ul>"},{"location":"built_ins/#constructed-types","title":"Constructed Types","text":"<p>Beyond the \"Type\" types above, the majority of the \"every day useful\" types are constructed types in Alan. This will be broken into a few categories: Configuration types, Optional types, Primitive types, Utility types, and GPGPU types. This is the order these different types are defined within the root scope definition (because believe it or not, the Primitive types can't be bound without the Configuration types already defined, for instance).</p>"},{"location":"built_ins/#configuration-types","title":"Configuration Types","text":"<ul> <li><code>Test</code> is a <code>Bool</code> that indicates whether or not the program is being compiled as a test.</li> <li><code>Release</code> is a <code>Bool</code> that indicates whether or not the program is being compiled as a release build.</li> <li><code>Debug</code> is a <code>Bool</code> that indicates whether or not the program is being compiled as a debug build. (Currently, this is unused. You can't make a <code>Debug</code> build, yet.)</li> <li><code>Rs</code> is a <code>Bool</code> that indicates if the host language is Rust or not.</li> <li><code>Js</code> is a <code>Bool</code> that indicates if the host language is Javascript or not. (Currently always the inverse of <code>Rs</code>, but if more target languages are added, not always the case, so this is included for completeness.)</li> <li><code>Lin</code> is a <code>Bool</code> that indicates if the target platform is Linux.</li> <li><code>Win</code> is a <code>Bool</code> that indicates if the target platform is Windows.</li> <li><code>Mac</code> is a <code>Bool</code> that indicates if the target platform is MacOS.</li> <li><code>Browser</code> is a <code>Bool</code> that indicates if the target platform is a web browser. (Currently always the same as <code>Js</code>, but that may not always be true in the future.)</li> <li><code>RootBacking</code> is the reference to Alan standard library support library for the host language you are targeting. Everything within it should be bound for you already, so it should simply be an implementation detail.</li> </ul>"},{"location":"built_ins/#optional-types","title":"Optional Types","text":"<ul> <li><code>void</code> is an alias for <code>()</code>, a group of nothing, and defines a type that has no value.</li> <li><code>Self{T}</code> is an alias for <code>T</code>, allowing for an operator that should have zero impact on the resulting output (and is used to provide a cleaner-looking operator syntax for the <code>Buffer{T, S}</code> type.</li> <li><code>Error</code> is the special error type for Alan. Rather than go with the overly complicated conversion of error types in Rust in order to bubble up errors through your API, this singular <code>Error</code> type works more like Javascript's <code>Error</code>. It is planned to provide a mechanism to attach metadata to the <code>Error</code> beyond the basic error message, but this has not been fleshed out, yet.</li> <li><code>Fallible{T}</code> is <code>T | Error</code>. It's similar in concept to <code>Result&lt;T, E&gt;</code> in Rust, but the error type cannot be chosen, it is always <code>Error</code>. There are special built-in functions to work with this type.</li> <li><code>Maybe{T}</code> is <code>T | ()</code>. It is similar in concept to <code>Option&lt;T&gt;</code> in Rust. There are special built-in functions to work with this type (and most are identical to those for <code>Fallible{T}</code>).</li> </ul>"},{"location":"built_ins/#primitive-types","title":"Primitive Types","text":"<ul> <li><code>f32</code> constructs a 32-bit IEEE-754 floating point number.</li> <li><code>f64</code> constructs a 64-bit IEEE-754 floating point number.</li> <li><code>u8</code> constructs an 8-bit unsigned integer. (0 to 255)</li> <li><code>u16</code> constructs a 16-bit unsigned integer. (0 to 65_535)</li> <li><code>u32</code> constructs a 32-bit unsigned integer. (0 to 4_294_967_295)</li> <li><code>u64</code> constructs a 64-bit unsigned integer. (0 to 18_446_744_073_709_551_615)</li> <li><code>i8</code> constructs an 8-bit signed integer. (-128 to 127)</li> <li><code>i16</code> constructs a 16-bit signed integer. (-32_768 to 32_767)</li> <li><code>i32</code> constructs a 32-bit signed integer. (-2_147_483_648 to 2_147_483_647)</li> <li><code>i64</code> constructs a 64-bit signed integer. (-9_223_372_036_854_775_808 to 9_223_372_036_854_775_807)</li> <li><code>string</code> constructs a UTF-8 string. (Note: <code>String</code> is a compile-time string, while <code>string</code> is a run-time string. The default constructor function for a <code>String</code> produces a <code>string</code>.)</li> <li><code>bool</code> constructs a boolean. (Note: <code>Bool</code> is a compile-time boolean, while <code>bool</code> is a run-time boolean. The default constructor function for a <code>Bool</code> produces a <code>bool</code>.)</li> </ul>"},{"location":"built_ins/#utility-types","title":"Utility Types","text":"<ul> <li><code>ExitCode</code> is a special type that the <code>main</code> function may return to indicate a non-successful execution to the parent process.</li> <li><code>Instant</code> and <code>Duration</code> are bound from Rust when compiling to Rust to allow for performance checking at run-time in Rust. <code>Performance</code> is similarly bound when compiling to Javascript for those purposes there. These types are not unified, but a small collection of functions with very similar calling structure allows one set or the other to be used efficiently in your code.</li> <li><code>uuid</code> provides a UUIDv4 type. (v4 is the correct choice for a UUID the vast majority of the time. If you really need a different kind, you need to BYOB.)</li> <li><code>Dict{K, V}</code> is a dictionary type. It maintains key insertion order when serialized to an <code>Array{(K, V)}</code> or similar.</li> <li><code>Set{V}</code> is a set type. It does not maintain insertion order.</li> <li><code>Tree{T}</code> is a tree type. It allows recursive-like data structures without an actually recursive type.</li> <li><code>Node{T}</code> is a node type. It represents a singular node within a tree.</li> <li><code>Testing</code> is a special type that only exists when <code>Test</code> is true, and is used for defining a test suite to execute during the test.</li> </ul>"},{"location":"built_ins/#gpgpu-types","title":"GPGPU Types","text":"<ul> <li><code>BufferUsages</code> is a type indicating how a GPU Buffer's memory may be accessed. The vast majority of the time you will not need to use this directly, but it is available for unusual needs.</li> <li><code>GBufferRaw</code> is the GPU Buffer type. It represents a block of memory and is not a generic type. This type is not meant to be used directly, it's the direct type the WebGPU API uses as it doesn't know what kind of data you're feeding to your shader (and it's up to you to not mess it up if you write a raw shader). It is somewhere in between an <code>Array{T}</code> and <code>Buffer{T, S}</code>: it is sized at run-time, but once created its size may not be altered.</li> <li><code>GBuffer{T}</code> is the GPU Buffer type you're intended to use. It has the related CPU type as its generic type so you can't accidentally write the wrong kind of data to it or garble the data when you read from it.</li> <li><code>GBufferTagged</code> is a type used internally by many of the GPU types below to keep metadata about the type of data stored inside of the <code>GBufferRaw</code> around so it can properly generate the WGSL shader code. You shouldn't need to use it directly.</li> <li><code>GPGPU</code> is a type representing work to do on the GPU. It can be constructed manually but is meant to be handled by other built-in functions, instead.</li> <li><code>WgpuType{N}</code> is a meta-type for defining an AST node for the various primitive GPU types. By being a singular generic type the primary <code>GPGPU</code> constructor function <code>build</code> can accept any of them and successfully build WGSL shadercode that eventually produces the desired value of the desired type.</li> <li><code>WgpuTypeMap</code> is a mapping of CPU primitive types to GPU primitive types. It is used in the process of converting a <code>GBuffer{T}</code> to a <code>GBufferTagged</code> but is not ever directly constructed, instead acting as a kind of compile-time dictionary.</li> <li><code>gu32</code> is a GPU 32-bit unsigned integer.</li> <li><code>gi32</code> is a GPU 32-bit signed integer.</li> <li><code>gf32</code> is a GPU 32-bit IEEE-754 floating point number.</li> <li><code>gbool</code> is a GPU boolean.</li> <li><code>gvec2u</code> is a 2-element unsigned integer vector.</li> <li><code>gvec2i</code> is a 2-element signed integer vector.</li> <li><code>gvec2f</code> is a 2-element floating point vector.</li> <li><code>gvec2b</code> is a 2-element boolean vector.</li> <li><code>gvec3u</code> is a 3-element unsigned integer vector.</li> <li><code>gvec3i</code> is a 3-element signed integer vector.</li> <li><code>gvec3f</code> is a 3-element floating point vector.</li> <li><code>gvec3b</code> is a 3-element boolean vector.</li> <li><code>gvec4u</code> is a 4-element unsigned integer vector.</li> <li><code>gvec4i</code> is a 4-element signed integer vector.</li> <li><code>gvec4f</code> is a 4-element floating point vector.</li> <li><code>gvec4b</code> is a 4-element boolean vector.</li> <li><code>gmat2x2f</code> is a 2x2 matrix (all matrices are floating point in WGSL)</li> <li><code>gmat2x3f</code> is a 2x3 matrix.</li> <li><code>gmat2x4f</code> is a 2x4 matrix.</li> <li><code>gmat3x2f</code> is a 3x2 matrix.</li> <li><code>gmat3x3f</code> is a 3x3 matrix.</li> <li><code>gmat3x4f</code> is a 3x4 matrix.</li> <li><code>gmat4x2f</code> is a 4x2 matrix.</li> <li><code>gmat4x3f</code> is a 4x3 matrix.</li> <li><code>gmat4x4f</code> is a 4x4 matrix.</li> <li><code>Window</code> is a special type for configuring a window for rendering to the screen (rather than doing GPGPU work).</li> <li><code>Frame</code> is a special type for accessing the context on the GPU for the rendering of an individual frame to render.</li> </ul>"},{"location":"built_ins/#type-operators","title":"Type Operators","text":"<p>Many, but not all, of the built-in types are bound to operators in the type system. Some of these, like <code>Tuple{A, ...}</code>, become symbols you don't normally expect of operators (in this case, it becomes <code>,</code>). Operators also have a precedence level. In Alan the higher the precedence number, the more \"greedy\" it is, so multiplication has a higher precedence level than addition, for example. Tie-breaker precedence is left-to-right evaluation.</p> <p>Alan has a special type operator syntax so you can declare new operators for the type system and specify the precedence they should take; but these cannot be exported out of your module, they need to be re-declared in any file you wish to use the custom type operator, but this isn't a huge burden as they are all one-line, top-level statements and deviation from the standard type syntax should be explicit, anyways.</p> <p>This means the only type operator precedence table you need to know is the one baked into the root scope of every module, listed below:</p> Type -fix Symbol Precedence <code>Self</code> Postfix <code>]</code> 11 <code>Prop</code> Infix <code>.</code> 6 <code>Array</code> Postfix <code>[]</code> 5 <code>Fallible</code> Postfix <code>!</code> 5 <code>Maybe</code> Postfix <code>?</code> 5 <code>Not</code> Prefix <code>~</code> 5 <code>Pow</code> Infix <code>**</code> 5 <code>And</code> Infix <code>&amp;&amp;</code> 4 <code>Div</code> Infix <code>/</code> 4 <code>Function</code> Infix <code>-&gt;</code> 4 <code>Mod</code> Infix <code>%</code> 4 <code>Mul</code> Infix <code>*</code> 4 <code>Nand</code> Infix <code>!&amp;</code> 4 <code>Add</code> Infix <code>+</code> 3 <code>Nor</code> Infix <code>!|</code> 3 <code>Or</code> Infix <code>||</code> 3 <code>Sub</code> Infix <code>-</code> 3 <code>Xnor</code> Infix <code>!^</code> 3 <code>Xor</code> Infix <code>^</code> 3 <code>Buffer</code> Infix <code>[</code> 2 <code>Dependency</code> Infix <code>@</code> 1 <code>Eq</code> Infix <code>==</code> 1 <code>Field</code> Infix <code>:</code> 1 <code>Gt</code> Infix <code>&gt;</code> 1 <code>Gte</code> Infix <code>&gt;=</code> 1 <code>If</code> Infix <code>:?</code> 1 <code>Lt</code> Infix <code>&lt;</code> 1 <code>Lte</code> Infix <code>&lt;=</code> 1 <code>Neq</code> Infix <code>!=</code> 1 <code>AnyOf</code> Infix <code>&amp;</code> 0 <code>Call</code> Infix <code>::</code> 0 <code>Either</code> Infix <code>|</code> 0 <code>From</code> Prefix <code>&lt;--</code> 0 <code>Import</code> Infix <code>&lt;-</code> 0 <code>Tuple</code> Infix <code>,</code> 0"},{"location":"built_ins/#functions","title":"Functions","text":"<p>Functions in Alan work a bit differently than in most programming languages. Function dispatch is based on both the function name and the arguments (number and type) they are called with. This way you can have both <code>add(i16, i16)</code> and <code>add(f32, f32)</code> and they do not overwrite each other.</p> <p>Generic functions also automatically attempt to infer their generic arguments at the callsite (which is doable if the generic arguments are all used in the input arguments of the function, not if any of them only exist in the output), so an <code>add{T}(T, T)</code> will also match for a call to an <code>add</code> function.</p> <p>How does Alan decide which function is the \"best\" to use if multiple match? The other way Alan differs from most languages is that function definition order matters, so the most-recently-defined matching function wins.</p> <p>So you can define a generic function that should work for all types you care about, but then afterwards define specialized functions for particular types where optimizations are possible and as they were defined later, code that follows after that definition will prefer the specialized versions over the generic version.</p> <p>This influences the order in which explicit functions are defined in Alan's root scope; the generic functions that apply as broadly as possible are first, and specialized functions follow.</p> <p>Explicit functions? That's the third way that Alan differs from most languages. In most languages types and very rigid, and certain kinds of types get certain language constructs, such as accessing properties from a struct. In Alan all of this is done with functions. A property access is simply taking a value of one type in and returning a value of a different type; it just happens to be a sub-type of the original type from the language's perspective. So instead in Alan all single-argument functions can be called with property syntax.</p> <p>So therefore when you define a new type, you're also implicitly defining a set of functions that work with that type to be able to access sub-types, construct the type, etc.</p> <p>This is only not true when you bind a native type. Alan has no idea what can be done with a bound native type, so you must also define all of the function calls that will work with that native type. Because the primitive types in Alan are all bound to the host language for better performance, there are several explicit functions to be described that would be implicitly defined otherwise.</p> <p>For clarity, the table of functions will be broken up into broad categories, and whether or not it is explicit or implicit will be called out, however, implicit functions from the root scope are only involving the <code>Tree{T}</code>, <code>Node{T}</code> and some of the GPGPU types, and even there explicit constructor and accessor functions have been defined for easier use of them. Because of this, most tables will not have an <code>Is Explicit</code> column, and when that is so, you can assume that they all are.</p>"},{"location":"built_ins/#functions-for-potentially-every-type","title":"Functions for (potentially) every type","text":"Name Type Description <code>clone{T}</code> <code>T -&gt; T</code> Creates a copy of the data <code>void{T}</code> <code>T -&gt; void</code> Consumes a value, useful for one-line side-effect functions <code>void</code> <code>() -&gt; void</code> Explicitly returns nothing <code>store{T}</code> <code>(Mut{T}, T) -&gt; T</code> Replaces the first arg with the second, returning the first"},{"location":"built_ins/#fallbile-maybe-and-either-functions","title":"Fallbile, Maybe, and Either functions","text":"Name Type Description Explicit <code>Maybe{T}</code> <code>T -&gt; T?</code> Wraps a value in a <code>Maybe{T}</code> \u274c <code>Maybe{T}</code> <code>() -&gt; T?</code> Wraps a <code>void</code> in a <code>Maybe{T}</code> \u274c <code>Maybe{T}</code> <code>T! -&gt; T?</code> Converts a <code>Fallible</code> into a <code>Maybe</code> \u2705 <code>Fallible{T}</code> <code>T -&gt; T!</code> Wraps a value in a <code>Fallible{T}</code> \u274c <code>Fallible{T}</code> <code>Error -&gt; T!</code> Wraps an <code>Error</code> in a <code>Fallible{T}</code> \u274c <code>Fallible{T}</code> <code>(T?, Error) -&gt; T!</code> Converts a <code>Maybe</code> into a <code>Fallible</code> \u2705 <code>getOr{T, U}</code> <code>(U, T) -&gt; T</code> Converts a value of type <code>U</code> to <code>T</code> or defaults \u2705 <code>getOr{T}</code> <code>(T?, T) -&gt; T</code> Unwraps a <code>Maybe{T}</code> or returns a default <code>T</code> \u2705 <code>getOr{T}</code> <code>(T!, T) -&gt; T</code> Unwraps a <code>Fallible{T}</code> or returns a default <code>T</code> \u2705 <code>getOrExit{T}</code> <code>T! -&gt; T</code> Unwraps a <code>Fallible{T}</code> or halts the program \u2705 <code>getOrExit{T}</code> <code>T? -&gt; T</code> Unwraps a <code>Maybe{T}</code> or halts the program \u2705 <code>Error{T}</code> <code>string -&gt; T!</code> Turns an error message into a <code>Fallible{T}</code> \u2705 <code>Error</code> <code>string -&gt; Error</code> Turns an error message into an <code>Error</code> \u2705 <code>exists{T}</code> <code>T? -&gt; bool</code> Returns whether a <code>Maybe{T}</code> has a value \u2705 <code>string</code> <code>Error -&gt; string</code> Returns the error message from the <code>Error</code> \u2705"},{"location":"built_ins/#primitive-type-casting-functions","title":"Primitive type casting functions","text":"Name Type Description <code>f32</code> <code>i8 -&gt; f32</code> Casts the <code>i8</code> integer into an <code>f32</code> <code>f32</code> <code>i16 -&gt; f32</code> Casts the <code>i16</code> integer into an <code>f32</code> <code>f32</code> <code>i32 -&gt; f32</code> Casts the <code>i32</code> integer into an <code>f32</code> <code>f32</code> <code>i64 -&gt; f32</code> Casts the <code>i64</code> integer into an <code>f32</code> <code>f32</code> <code>u8 -&gt; f32</code> Casts the <code>u8</code> integer into an <code>f32</code> <code>f32</code> <code>u16 -&gt; f32</code> Casts the <code>u16</code> integer into an <code>f32</code> <code>f32</code> <code>u32 -&gt; f32</code> Casts the <code>u32</code> integer into an <code>f32</code> <code>f32</code> <code>u64 -&gt; f32</code> Casts the <code>u64</code> integer into an <code>f32</code> <code>f32</code> <code>f32 -&gt; f32</code> Returns the original <code>f32</code> back <code>f32</code> <code>f64 -&gt; f32</code> Casts the <code>f64</code> float into an <code>f32</code> <code>f32</code> <code>string -&gt; f32!</code> Parses the <code>string</code> for an <code>f32</code>, returns <code>f32!</code> in case it cannot <code>f64</code> <code>i8 -&gt; f64</code> Casts the <code>i8</code> integer into an <code>f64</code> <code>f64</code> <code>i16 -&gt; f64</code> Casts the <code>i16</code> integer into an <code>f64</code> <code>f64</code> <code>i32 -&gt; f64</code> Casts the <code>i32</code> integer into an <code>f64</code> <code>f64</code> <code>i64 -&gt; f64</code> Casts the <code>i64</code> integer into an <code>f64</code> <code>f64</code> <code>u8 -&gt; f64</code> Casts the <code>u8</code> integer into an <code>f64</code> <code>f64</code> <code>u16 -&gt; f64</code> Casts the <code>u16</code> integer into an <code>f64</code> <code>f64</code> <code>u32 -&gt; f64</code> Casts the <code>u32</code> integer into an <code>f64</code> <code>f64</code> <code>u64 -&gt; f64</code> Casts the <code>u64</code> integer into an <code>f64</code> <code>f64</code> <code>f32 -&gt; f64</code> Casts the <code>f32</code> float into an <code>f64</code> <code>f64</code> <code>f64 -&gt; f64</code> Returns the original <code>f64</code> back <code>f64</code> <code>string -&gt; f64!</code> Parses the <code>string</code> for an <code>f64</code>, returns <code>f64!</code> in case it cannot <code>u8</code> <code>i8 -&gt; u8</code> Casts the <code>i8</code> integer into a <code>u8</code> <code>u8</code> <code>i16 -&gt; u8</code> Casts the <code>i16</code> integer into a <code>u8</code> <code>u8</code> <code>i32 -&gt; u8</code> Casts the <code>i32</code> integer into a <code>u8</code> <code>u8</code> <code>i64 -&gt; u8</code> Casts the <code>i64</code> integer into a <code>u8</code> <code>u8</code> <code>u8 -&gt; u8</code> Returns the original <code>u8</code> back <code>u8</code> <code>u16 -&gt; u8</code> Casts the <code>u16</code> itneger into a <code>u8</code> <code>u8</code> <code>u32 -&gt; u8</code> Casts the <code>u32</code> integer into a <code>u8</code> <code>u8</code> <code>u64 -&gt; u8</code> Casts the <code>u64</code> integer into a <code>u8</code> <code>u8</code> <code>f32 -&gt; u8</code> Casts the <code>f32</code> float into a <code>u8</code> <code>u8</code> <code>f64 -&gt; u8</code> Casts the <code>f64</code> float into a <code>u8</code> <code>u8</code> <code>string -&gt; u8!</code> Parses the <code>string</code> for a <code>u8</code>, returns <code>u8!</code> in case it cannot <code>u16</code> <code>i8 -&gt; u16</code> Casts the <code>i8</code> integer into a <code>u16</code> <code>u16</code> <code>i16 -&gt; u16</code> Casts the <code>i16</code> integer into a <code>u16</code> <code>u16</code> <code>i32 -&gt; u16</code> Casts the <code>i32</code> integer into a <code>u16</code> <code>u16</code> <code>i64 -&gt; u16</code> Casts the <code>i64</code> integer into a <code>u16</code> <code>u16</code> <code>u8 -&gt; u16</code> Casts the <code>u8</code> itneger into a <code>u16</code> <code>u16</code> <code>u16 -&gt; u16</code> Returns the original <code>u16</code> back <code>u16</code> <code>u32 -&gt; u16</code> Casts the <code>u32</code> integer into a <code>u16</code> <code>u16</code> <code>u64 -&gt; u16</code> Casts the <code>u64</code> integer into a <code>u16</code> <code>u16</code> <code>f32 -&gt; u16</code> Casts the <code>f32</code> float into a <code>u16</code> <code>u16</code> <code>f64 -&gt; u16</code> Casts the <code>f64</code> float into a <code>u16</code> <code>u16</code> <code>string -&gt; u16!</code> Parses the <code>string</code> for a <code>u16</code>, returns <code>u16!</code> in case it cannot <code>u32</code> <code>i8 -&gt; u32</code> Casts the <code>i8</code> integer into a <code>u32</code> <code>u32</code> <code>i16 -&gt; u32</code> Casts the <code>i16</code> integer into a <code>u32</code> <code>u32</code> <code>i32 -&gt; u32</code> Casts the <code>i32</code> integer into a <code>u32</code> <code>u32</code> <code>i64 -&gt; u32</code> Casts the <code>i64</code> integer into a <code>u32</code> <code>u32</code> <code>u8 -&gt; u32</code> Casts the <code>u8</code> itneger into a <code>u32</code> <code>u32</code> <code>u16 -&gt; u32</code> Casts the <code>u16</code> integer into a <code>u32</code> <code>u32</code> <code>u32 -&gt; u32</code> Returns the original <code>u32</code> back <code>u32</code> <code>u64 -&gt; u32</code> Casts the <code>u64</code> integer into a <code>u32</code> <code>u32</code> <code>f32 -&gt; u32</code> Casts the <code>f32</code> float into a <code>u32</code> <code>u32</code> <code>f64 -&gt; u32</code> Casts the <code>f64</code> float into a <code>u32</code> <code>u32</code> <code>string -&gt; u32!</code> Parses the <code>string</code> for a <code>u32</code>, returns <code>u32!</code> in case it cannot <code>u64</code> <code>i8 -&gt; u64</code> Casts the <code>i8</code> integer into a <code>u64</code> <code>u64</code> <code>i16 -&gt; u64</code> Casts the <code>i16</code> integer into a <code>u64</code> <code>u64</code> <code>i32 -&gt; u64</code> Casts the <code>i32</code> integer into a <code>u64</code> <code>u64</code> <code>i64 -&gt; u64</code> Casts the <code>i64</code> integer into a <code>u64</code> <code>u64</code> <code>u8 -&gt; u64</code> Casts the <code>u8</code> itneger into a <code>u64</code> <code>u64</code> <code>u16 -&gt; u64</code> Casts the <code>u16</code> integer into a <code>u64</code> <code>u64</code> <code>u32 -&gt; u64</code> Casts the <code>u32</code> integer into a <code>u64</code> <code>u64</code> <code>u64 -&gt; u64</code> Returns the original <code>u64</code> back <code>u64</code> <code>f32 -&gt; u64</code> Casts the <code>f32</code> float into a <code>u64</code> <code>u64</code> <code>f64 -&gt; u64</code> Casts the <code>f64</code> float into a <code>u64</code> <code>u64</code> <code>string -&gt; u64!</code> Parses the <code>string</code> for a <code>u64</code>, returns <code>u64!</code> in case it cannot <code>i8</code> <code>i8 -&gt; i8</code> Returns the original <code>i8</code> back <code>i8</code> <code>i16 -&gt; i8</code> Casts the <code>i16</code> integer into a <code>i8</code> <code>i8</code> <code>i32 -&gt; i8</code> Casts the <code>i32</code> integer into a <code>i8</code> <code>i8</code> <code>i64 -&gt; i8</code> Casts the <code>i64</code> integer into a <code>i8</code> <code>i8</code> <code>u8 -&gt; i8</code> Casts the <code>u8</code> integer into a <code>i8</code> <code>i8</code> <code>u16 -&gt; i8</code> Casts the <code>u16</code> itneger into a <code>i8</code> <code>i8</code> <code>u32 -&gt; i8</code> Casts the <code>u32</code> integer into a <code>i8</code> <code>i8</code> <code>u64 -&gt; i8</code> Casts the <code>u64</code> integer into a <code>i8</code> <code>i8</code> <code>f32 -&gt; i8</code> Casts the <code>f32</code> float into a <code>i8</code> <code>i8</code> <code>f64 -&gt; i8</code> Casts the <code>f64</code> float into a <code>i8</code> <code>i8</code> <code>string -&gt; i8!</code> Parses the <code>string</code> for a <code>i8</code>, returns <code>i8!</code> in case it cannot <code>i16</code> <code>i8 -&gt; i16</code> Casts the <code>i8</code> integer into a <code>i16</code> <code>i16</code> <code>i16 -&gt; i16</code> Returns the original <code>i16</code> back <code>i16</code> <code>i32 -&gt; i16</code> Casts the <code>i32</code> integer into a <code>i16</code> <code>i16</code> <code>i64 -&gt; i16</code> Casts the <code>i64</code> integer into a <code>i16</code> <code>i16</code> <code>u8 -&gt; i16</code> Casts the <code>u8</code> integer into a <code>i16</code> <code>i16</code> <code>u16 -&gt; i16</code> Casts the <code>u16</code> itneger into a <code>i16</code> <code>i16</code> <code>u32 -&gt; i16</code> Casts the <code>u32</code> integer into a <code>i16</code> <code>i16</code> <code>u64 -&gt; i16</code> Casts the <code>u64</code> integer into a <code>i16</code> <code>i16</code> <code>f32 -&gt; i16</code> Casts the <code>f32</code> float into a <code>i16</code> <code>i16</code> <code>f64 -&gt; i16</code> Casts the <code>f64</code> float into a <code>i16</code> <code>i16</code> <code>string -&gt; i16!</code> Parses the <code>string</code> for a <code>i16</code>, returns <code>i16!</code> in case it cannot <code>i32</code> <code>i8 -&gt; i32</code> Casts the <code>i8</code> integer into a <code>i32</code> <code>i32</code> <code>i16 -&gt; i32</code> Casts the <code>i16</code> integer into a <code>i32</code> <code>i32</code> <code>i32 -&gt; i32</code> Returns the original <code>i32</code> back <code>i32</code> <code>i64 -&gt; i32</code> Casts the <code>i64</code> integer into a <code>i32</code> <code>i32</code> <code>u8 -&gt; i32</code> Casts the <code>u8</code> integer into a <code>i32</code> <code>i32</code> <code>u16 -&gt; i32</code> Casts the <code>u16</code> itneger into a <code>i32</code> <code>i32</code> <code>u32 -&gt; i32</code> Casts the <code>u32</code> integer into a <code>i32</code> <code>i32</code> <code>u64 -&gt; i32</code> Casts the <code>u64</code> integer into a <code>i32</code> <code>i32</code> <code>f32 -&gt; i32</code> Casts the <code>f32</code> float into a <code>i32</code> <code>i32</code> <code>f64 -&gt; i32</code> Casts the <code>f64</code> float into a <code>i32</code> <code>i32</code> <code>string -&gt; i32!</code> Parses the <code>string</code> for a <code>i32</code>, returns <code>i32!</code> in case it cannot <code>i64</code> <code>i8 -&gt; i64</code> Casts the <code>i8</code> integer into a <code>i64</code> <code>i64</code> <code>i16 -&gt; i64</code> Casts the <code>i16</code> integer into a <code>i64</code> <code>i64</code> <code>i32 -&gt; i64</code> Casts the <code>i32</code> integer into a <code>i64</code> <code>i64</code> <code>i64 -&gt; i64</code> Returns the original <code>i64</code> back <code>i64</code> <code>u8 -&gt; i64</code> Casts the <code>u8</code> integer into a <code>i64</code> <code>i64</code> <code>u16 -&gt; i64</code> Casts the <code>u16</code> itneger into a <code>i64</code> <code>i64</code> <code>u32 -&gt; i64</code> Casts the <code>u32</code> integer into a <code>i64</code> <code>i64</code> <code>u64 -&gt; i64</code> Casts the <code>u64</code> integer into a <code>i64</code> <code>i64</code> <code>f32 -&gt; i64</code> Casts the <code>f32</code> float into a <code>i64</code> <code>i64</code> <code>f64 -&gt; i64</code> Casts the <code>f64</code> float into a <code>i64</code> <code>i64</code> <code>string -&gt; i64!</code> Parses the <code>string</code> for a <code>i64</code>, returns <code>i64!</code> in case it cannot <code>bool</code> <code>i8 -&gt; bool</code> Casts the <code>i8</code> to a <code>bool</code> <code>bool</code> <code>i16 -&gt; bool</code> Casts the <code>i16</code> to a <code>bool</code> <code>bool</code> <code>i32 -&gt; bool</code> Casts the <code>i32</code> to a <code>bool</code> <code>bool</code> <code>i64 -&gt; bool</code> Casts the <code>i64</code> to a <code>bool</code> <code>bool</code> <code>u8 -&gt; bool</code> Casts the <code>u8</code> to a <code>bool</code> <code>bool</code> <code>u16 -&gt; bool</code> Casts the <code>u16</code> to a <code>bool</code> <code>bool</code> <code>u32 -&gt; bool</code> Casts the <code>u32</code> to a <code>bool</code> <code>bool</code> <code>u64 -&gt; bool</code> Casts the <code>u64</code> to a <code>bool</code> <code>bool</code> <code>f32 -&gt; bool</code> Casts the <code>f32</code> to a <code>bool</code> <code>bool</code> <code>f64 -&gt; bool</code> Casts the <code>f64</code> to a <code>bool</code> <code>bool</code> <code>string -&gt; bool</code> Casts the <code>string</code> to a <code>bool</code> (<code>'true'</code> is <code>true</code>, else <code>false</code>)"},{"location":"built_ins/#bitcasting-functions","title":"Bitcasting functions","text":"Name Type Description <code>asU8</code> <code>u8 -&gt; u8</code> Returns the original value <code>asU8</code> <code>i8 -&gt; u8</code> Returns the <code>i8</code> byte as a <code>u8</code> <code>asU16</code> <code>u16 -&gt; u16</code> Returns the original value <code>asU16</code> <code>i16 -&gt; u16</code> Returns the <code>i16</code> byte as a <code>u16</code> <code>asU32</code> <code>u32 -&gt; u32</code> Returns the original value <code>asU32</code> <code>i32 -&gt; u32</code> Returns the <code>i32</code> byte as a <code>u32</code> <code>asU32</code> <code>f32 -&gt; u32</code> Returns the <code>f32</code> byte as a <code>u32</code> <code>asU64</code> <code>u64 -&gt; u64</code> Returns the original value <code>asU64</code> <code>i64 -&gt; u64</code> Returns the <code>i64</code> byte as a <code>u64</code> <code>asU64</code> <code>f64 -&gt; u64</code> Returns the <code>f64</code> byte as a <code>u64</code> <code>asI8</code> <code>u8 -&gt; i8</code> Returns the <code>u8</code> byte as an <code>i8</code> <code>asI8</code> <code>i8 -&gt; i8</code> Returns the original value <code>asI16</code> <code>u16 -&gt; i16</code> Returns the <code>u16</code> byte as an <code>i16</code> <code>asI16</code> <code>i16 -&gt; i16</code> Returns the original value <code>asI32</code> <code>u32 -&gt; i32</code> Returns the <code>u32</code> byte as an <code>i32</code> <code>asI32</code> <code>i32 -&gt; i32</code> Returns the original value <code>asI32</code> <code>f32 -&gt; i32</code> Returns the <code>f32</code> byte as an <code>i32</code> <code>asI64</code> <code>u64 -&gt; i64</code> Returns the <code>u64</code> byte as an <code>i64</code> <code>asI64</code> <code>i64 -&gt; i64</code> Returns the original value <code>asI64</code> <code>f64 -&gt; i64</code> Returns the <code>f64</code> byte as an <code>i64</code> <code>asF32</code> <code>u32 -&gt; f32</code> Returns the <code>u32</code> byte as an <code>f32</code> <code>asF32</code> <code>i32 -&gt; f32</code> Returns the <code>i32</code> byte as an <code>f32</code> <code>asF32</code> <code>f32 -&gt; f32</code> Returns the original value <code>asF64</code> <code>u64 -&gt; f64</code> Returns the <code>u64</code> byte as an <code>f64</code> <code>asF64</code> <code>i64 -&gt; f64</code> Returns the <code>i64</code> byte as an <code>f64</code> <code>asF64</code> <code>f64 -&gt; f64</code> Returns the original value"},{"location":"built_ins/#boolean-related-functions","title":"Boolean-related functions","text":"Name Type Description <code>and</code> <code>(bool, bool) -&gt; bool</code> Boolean AND (<code>true</code> if both inputs <code>true</code>) <code>or</code> <code>(bool, bool) -&gt; bool</code> Boolean OR  (<code>true</code> if any input <code>true</code>) <code>xor</code> <code>(bool, bool) -&gt; bool</code> Boolean XOR (<code>true</code> if only one input <code>true</code>) <code>not</code> <code>bool -&gt; bool</code> Boolean NOT (flips <code>true</code> and <code>false</code>) <code>nand</code> <code>(bool, bool) -&gt; bool</code> Boolean NAND (<code>true</code> if any input <code>false</code>) <code>nor</code> <code>(bool, bool) -&gt; bool</code> Boolean NOR (<code>true</code> if both inputs <code>false</code>) <code>xnor</code> <code>(bool, bool) -&gt; bool</code> Boolean XNOR (<code>true</code> if both inputs the same) <code>eq</code> <code>(bool, bool) -&gt; bool</code> Equals (<code>true</code> if both inputs the same, see <code>xnor</code>) <code>neq</code> <code>(bool, bool) -&gt; bool</code> Not Equals (<code>true</code> if both inputs differ, see <code>xor</code>) <code>if{T}</code> <code>(bool, T) -&gt; T?</code> Returns a <code>Maybe{T}</code> that has the specified value or not <code>if{T}</code> <code>(bool, T, T) -&gt; T</code> Returns the first or second <code>T</code> depending on the <code>bool</code> <code>if{T}</code> <code>(bool, () -&gt; T) -&gt; T?</code> Returns a <code>Maybe{T}</code> that may have the output of the callback <code>if{T}</code> <code>(bool, () -&gt; T, () -&gt; T) -&gt; T</code> Returns the first or second <code>T</code> function result <code>if</code> <code>(bool, () -&gt; ()) -&gt; ()</code> Runs the side-effect function only if <code>true</code> <code>if</code> <code>(bool, () -&gt; (), () -&gt; ()) -&gt; ()</code> Runs either the first or second side-effect function"},{"location":"built_ins/#float-related-functions","title":"Float-related functions","text":"Name Type Description <code>add</code> <code>(f32, f32) -&gt; f32</code> Adds two <code>f32</code>s together <code>sub</code> <code>(f32, f32) -&gt; f32</code> Subtracts two <code>f32</code>s <code>mul</code> <code>(f32, f32) -&gt; f32</code> Multiplies two <code>f32</code>s <code>div</code> <code>(f32, f32) -&gt; f32</code> Divides two <code>f32</code>s <code>sqrt</code> <code>f32 -&gt; f32</code> Returns the square root of an <code>f32</code> <code>pow</code> <code>(f32, f32) -&gt; f32</code> Raises the first <code>f32</code> to the power of the second <code>abs</code> <code>f32 -&gt; f32</code> Returns the positive version of the <code>f32</code> <code>neg</code> <code>f32 -&gt; f32</code> Multiplies the <code>f32</code> by <code>-1</code> <code>eq</code> <code>(f32, f32) -&gt; bool</code> Returns <code>true</code> if the two <code>f32</code>s are equal <code>neq</code> <code>(f32, f32) -&gt; bool</code> Returns <code>true</code> if the two <code>f32</code>s are not equal <code>lt</code> <code>(f32, f32) -&gt; bool</code> Returns <code>true</code> if the first <code>f32</code> is less than the second <code>lte</code> <code>(f32, f32) -&gt; bool</code> Returns <code>true</code> if the first <code>f32</code> is less than or equal to the second <code>gt</code> <code>(f32, f32) -&gt; bool</code> Returns <code>true</code> if the first <code>f32</code> is greater than the second <code>gte</code> <code>(f32, f32) -&gt; bool</code> Returns <code>true</code> if the first <code>f32</code> is greater than or equal to the second <code>min</code> <code>(f32, f32) -&gt; f32</code> Returns the smaller <code>f32</code> <code>max</code> <code>(f32, f32) -&gt; f32</code> Returns the larger <code>f32</code> <code>clamp</code> <code>(f32, f32, f32) -&gt; f32</code> Clamps the first <code>f32</code> to be above the second and below the third <code>saturate</code> <code>f32 -&gt; f32</code> Clamps the <code>f32</code> between <code>0</code> and <code>1</code> <code>floor</code> <code>f32 -&gt; f32</code> Rounds the <code>f32</code> down to the nearest integer <code>ceil</code> <code>f32 -&gt; f32</code> Rounds the <code>f32</code> up to the nearest integer <code>acos</code> <code>f32 -&gt; f32</code> Calculates the arccosine of the <code>f32</code> <code>acosh</code> <code>f32 -&gt; f32</code> Calculates the hyperbolic arccosine of the <code>f32</code> <code>asin</code> <code>f32 -&gt; f32</code> Calculates the arcsine of the <code>f32</code> <code>asinh</code> <code>f32 -&gt; f32</code> Calculates the hyperbolic arcsine of the <code>f32</code> <code>atan</code> <code>f32 -&gt; f32</code> Calculates the arctangent of the <code>f32</code> <code>atan2</code> <code>(f32, f32) -&gt; f32</code> Calculates the arctangent of the two sides defined by the <code>f32</code>s <code>cos</code> <code>f32 -&gt; f32</code> Calculates the cosine of the <code>f32</code> <code>cosh</code> <code>f32 -&gt; f32</code> Calculates the hyperbolic cosine of the <code>f32</code> <code>sin</code> <code>f32 -&gt; f32</code> Calculates the sine of the <code>f32</code> <code>sinh</code> <code>f32 -&gt; f32</code> Calculates the hyperbolic sine of the <code>f32</code> <code>tan</code> <code>f32 -&gt; f32</code> Calculates the tangent of the <code>f32</code> <code>tanh</code> <code>f32 -&gt; f32</code> Calculates the hyperbolic tangent of the <code>f32</code> <code>exp</code> <code>f32 -&gt; f32</code> Raises <code>e</code> to the power of the <code>f32</code> <code>ln</code> <code>f32 -&gt; f32</code> Calculates the natural log of the <code>f32</code> <code>log2</code> <code>f32 -&gt; f32</code> Calculates the log base 2 of the <code>f32</code> <code>log10</code> <code>f32 -&gt; f32</code> Calculates the log base 10 of the <code>f32</code> <code>sec</code> <code>f32 -&gt; f32</code> Calculates the secant of the <code>f32</code> <code>csc</code> <code>f32 -&gt; f32</code> Calculates the cosecant of the <code>f32</code> <code>cot</code> <code>f32 -&gt; f32</code> Calculates the cotangent of the <code>f32</code> <code>asec</code> <code>f32 -&gt; f32</code> Calculates the arcsecant of the <code>f32</code> <code>acsc</code> <code>f32 -&gt; f32</code> Calculates the arccosecant of the <code>f32</code> <code>acot</code> <code>f32 -&gt; f32</code> Calculates the arccotangent of the <code>f32</code> <code>sech</code> <code>f32 -&gt; f32</code> Calculates the hyperbolic secant of the <code>f32</code> <code>csch</code> <code>f32 -&gt; f32</code> Calculates the hyperbolic cosecant of the <code>f32</code> <code>coth</code> <code>f32 -&gt; f32</code> Calculates the hyperbolic cotangent of the <code>f32</code> <code>asech</code> <code>f32 -&gt; f32</code> Calculates the hyperbolic arcsecant of the <code>f32</code> <code>acsch</code> <code>f32 -&gt; f32</code> Calculates the hyperbolic arccosecant of the <code>f32</code> <code>acoth</code> <code>f32 -&gt; f32</code> Calculates the hyperbolic arccotangent of the <code>f32</code> <code>round</code> <code>f32 -&gt; f32</code> Rounds the number to the nearest integer, ties break even <code>magnitude</code> <code>f32 -&gt; f32</code> Returns the positive version of the <code>f32</code> <code>inverseSqrt</code> <code>f32 -&gt; f32</code> Calculates the inverse square root (<code>1/sqrt(x)</code>) of the <code>f32</code> <code>fma</code> <code>(f32, f32, f32) -&gt; f32</code> Calculates the fused multiply-add of the three <code>f32</code>s <code>fract</code> <code>f32 -&gt; f32</code> Calculates the fractional component of the <code>f32</code> <code>add</code> <code>(f64, f64) -&gt; f64</code> Adds two <code>f64</code>s together <code>sub</code> <code>(f64, f64) -&gt; f64</code> Subtracts two <code>f64</code>s <code>mul</code> <code>(f64, f64) -&gt; f64</code> Multiplies two <code>f64</code>s <code>div</code> <code>(f64, f64) -&gt; f64</code> Divides two <code>f64</code>s <code>sqrt</code> <code>f64 -&gt; f64</code> Returns the square root of an <code>f64</code> <code>pow</code> <code>(f64, f64) -&gt; f64</code> Raises the first <code>f64</code> to the power of the second <code>abs</code> <code>f64 -&gt; f64</code> Returns the positive version of the <code>f64</code> <code>neg</code> <code>f64 -&gt; f64</code> Multiplies the <code>f64</code> by <code>-1</code> <code>eq</code> <code>(f64, f64) -&gt; bool</code> Returns <code>true</code> if the two <code>f64</code>s are equal <code>neq</code> <code>(f64, f64) -&gt; bool</code> Returns <code>true</code> if the two <code>f64</code>s are not equal <code>lt</code> <code>(f64, f64) -&gt; bool</code> Returns <code>true</code> if the first <code>f64</code> is less than the second <code>lte</code> <code>(f64, f64) -&gt; bool</code> Returns <code>true</code> if the first <code>f64</code> is less than or equal to the second <code>gt</code> <code>(f64, f64) -&gt; bool</code> Returns <code>true</code> if the first <code>f64</code> is greater than the second <code>gte</code> <code>(f64, f64) -&gt; bool</code> Returns <code>true</code> if the first <code>f64</code> is greater than or equal to the second <code>min</code> <code>(f64, f64) -&gt; f64</code> Returns the smaller <code>f64</code> <code>max</code> <code>(f64, f64) -&gt; f64</code> Returns the larger <code>f64</code> <code>clamp</code> <code>(f64, f64, f64) -&gt; f64</code> Clamps the first <code>f64</code> to be above the second and below the third <code>saturate</code> <code>f64 -&gt; f64</code> Clamps the <code>f64</code> between <code>0</code> and <code>1</code> <code>floor</code> <code>f64 -&gt; f64</code> Rounds the <code>f64</code> down to the nearest integer <code>ceil</code> <code>f64 -&gt; f64</code> Rounds the <code>f64</code> up to the nearest integer <code>acos</code> <code>f64 -&gt; f64</code> Calculates the arccosine of the <code>f64</code> <code>acosh</code> <code>f64 -&gt; f64</code> Calculates the hyperbolic arccosine of the <code>f64</code> <code>asin</code> <code>f64 -&gt; f64</code> Calculates the arcsine of the <code>f64</code> <code>asinh</code> <code>f64 -&gt; f64</code> Calculates the hyperbolic arcsine of the <code>f64</code> <code>atan</code> <code>f64 -&gt; f64</code> Calculates the arctangent of the <code>f64</code> <code>atan2</code> <code>(f64, f64) -&gt; f64</code> Calculates the arctangent of the two sides defined by the <code>f64</code>s <code>cos</code> <code>f64 -&gt; f64</code> Calculates the cosine of the <code>f64</code> <code>cosh</code> <code>f64 -&gt; f64</code> Calculates the hyperbolic cosine of the <code>f64</code> <code>sin</code> <code>f64 -&gt; f64</code> Calculates the sine of the <code>f64</code> <code>sinh</code> <code>f64 -&gt; f64</code> Calculates the hyperbolic sine of the <code>f64</code> <code>tan</code> <code>f64 -&gt; f64</code> Calculates the tangent of the <code>f64</code> <code>tanh</code> <code>f64 -&gt; f64</code> Calculates the hyperbolic tangent of the <code>f64</code> <code>exp</code> <code>f64 -&gt; f64</code> Raises <code>e</code> to the power of the <code>f64</code> <code>ln</code> <code>f64 -&gt; f64</code> Calculates the natural log of the <code>f64</code> <code>log2</code> <code>f64 -&gt; f64</code> Calculates the log base 2 of the <code>f64</code> <code>log10</code> <code>f64 -&gt; f64</code> Calculates the log base 10 of the <code>f64</code> <code>sec</code> <code>f64 -&gt; f64</code> Calculates the secant of the <code>f64</code> <code>csc</code> <code>f64 -&gt; f64</code> Calculates the cosecant of the <code>f64</code> <code>cot</code> <code>f64 -&gt; f64</code> Calculates the cotangent of the <code>f64</code> <code>asec</code> <code>f64 -&gt; f64</code> Calculates the arcsecant of the <code>f64</code> <code>acsc</code> <code>f64 -&gt; f64</code> Calculates the arccosecant of the <code>f64</code> <code>acot</code> <code>f64 -&gt; f64</code> Calculates the arccotangent of the <code>f64</code> <code>sech</code> <code>f64 -&gt; f64</code> Calculates the hyperbolic secant of the <code>f64</code> <code>csch</code> <code>f64 -&gt; f64</code> Calculates the hyperbolic cosecant of the <code>f64</code> <code>coth</code> <code>f64 -&gt; f64</code> Calculates the hyperbolic cotangent of the <code>f64</code> <code>asech</code> <code>f64 -&gt; f64</code> Calculates the hyperbolic arcsecant of the <code>f64</code> <code>acsch</code> <code>f64 -&gt; f64</code> Calculates the hyperbolic arccosecant of the <code>f64</code> <code>acoth</code> <code>f64 -&gt; f64</code> Calculates the hyperbolic arccotangent of the <code>f64</code> <code>round</code> <code>f64 -&gt; f64</code> Rounds the number to the nearest integer, ties break even <code>magnitude</code> <code>f64 -&gt; f64</code> Returns the positive version of the <code>f64</code> <code>inverseSqrt</code> <code>f64 -&gt; f64</code> Calculates the inverse square root (<code>1/sqrt(x)</code>) of the <code>f64</code> <code>fma</code> <code>(f64, f64, f64) -&gt; f64</code> Calculates the fused multiply-add of the three <code>f64</code>s <code>fract</code> <code>f64 -&gt; f64</code> Calculates the fractional component of the <code>f64</code>"},{"location":"built_ins/#unsigned-integer-related-functions","title":"Unsigned Integer-related functions","text":"Name Type Description <code>add</code> <code>(u8, u8) -&gt; u8</code> Adds two <code>u8</code>s together. Wraps on overflow <code>sub</code> <code>(u8, u8) -&gt; u8</code> Subtracts two <code>u8</code>s. Wraps on overflow <code>mul</code> <code>(u8, u8) -&gt; u8</code> Multiplies two <code>u8</code>s. Wraps on overflow <code>div</code> <code>(u8, u8) -&gt; u8</code> Divides two <code>u8</code>s. Wraps on overflow <code>mod</code> <code>(u8, u8) -&gt; u8</code> Returns the modulus (remainder) of the first <code>u8</code> divided by the second <code>pow</code> <code>(u8, u8) -&gt; u8</code> Raises the first <code>u8</code> to the power of the second <code>and</code> <code>(u8, u8) -&gt; u8</code> Performs the bitwise AND operation <code>or</code> <code>(u8, u8) -&gt; u8</code> Performs the bitwise OR operation <code>xor</code> <code>(u8, u8) -&gt; u8</code> Performs the bitwise XOR operation <code>not</code> <code>u8 -&gt; u8</code> Performs the bitwise NOT operation <code>nand</code> <code>(u8, u8) -&gt; u8</code> Performs the bitwise NAND operation <code>nor</code> <code>(u8, u8) -&gt; u8</code> Performs the bitwise NOR operation <code>xnor</code> <code>(u8, u8) -&gt; u8</code> Performs the bitwise XNOR operation <code>eq</code> <code>(u8, u8) -&gt; bool</code> Returns <code>true</code> if both <code>u8</code>s are the same <code>neq</code> <code>(u8, u8) -&gt; bool</code> Returns <code>true</code> if both <code>u8</code>s differ <code>lt</code> <code>(u8, u8) -&gt; bool</code> Returns <code>true</code> if the first <code>u8</code> is less than the second <code>lte</code> <code>(u8, u8) -&gt; bool</code> Returns <code>true</code> if the first <code>u8</code> is less than or equal to the second <code>gt</code> <code>(u8, u8) -&gt; bool</code> Returns <code>true</code> if the first <code>u8</code> is greater than the second <code>gte</code> <code>(u8, u8) -&gt; bool</code> Returns <code>true</code> if the first <code>u8</code> is greater than or equal to the second <code>min</code> <code>(u8, u8) -&gt; u8</code> Returns the smaller <code>u8</code> <code>max</code> <code>(u8, u8) -&gt; u8</code> Returns the larger <code>u8</code> <code>clamp</code> <code>(u8, u8, u8) -&gt; u8</code> Clamps the first <code>u8</code> to be above the second and below the third <code>shl</code> <code>(u8, u8) -&gt; u8</code> Shifts the first <code>u8</code> left the number of places specified by the second <code>shr</code> <code>(u8, u8) -&gt; u8</code> Shifts the first <code>u8</code> right the number of places specified by the second <code>wrl</code> <code>(u8, u8) -&gt; u8</code> Wrapping shifts the first <code>u8</code> left the number of place specified by the second <code>wrr</code> <code>(u8, u8) -&gt; u8</code> Wrapping shifts the first <code>u8</code> right the number of place specified by the second <code>clz</code> <code>u8 -&gt; u8</code> Returns the number of leading zeroes for the <code>u8</code> <code>ones</code> <code>u8 -&gt; u8</code> Returns the number of one bits in the <code>u8</code> <code>ctz</code> <code>u8 -&gt; u8</code> Returns the number of trailing zeroes for the <code>u8</code> <code>reverseBits</code> <code>u8 -&gt; u8</code> Returns the <code>u8</code> with its bits in reverse order <code>extractBits</code> <code>(u8, u8, u8) -&gt; u8</code> From the first <code>u8</code>, start at the bit specified by the second extract to the third <code>insertBits</code> <code>(u8, u8, u8, u8) -&gt; u8</code> Into the first <code>u8</code> insert bits from the second starting at the bit specified by the third until the fourth <code>add</code> <code>(u16, u16) -&gt; u16</code> Adds two <code>u16</code>s together. Wraps on overflow <code>sub</code> <code>(u16, u16) -&gt; u16</code> Subtracts two <code>u16</code>s. Wraps on overflow <code>mul</code> <code>(u16, u16) -&gt; u16</code> Multiplies two <code>u16</code>s. Wraps on overflow <code>div</code> <code>(u16, u16) -&gt; u16</code> Divides two <code>u16</code>s. Wraps on overflow <code>mod</code> <code>(u16, u16) -&gt; u16</code> Returns the modulus (remainder) of the first <code>u16</code> divided by the second <code>pow</code> <code>(u16, u16) -&gt; u16</code> Raises the first <code>u16</code> to the power of the second <code>and</code> <code>(u16, u16) -&gt; u16</code> Performs the bitwise AND operation <code>or</code> <code>(u16, u16) -&gt; u16</code> Performs the bitwise OR operation <code>xor</code> <code>(u16, u16) -&gt; u16</code> Performs the bitwise XOR operation <code>not</code> <code>u16 -&gt; u16</code> Performs the bitwise NOT operation <code>nand</code> <code>(u16, u16) -&gt; u16</code> Performs the bitwise NAND operation <code>nor</code> <code>(u16, u16) -&gt; u16</code> Performs the bitwise NOR operation <code>xnor</code> <code>(u16, u16) -&gt; u16</code> Performs the bitwise XNOR operation <code>eq</code> <code>(u16, u16) -&gt; bool</code> Returns <code>true</code> if both <code>u16</code>s are the same <code>neq</code> <code>(u16, u16) -&gt; bool</code> Returns <code>true</code> if both <code>u16</code>s differ <code>lt</code> <code>(u16, u16) -&gt; bool</code> Returns <code>true</code> if the first <code>u16</code> is less than the second <code>lte</code> <code>(u16, u16) -&gt; bool</code> Returns <code>true</code> if the first <code>u16</code> is less than or equal to the second <code>gt</code> <code>(u16, u16) -&gt; bool</code> Returns <code>true</code> if the first <code>u16</code> is greater than the second <code>gte</code> <code>(u16, u16) -&gt; bool</code> Returns <code>true</code> if the first <code>u16</code> is greater than or equal to the second <code>min</code> <code>(u16, u16) -&gt; u16</code> Returns the smaller <code>u16</code> <code>max</code> <code>(u16, u16) -&gt; u16</code> Returns the larger <code>u16</code> <code>clamp</code> <code>(u16, u16, u16) -&gt; u16</code> Clamps the first <code>u16</code> to be above the second and below the third <code>shl</code> <code>(u16, u16) -&gt; u16</code> Shifts the first <code>u16</code> left the number of places specified by the second <code>shr</code> <code>(u16, u16) -&gt; u16</code> Shifts the first <code>u16</code> right the number of places specified by the second <code>wrl</code> <code>(u16, u16) -&gt; u16</code> Wrapping shifts the first <code>u16</code> left the number of place specified by the second <code>wrr</code> <code>(u16, u16) -&gt; u16</code> Wrapping shifts the first <code>u16</code> right the number of place specified by the second <code>clz</code> <code>u16 -&gt; u16</code> Returns the number of leading zeroes for the <code>u16</code> <code>ones</code> <code>u16 -&gt; u16</code> Returns the number of one bits in the <code>u16</code> <code>ctz</code> <code>u16 -&gt; u16</code> Returns the number of trailing zeroes for the <code>u16</code> <code>reverseBits</code> <code>u16 -&gt; u16</code> Returns the <code>u16</code> with its bits in reverse order <code>extractBits</code> <code>(u16, u16, u16) -&gt; u16</code> From the first <code>u16</code>, start at the bit specified by the second extract to the third <code>insertBits</code> <code>(u16, u16, u16, u16) -&gt; u16</code> Into the first <code>u16</code> insert bits from the second starting at the bit specified by the third until the fourth <code>add</code> <code>(u32, u32) -&gt; u32</code> Adds two <code>u32</code>s together. Wraps on overflow <code>sub</code> <code>(u32, u32) -&gt; u32</code> Subtracts two <code>u32</code>s. Wraps on overflow <code>mul</code> <code>(u32, u32) -&gt; u32</code> Multiplies two <code>u32</code>s. Wraps on overflow <code>div</code> <code>(u32, u32) -&gt; u32</code> Divides two <code>u32</code>s. Wraps on overflow <code>mod</code> <code>(u32, u32) -&gt; u32</code> Returns the modulus (remainder) of the first <code>u32</code> divided by the second <code>pow</code> <code>(u32, u32) -&gt; u32</code> Raises the first <code>u32</code> to the power of the second <code>and</code> <code>(u32, u32) -&gt; u32</code> Performs the bitwise AND operation <code>or</code> <code>(u32, u32) -&gt; u32</code> Performs the bitwise OR operation <code>xor</code> <code>(u32, u32) -&gt; u32</code> Performs the bitwise XOR operation <code>not</code> <code>u32 -&gt; u32</code> Performs the bitwise NOT operation <code>nand</code> <code>(u32, u32) -&gt; u32</code> Performs the bitwise NAND operation <code>nor</code> <code>(u32, u32) -&gt; u32</code> Performs the bitwise NOR operation <code>xnor</code> <code>(u32, u32) -&gt; u32</code> Performs the bitwise XNOR operation <code>eq</code> <code>(u32, u32) -&gt; bool</code> Returns <code>true</code> if both <code>u32</code>s are the same <code>neq</code> <code>(u32, u32) -&gt; bool</code> Returns <code>true</code> if both <code>u32</code>s differ <code>lt</code> <code>(u32, u32) -&gt; bool</code> Returns <code>true</code> if the first <code>u32</code> is less than the second <code>lte</code> <code>(u32, u32) -&gt; bool</code> Returns <code>true</code> if the first <code>u32</code> is less than or equal to the second <code>gt</code> <code>(u32, u32) -&gt; bool</code> Returns <code>true</code> if the first <code>u32</code> is greater than the second <code>gte</code> <code>(u32, u32) -&gt; bool</code> Returns <code>true</code> if the first <code>u32</code> is greater than or equal to the second <code>min</code> <code>(u32, u32) -&gt; u32</code> Returns the smaller <code>u32</code> <code>max</code> <code>(u32, u32) -&gt; u32</code> Returns the larger <code>u32</code> <code>clamp</code> <code>(u32, u32, u32) -&gt; u32</code> Clamps the first <code>u32</code> to be above the second and below the third <code>shl</code> <code>(u32, u32) -&gt; u32</code> Shifts the first <code>u32</code> left the number of places specified by the second <code>shr</code> <code>(u32, u32) -&gt; u32</code> Shifts the first <code>u32</code> right the number of places specified by the second <code>wrl</code> <code>(u32, u32) -&gt; u32</code> Wrapping shifts the first <code>u32</code> left the number of place specified by the second <code>wrr</code> <code>(u32, u32) -&gt; u32</code> Wrapping shifts the first <code>u32</code> right the number of place specified by the second <code>clz</code> <code>u32 -&gt; u32</code> Returns the number of leading zeroes for the <code>u32</code> <code>ones</code> <code>u32 -&gt; u32</code> Returns the number of one bits in the <code>u32</code> <code>ctz</code> <code>u32 -&gt; u32</code> Returns the number of trailing zeroes for the <code>u32</code> <code>reverseBits</code> <code>u32 -&gt; u32</code> Returns the <code>u32</code> with its bits in reverse order <code>extractBits</code> <code>(u32, u32, u32) -&gt; u32</code> From the first <code>u32</code>, start at the bit specified by the second extract to the third <code>insertBits</code> <code>(u32, u32, u32, u32) -&gt; u32</code> Into the first <code>u32</code> insert bits from the second starting at the bit specified by the third until the fourth <code>add</code> <code>(u64, u64) -&gt; u64</code> Adds two <code>u64</code>s together. Wraps on overflow <code>sub</code> <code>(u64, u64) -&gt; u64</code> Subtracts two <code>u64</code>s. Wraps on overflow <code>mul</code> <code>(u64, u64) -&gt; u64</code> Multiplies two <code>u64</code>s. Wraps on overflow <code>div</code> <code>(u64, u64) -&gt; u64</code> Divides two <code>u64</code>s. Wraps on overflow <code>mod</code> <code>(u64, u64) -&gt; u64</code> Returns the modulus (remainder) of the first <code>u64</code> divided by the second <code>pow</code> <code>(u64, u64) -&gt; u64</code> Raises the first <code>u64</code> to the power of the second <code>and</code> <code>(u64, u64) -&gt; u64</code> Performs the bitwise AND operation <code>or</code> <code>(u64, u64) -&gt; u64</code> Performs the bitwise OR operation <code>xor</code> <code>(u64, u64) -&gt; u64</code> Performs the bitwise XOR operation <code>not</code> <code>u64 -&gt; u64</code> Performs the bitwise NOT operation <code>nand</code> <code>(u64, u64) -&gt; u64</code> Performs the bitwise NAND operation <code>nor</code> <code>(u64, u64) -&gt; u64</code> Performs the bitwise NOR operation <code>xnor</code> <code>(u64, u64) -&gt; u64</code> Performs the bitwise XNOR operation <code>eq</code> <code>(u64, u64) -&gt; bool</code> Returns <code>true</code> if both <code>u64</code>s are the same <code>neq</code> <code>(u64, u64) -&gt; bool</code> Returns <code>true</code> if both <code>u64</code>s differ <code>lt</code> <code>(u64, u64) -&gt; bool</code> Returns <code>true</code> if the first <code>u64</code> is less than the second <code>lte</code> <code>(u64, u64) -&gt; bool</code> Returns <code>true</code> if the first <code>u64</code> is less than or equal to the second <code>gt</code> <code>(u64, u64) -&gt; bool</code> Returns <code>true</code> if the first <code>u64</code> is greater than the second <code>gte</code> <code>(u64, u64) -&gt; bool</code> Returns <code>true</code> if the first <code>u64</code> is greater than or equal to the second <code>min</code> <code>(u64, u64) -&gt; u64</code> Returns the smaller <code>u64</code> <code>max</code> <code>(u64, u64) -&gt; u64</code> Returns the larger <code>u64</code> <code>clamp</code> <code>(u64, u64, u64) -&gt; u64</code> Clamps the first <code>u64</code> to be above the second and below the third <code>shl</code> <code>(u64, u64) -&gt; u64</code> Shifts the first <code>u64</code> left the number of places specified by the second <code>shr</code> <code>(u64, u64) -&gt; u64</code> Shifts the first <code>u64</code> right the number of places specified by the second <code>wrl</code> <code>(u64, u64) -&gt; u64</code> Wrapping shifts the first <code>u64</code> left the number of place specified by the second <code>wrr</code> <code>(u64, u64) -&gt; u64</code> Wrapping shifts the first <code>u64</code> right the number of place specified by the second <code>clz</code> <code>u64 -&gt; u64</code> Returns the number of leading zeroes for the <code>u64</code> <code>ones</code> <code>u64 -&gt; u64</code> Returns the number of one bits in the <code>u64</code> <code>ctz</code> <code>u64 -&gt; u64</code> Returns the number of trailing zeroes for the <code>u64</code> <code>reverseBits</code> <code>u64 -&gt; u64</code> Returns the <code>u64</code> with its bits in reverse order <code>extractBits</code> <code>(u64, u64, u64) -&gt; u64</code> From the first <code>u64</code>, start at the bit specified by the second extract to the third <code>insertBits</code> <code>(u64, u64, u64, u64) -&gt; u64</code> Into the first <code>u64</code> insert bits from the second starting at the bit specified by the third until the fourth"},{"location":"built_ins/#signed-integer-related-functions","title":"Signed Integer-related functions","text":"Name Type Description <code>add</code> <code>(i8, i8) -&gt; i8</code> Adds two <code>i8</code>s together. Wraps on overflow <code>sub</code> <code>(i8, i8) -&gt; i8</code> Subtracts two <code>i8</code>s. Wraps on overflow <code>mul</code> <code>(i8, i8) -&gt; i8</code> Multiplies two <code>i8</code>s. Wraps on overflow <code>div</code> <code>(i8, i8) -&gt; i8</code> Divides two <code>i8</code>s. Wraps on overflow <code>mod</code> <code>(i8, i8) -&gt; i8</code> Returns the modulus (remainder) of the first <code>i8</code> divided by the second <code>pow</code> <code>(i8, i8) -&gt; i8</code> Raises the first <code>i8</code> to the power of the second <code>abs</code> <code>i8 -&gt; i8</code> Returns the positive version of the <code>i8</code> <code>neg</code> <code>i8 -&gt; i8</code> Multiplies the <code>i8</code> by <code>-1</code> <code>and</code> <code>(i8, i8) -&gt; i8</code> Performs the bitwise AND operation <code>or</code> <code>(i8, i8) -&gt; i8</code> Performs the bitwise OR operation <code>xor</code> <code>(i8, i8) -&gt; i8</code> Performs the bitwise XOR operation <code>not</code> <code>i8 -&gt; i8</code> Performs the bitwise NOT operation <code>nand</code> <code>(i8, i8) -&gt; i8</code> Performs the bitwise NAND operation <code>nor</code> <code>(i8, i8) -&gt; i8</code> Performs the bitwise NOR operation <code>xnor</code> <code>(i8, i8) -&gt; i8</code> Performs the bitwise XNOR operation <code>eq</code> <code>(i8, i8) -&gt; bool</code> Returns <code>true</code> if both <code>i8</code>s are the same <code>neq</code> <code>(i8, i8) -&gt; bool</code> Returns <code>true</code> if both <code>i8</code>s differ <code>lt</code> <code>(i8, i8) -&gt; bool</code> Returns <code>true</code> if the first <code>i8</code> is less than the second <code>lte</code> <code>(i8, i8) -&gt; bool</code> Returns <code>true</code> if the first <code>i8</code> is less than or equal to the second <code>gt</code> <code>(i8, i8) -&gt; bool</code> Returns <code>true</code> if the first <code>i8</code> is greater than the second <code>gte</code> <code>(i8, i8) -&gt; bool</code> Returns <code>true</code> if the first <code>i8</code> is greater than or equal to the second <code>min</code> <code>(i8, i8) -&gt; i8</code> Returns the smaller <code>i8</code> <code>max</code> <code>(i8, i8) -&gt; i8</code> Returns the larger <code>i8</code> <code>clamp</code> <code>(i8, i8, i8) -&gt; i8</code> Clamps the first <code>i8</code> to be above the second and below the third <code>shl</code> <code>(i8, i8) -&gt; i8</code> Shifts the first <code>i8</code> left the number of places specified by the second <code>shr</code> <code>(i8, i8) -&gt; i8</code> Shifts the first <code>i8</code> right the number of places specified by the second <code>wrl</code> <code>(i8, i8) -&gt; i8</code> Wrapping shifts the first <code>i8</code> left the number of place specified by the second <code>wrr</code> <code>(i8, i8) -&gt; i8</code> Wrapping shifts the first <code>i8</code> right the number of place specified by the second <code>clz</code> <code>i8 -&gt; i8</code> Returns the number of leading zeroes for the <code>i8</code> <code>ones</code> <code>i8 -&gt; i8</code> Returns the number of one bits in the <code>i8</code> <code>ctz</code> <code>i8 -&gt; i8</code> Returns the number of trailing zeroes for the <code>i8</code> <code>reverseBits</code> <code>i8 -&gt; i8</code> Returns the <code>i8</code> with its bits in reverse order <code>extractBits</code> <code>(i8, i8, i8) -&gt; i8</code> From the first <code>i8</code>, start at the bit specified by the second extract to the third <code>insertBits</code> <code>(i8, i8, i8, i8) -&gt; i8</code> Into the first <code>i8</code> insert bits from the second starting at the bit specified by the third until the fourth <code>add</code> <code>(i16, i16) -&gt; i16</code> Adds two <code>i16</code>s together. Wraps on overflow <code>sub</code> <code>(i16, i16) -&gt; i16</code> Subtracts two <code>i16</code>s. Wraps on overflow <code>mul</code> <code>(i16, i16) -&gt; i16</code> Multiplies two <code>i16</code>s. Wraps on overflow <code>div</code> <code>(i16, i16) -&gt; i16</code> Divides two <code>i16</code>s. Wraps on overflow <code>mod</code> <code>(i16, i16) -&gt; i16</code> Returns the modulus (remainder) of the first <code>i16</code> divided by the second <code>pow</code> <code>(i16, i16) -&gt; i16</code> Raises the first <code>i16</code> to the power of the second <code>abs</code> <code>i16 -&gt; i16</code> Returns the positive version of the <code>i16</code> <code>neg</code> <code>i16 -&gt; i16</code> Multiplies the <code>i16</code> by <code>-1</code> <code>and</code> <code>(i16, i16) -&gt; i16</code> Performs the bitwise AND operation <code>or</code> <code>(i16, i16) -&gt; i16</code> Performs the bitwise OR operation <code>xor</code> <code>(i16, i16) -&gt; i16</code> Performs the bitwise XOR operation <code>not</code> <code>i16 -&gt; i16</code> Performs the bitwise NOT operation <code>nand</code> <code>(i16, i16) -&gt; i16</code> Performs the bitwise NAND operation <code>nor</code> <code>(i16, i16) -&gt; i16</code> Performs the bitwise NOR operation <code>xnor</code> <code>(i16, i16) -&gt; i16</code> Performs the bitwise XNOR operation <code>eq</code> <code>(i16, i16) -&gt; bool</code> Returns <code>true</code> if both <code>i16</code>s are the same <code>neq</code> <code>(i16, i16) -&gt; bool</code> Returns <code>true</code> if both <code>i16</code>s differ <code>lt</code> <code>(i16, i16) -&gt; bool</code> Returns <code>true</code> if the first <code>i16</code> is less than the second <code>lte</code> <code>(i16, i16) -&gt; bool</code> Returns <code>true</code> if the first <code>i16</code> is less than or equal to the second <code>gt</code> <code>(i16, i16) -&gt; bool</code> Returns <code>true</code> if the first <code>i16</code> is greater than the second <code>gte</code> <code>(i16, i16) -&gt; bool</code> Returns <code>true</code> if the first <code>i16</code> is greater than or equal to the second <code>min</code> <code>(i16, i16) -&gt; i16</code> Returns the smaller <code>i16</code> <code>max</code> <code>(i16, i16) -&gt; i16</code> Returns the larger <code>i16</code> <code>clamp</code> <code>(i16, i16, i16) -&gt; i16</code> Clamps the first <code>i16</code> to be above the second and below the third <code>shl</code> <code>(i16, i16) -&gt; i16</code> Shifts the first <code>i16</code> left the number of places specified by the second <code>shr</code> <code>(i16, i16) -&gt; i16</code> Shifts the first <code>i16</code> right the number of places specified by the second <code>wrl</code> <code>(i16, i16) -&gt; i16</code> Wrapping shifts the first <code>i16</code> left the number of place specified by the second <code>wrr</code> <code>(i16, i16) -&gt; i16</code> Wrapping shifts the first <code>i16</code> right the number of place specified by the second <code>clz</code> <code>i16 -&gt; i16</code> Returns the number of leading zeroes for the <code>i16</code> <code>ones</code> <code>i16 -&gt; i16</code> Returns the number of one bits in the <code>i16</code> <code>ctz</code> <code>i16 -&gt; i16</code> Returns the number of trailing zeroes for the <code>i16</code> <code>reverseBits</code> <code>i16 -&gt; i16</code> Returns the <code>i16</code> with its bits in reverse order <code>extractBits</code> <code>(i16, i16, i16) -&gt; i16</code> From the first <code>i16</code>, start at the bit specified by the second extract to the third <code>insertBits</code> <code>(i16, i16, i16, i16) -&gt; i16</code> Into the first <code>i16</code> insert bits from the second starting at the bit specified by the third until the fourth <code>add</code> <code>(i32, i32) -&gt; i32</code> Adds two <code>i32</code>s together. Wraps on overflow <code>sub</code> <code>(i32, i32) -&gt; i32</code> Subtracts two <code>i32</code>s. Wraps on overflow <code>mul</code> <code>(i32, i32) -&gt; i32</code> Multiplies two <code>i32</code>s. Wraps on overflow <code>div</code> <code>(i32, i32) -&gt; i32</code> Divides two <code>i32</code>s. Wraps on overflow <code>mod</code> <code>(i32, i32) -&gt; i32</code> Returns the modulus (remainder) of the first <code>i32</code> divided by the second <code>pow</code> <code>(i32, i32) -&gt; i32</code> Raises the first <code>i32</code> to the power of the second <code>abs</code> <code>i32 -&gt; i32</code> Returns the positive version of the <code>i32</code> <code>neg</code> <code>i32 -&gt; i32</code> Multiplies the <code>i32</code> by <code>-1</code> <code>and</code> <code>(i32, i32) -&gt; i32</code> Performs the bitwise AND operation <code>or</code> <code>(i32, i32) -&gt; i32</code> Performs the bitwise OR operation <code>xor</code> <code>(i32, i32) -&gt; i32</code> Performs the bitwise XOR operation <code>not</code> <code>i32 -&gt; i32</code> Performs the bitwise NOT operation <code>nand</code> <code>(i32, i32) -&gt; i32</code> Performs the bitwise NAND operation <code>nor</code> <code>(i32, i32) -&gt; i32</code> Performs the bitwise NOR operation <code>xnor</code> <code>(i32, i32) -&gt; i32</code> Performs the bitwise XNOR operation <code>eq</code> <code>(i32, i32) -&gt; bool</code> Returns <code>true</code> if both <code>i32</code>s are the same <code>neq</code> <code>(i32, i32) -&gt; bool</code> Returns <code>true</code> if both <code>i32</code>s differ <code>lt</code> <code>(i32, i32) -&gt; bool</code> Returns <code>true</code> if the first <code>i32</code> is less than the second <code>lte</code> <code>(i32, i32) -&gt; bool</code> Returns <code>true</code> if the first <code>i32</code> is less than or equal to the second <code>gt</code> <code>(i32, i32) -&gt; bool</code> Returns <code>true</code> if the first <code>i32</code> is greater than the second <code>gte</code> <code>(i32, i32) -&gt; bool</code> Returns <code>true</code> if the first <code>i32</code> is greater than or equal to the second <code>min</code> <code>(i32, i32) -&gt; i32</code> Returns the smaller <code>i32</code> <code>max</code> <code>(i32, i32) -&gt; i32</code> Returns the larger <code>i32</code> <code>clamp</code> <code>(i32, i32, i32) -&gt; i32</code> Clamps the first <code>i32</code> to be above the second and below the third <code>shl</code> <code>(i32, i32) -&gt; i32</code> Shifts the first <code>i32</code> left the number of places specified by the second <code>shr</code> <code>(i32, i32) -&gt; i32</code> Shifts the first <code>i32</code> right the number of places specified by the second <code>wrl</code> <code>(i32, i32) -&gt; i32</code> Wrapping shifts the first <code>i32</code> left the number of place specified by the second <code>wrr</code> <code>(i32, i32) -&gt; i32</code> Wrapping shifts the first <code>i32</code> right the number of place specified by the second <code>clz</code> <code>i32 -&gt; i32</code> Returns the number of leading zeroes for the <code>i32</code> <code>ones</code> <code>i32 -&gt; i32</code> Returns the number of one bits in the <code>i32</code> <code>ctz</code> <code>i32 -&gt; i32</code> Returns the number of trailing zeroes for the <code>i32</code> <code>reverseBits</code> <code>i32 -&gt; i32</code> Returns the <code>i32</code> with its bits in reverse order <code>extractBits</code> <code>(i32, i32, i32) -&gt; i32</code> From the first <code>i32</code>, start at the bit specified by the second extract to the third <code>insertBits</code> <code>(i32, i32, i32, i32) -&gt; i32</code> Into the first <code>i32</code> insert bits from the second starting at the bit specified by the third until the fourth <code>add</code> <code>(i64, i64) -&gt; i64</code> Adds two <code>i64</code>s together. Wraps on overflow <code>sub</code> <code>(i64, i64) -&gt; i64</code> Subtracts two <code>i64</code>s. Wraps on overflow <code>mul</code> <code>(i64, i64) -&gt; i64</code> Multiplies two <code>i64</code>s. Wraps on overflow <code>div</code> <code>(i64, i64) -&gt; i64</code> Divides two <code>i64</code>s. Wraps on overflow <code>mod</code> <code>(i64, i64) -&gt; i64</code> Returns the modulus (remainder) of the first <code>i64</code> divided by the second <code>pow</code> <code>(i64, i64) -&gt; i64</code> Raises the first <code>i64</code> to the power of the second <code>abs</code> <code>i64 -&gt; i64</code> Returns the positive version of the <code>i64</code> <code>neg</code> <code>i64 -&gt; i64</code> Multiplies the <code>i64</code> by <code>-1</code> <code>and</code> <code>(i64, i64) -&gt; i64</code> Performs the bitwise AND operation <code>or</code> <code>(i64, i64) -&gt; i64</code> Performs the bitwise OR operation <code>xor</code> <code>(i64, i64) -&gt; i64</code> Performs the bitwise XOR operation <code>not</code> <code>i64 -&gt; i64</code> Performs the bitwise NOT operation <code>nand</code> <code>(i64, i64) -&gt; i64</code> Performs the bitwise NAND operation <code>nor</code> <code>(i64, i64) -&gt; i64</code> Performs the bitwise NOR operation <code>xnor</code> <code>(i64, i64) -&gt; i64</code> Performs the bitwise XNOR operation <code>eq</code> <code>(i64, i64) -&gt; bool</code> Returns <code>true</code> if both <code>i64</code>s are the same <code>neq</code> <code>(i64, i64) -&gt; bool</code> Returns <code>true</code> if both <code>i64</code>s differ <code>lt</code> <code>(i64, i64) -&gt; bool</code> Returns <code>true</code> if the first <code>i64</code> is less than the second <code>lte</code> <code>(i64, i64) -&gt; bool</code> Returns <code>true</code> if the first <code>i64</code> is less than or equal to the second <code>gt</code> <code>(i64, i64) -&gt; bool</code> Returns <code>true</code> if the first <code>i64</code> is greater than the second <code>gte</code> <code>(i64, i64) -&gt; bool</code> Returns <code>true</code> if the first <code>i64</code> is greater than or equal to the second <code>min</code> <code>(i64, i64) -&gt; i64</code> Returns the smaller <code>i64</code> <code>max</code> <code>(i64, i64) -&gt; i64</code> Returns the larger <code>i64</code> <code>clamp</code> <code>(i64, i64, i64) -&gt; i64</code> Clamps the first <code>i64</code> to be above the second and below the third <code>shl</code> <code>(i64, i64) -&gt; i64</code> Shifts the first <code>i64</code> left the number of places specified by the second <code>shr</code> <code>(i64, i64) -&gt; i64</code> Shifts the first <code>i64</code> right the number of places specified by the second <code>wrl</code> <code>(i64, i64) -&gt; i64</code> Wrapping shifts the first <code>i64</code> left the number of place specified by the second <code>wrr</code> <code>(i64, i64) -&gt; i64</code> Wrapping shifts the first <code>i64</code> right the number of place specified by the second <code>clz</code> <code>i64 -&gt; i64</code> Returns the number of leading zeroes for the <code>i64</code> <code>ones</code> <code>i64 -&gt; i64</code> Returns the number of one bits in the <code>i64</code> <code>ctz</code> <code>i64 -&gt; i64</code> Returns the number of trailing zeroes for the <code>i64</code> <code>reverseBits</code> <code>i64 -&gt; i64</code> Returns the <code>i64</code> with its bits in reverse order <code>extractBits</code> <code>(i64, i64, i64) -&gt; i64</code> From the first <code>i64</code>, start at the bit specified by the second extract to the third <code>insertBits</code> <code>(i64, i64, i64, i64) -&gt; i64</code> Into the first <code>i64</code> insert bits from the second starting at the bit specified by the third until the fourth"},{"location":"built_ins/#string-related-functions","title":"String-related functions","text":"Name Type Description <code>string</code> <code>f32 -&gt; string</code> Converts the <code>f32</code> to a <code>string</code> <code>string</code> <code>f64 -&gt; string</code> Converts the <code>f64</code> to a <code>string</code> <code>string</code> <code>u8 -&gt; string</code> Converts the <code>u8</code> to a <code>string</code> <code>string</code> <code>u16 -&gt; string</code> Converts the <code>u16</code> to a <code>string</code> <code>string</code> <code>u32 -&gt; string</code> Converts the <code>u32</code> to a <code>string</code> <code>string</code> <code>u64 -&gt; string</code> Converts the <code>u64</code> to a <code>string</code> <code>string</code> <code>i8 -&gt; string</code> Converts the <code>i8</code> to a <code>string</code> <code>string</code> <code>i16 -&gt; string</code> Converts the <code>i16</code> to a <code>string</code> <code>string</code> <code>i32 -&gt; string</code> Converts the <code>i32</code> to a <code>string</code> <code>string</code> <code>i64 -&gt; string</code> Converts the <code>i64</code> to a <code>string</code> <code>string</code> <code>(f32, i64) -&gt; string</code> Converts the <code>f32</code> to a string with the number of decimals specified by the <code>i64</code> <code>string</code> <code>(f64, i64) -&gt; string</code> Converts the <code>f64</code> to a string with the number of decimals specified by the <code>i64</code> <code>string</code> <code>bool -&gt; string</code> Converts the <code>bool</code> to a <code>string</code> <code>string</code> <code>string -&gt; string</code> Returns the original <code>string</code> <code>concat</code> <code>(string, string) -&gt; string</code> Concatenates the two <code>string</code>s into a new <code>string</code> <code>repeat</code> <code>(string, i64) -&gt; string</code> Repeats the <code>string</code> the number of times specified by the <code>i64</code> <code>replace</code> <code>(string, string, string) -&gt; string</code> Replaces instances of the second <code>string</code> with the third in the first <code>split</code> <code>(string, string) -&gt; string[]</code> Splits the first <code>string</code> by the second, returning an array of smaller <code>string</code>s <code>len</code> <code>string -&gt; i64</code> Returns the length of the <code>string</code> <code>get</code> <code>(string, i64) -&gt; string!</code> Returns the character in the <code>string</code> at the index specified by the <code>i64</code> or fails <code>trim</code> <code>string -&gt; string</code> Removes whitespace from the beginning and end of the <code>string</code> <code>index</code> <code>(string, string) -&gt; i64!</code> Returns the index where the second <code>string</code> starts in the first or fails <code>eq</code> <code>(string, string) -&gt; bool</code> Returns <code>true</code> if the two <code>string</code>s are the same <code>neq</code> <code>(string, string) -&gt; bool</code> Returns <code>true</code> if the two <code>string</code>s differ <code>lt</code> <code>(string, string) -&gt; bool</code> Returns <code>true</code> if the first <code>string</code> sorts earlier than the second <code>lte</code> <code>(string, string) -&gt; bool</code> Returns <code>true</code> if the two <code>strings</code>s are the same or the first sorts earlier <code>gt</code> <code>(string, string) -&gt; bool</code> Returns <code>true</code> if the first <code>string</code> sorts later than the second <code>gte</code> <code>(string, string) -&gt; bool</code> Returns <code>true</code> if the two <code>string</code>s are the same or the first sorts later <code>min</code> <code>(string, string) -&gt; string</code> Returns the <code>string</code> that sorts earlier <code>max</code> <code>(string, string) -&gt; string</code> Returns the <code>string</code> that sorts later <code>join</code> <code>(string[], string) -&gt; string</code> Joins the array of <code>string[]</code>s by the <code>string</code> into a new <code>string</code> <code>join{S}</code> <code>(string[S], string) -&gt; string</code> Joins the buffer of <code>string[S]</code>s by the <code>string</code> into a new <code>string</code>"},{"location":"built_ins/#array-related-functions","title":"Array-related functions","text":"Name Type Description Explicit <code>Array{T}</code> <code>(T, ...) -&gt; T[]</code> Built-in Array constructor function. Can also be written <code>[T, ...]</code> \u274c <code>len{T}</code> <code>T[] -&gt; i64</code> Returns the number of elements in the <code>Array{T}</code> \u2705 <code>get{T}</code> <code>(T[], i64) -&gt; T?</code> Returns the value at the index specified by the <code>i64</code>, otherwise <code>void</code>. May also be written <code>arr[idx]</code> \u2705 <code>push{T}</code> <code>(Mut{T[]}, T) -&gt; ()</code> Appends the provided <code>T</code> to the end of the <code>T[]</code> \u2705 <code>pop{T}</code> <code>Mut{T[]} -&gt; T?</code> Removes the last <code>T</code> from the <code>T[]</code> and returns it, or <code>void</code> if empty \u2705 <code>map{T, U}</code> <code>(T[], T -&gt; U) -&gt; U[]</code> Creates a new <code>U[]</code> array by calling the <code>T -&gt; U</code> function on each of <code>T[]</code>'s elements \u2705 <code>map{T, U}</code> <code>(T[], (T, i64) -&gt; U) -&gt; U[]</code> Creates a new <code>U[]</code> array by calling the <code>(T, i64) -&gt; U</code> function on each of <code>T[]</code>'s elements with its index \u2705 <code>parmap{T, U}</code> <code>(T[], T -&gt; U) -&gt; U[]</code> (Rust-only for now) Creates a new <code>U[]</code> by dividing <code>T[]</code> across all CPU cores and running in parallel \u2705 <code>filter{T}</code> <code>(T[], T -&gt; bool) -&gt; T[]</code> Creates a new array including only the elements that evaluated to <code>true</code> when passed to the <code>T -&gt; bool</code> function \u2705 <code>filter{T}</code> <code>(T[], (T, i64) -&gt; bool) -&gt; T[]</code> Creates a new array including only the elements that evaluated to <code>true</code> when passed with their index to the <code>(T, i64) -&gt; bool</code> function \u2705 <code>reduce{T}</code> <code>(T[], (T, T) -&gt; T) -&gt; T?</code> Combines the elements of <code>T[]</code> into a singular <code>T</code> using the <code>(T, T) -&gt; T</code> function. Returns <code>void</code> if empty \u2705 <code>reduce{T}</code> <code>(T[], (T, T, i64) -&gt; T) -&gt; T?</code> Combines the elements of <code>T[]</code> into a singular <code>T</code> using the <code>(T, T, i64) -&gt; T</code> function and element indexes. Returns <code>void</code> if empty \u2705 <code>reduce{T, U}</code> <code>(T[], U, (U, T) -&gt; U) -&gt; U</code> Combines the elements of <code>T[]</code> into a singular <code>U</code> using the <code>(U, T) -&gt; U</code> function and an initial <code>U</code> value \u2705 <code>reduce{T, U}</code> <code>(T[], U, (U, T, i64) -&gt; U) -&gt; U</code> Combines the elements of <code>T[]</code> into a singular <code>U</code> using the <code>(U, T, i64) -&gt; U</code> function, element indexes, and an initial <code>U</code> value \u2705 <code>concat{T}</code> <code>(T[], T[]) -&gt; T[]</code> Concatenates two <code>T[]</code> arrays into a new <code>T[]</code> array \u2705 <code>append{T}</code> <code>(Mut{T[]}, T[]) -&gt; ()</code> Appends the contents of the second <code>T[]</code> into the first. Mutates the first but does not change the second \u2705 <code>filled{T}</code> <code>(T, i64) -&gt; T[]</code> Creates a <code>T[]</code> with the number of elements specified by the <code>i64</code> all with the value specified by the <code>T</code> \u2705 <code>has{T}</code> <code>(T[], T) -&gt; bool</code> Returns <code>true</code> if the value in <code>T</code> exists within the <code>T[]</code> \u2705 <code>has{T}</code> <code>(T[], T -&gt; bool) -&gt; bool</code> Returns <code>true</code> if any value in <code>T[]</code> returns <code>true</code> when passed to the <code>T -&gt; bool</code> function \u2705 <code>find{T}</code> <code>(T[], T -&gt; bool) -&gt; T?</code> Returns the first <code>T</code> from the <code>T[]</code> that returns <code>true</code> when passed to the <code>T -&gt; bool</code> function. Otherwise returns <code>void</code> \u2705 <code>index{T}</code> <code>(T[], T) -&gt; i64?</code> Returns the first index that the <code>T</code> value is found in the <code>T[]</code>. Otherwise returns <code>void</code> \u2705 <code>index{T}</code> <code>(T[], T -&gt; bool) -&gt; i64?</code> Returns the first index that returns <code>true</code> when the <code>T</code> value is passed to the <code>T -&gt; bool</code> function. Otherwise returns <code>void</code> \u2705 <code>index{T}</code> <code>(T[], (T, i64) -&gt; bool) -&gt; i64?</code> Returns the first index that returns <code>true</code> when the <code>T</code> value and index is passed to the <code>(T, i64) -&gt; bool</code> function. Otherwise <code>void</code> \u2705 <code>every{T}</code> <code>(T[], T -&gt; bool) -&gt; bool</code> Returns <code>true</code> if every element in the <code>T[]</code> returns <code>true</code> when passed to the <code>T -&gt; bool</code> function \u2705 <code>some{T}</code> <code>(T[], T -&gt; bool) -&gt; bool</code> Returns <code>true</code> if any element in the <code>T[]</code> returns <code>true</code> when passed to the <code>T -&gt; bool</code> function \u2705 <code>repeat{T}</code> <code>(T[], i64) -&gt; T[]</code> Returns a new <code>T[]</code> that is the original <code>T[]</code> appended to itself the number of times specified by the <code>i64</code> \u2705 <code>store{T}</code> <code>(Mut{T[]}, i64, T) -&gt; void!</code> Stores the <code>T</code> in the specified index (shifting later values forward). Returns an Error if the array is too small. AKA <code>arr[idx] = val</code> \u2705 <code>delete{T}</code> <code>(Mut{T[]}, i64) -&gt; T!</code> Deletes the <code>T</code> at the index specified in the <code>i64</code> from the <code>T[]</code> and returns it. If the index does not exist, it returns an <code>Error</code> \u2705 <code>last{T}</code> <code>T[] -&gt; T?</code> Returns the last <code>T</code> value in the <code>T[]</code> without mutating it. If the array is empty it returns <code>void</code> \u2705 <code>swap{T}</code> <code>(Mut{T[]}, i64, i64) -&gt; void!</code> Swaps the values at the two specified indexes. Returns an <code>Error</code> if either index is invalid \u2705 <code>sort{T}</code> <code>(Mut{T[]}, (T, T) -&gt; i8) -&gt; void</code> Sorts the array using the provided sorting function. <code>0</code> means the elements are equal, negative for keep the order, positive for flip \u2705 <code>sort{T}</code> <code>Mut{T[]} -&gt; void</code> Sorts the array using the <code>T</code> type's built-in ordering logic. Requires <code>eq</code> and <code>lt</code> to have been implemented for the type \u2705 <code>magnitude</code> <code>f32[] -&gt; f32</code> Computes the magnitude of a vector represented by the array \u2705 <code>magnitude</code> <code>f64[] -&gt; f64</code> Computes the magnitude of a vector represented by the array \u2705 <code>normalize</code> <code>f32[] -&gt; f32[]</code> Converts the vector represented by the array into a unit vector (magnitude of <code>1</code>) \u2705 <code>normalize</code> <code>f64[] -&gt; f64[]</code> Converts the vector represented by the array into a unit vector (magnitude of <code>1</code>) \u2705 <code>inverseSqrt</code> <code>f32[] -&gt; f32[]</code> Calculates the inverse square root for all elements of the array \u2705 <code>inverseSqrt</code> <code>f64[] -&gt; f64[]</code> Calculates the inverse square root for all elements of the array \u2705 <code>fma</code> <code>(f32[], f32[], f32[]) -&gt; f32[]!</code> Calculates the fused multiply add operation for all three arrays. Returns an <code>Error</code> if any of the array lengths do not match \u2705 <code>fma</code> <code>(f64[], f64[], f64[]) -&gt; f64[]!</code> Calculates the fused multiply add operation for all three arrays. Returns an <code>Error</code> if any of the array lengths do not match \u2705 <code>fract</code> <code>f32[] -&gt; f32[]</code> Returns the fractional component of each <code>f32</code> element in the array \u2705 <code>fract</code> <code>f64[] -&gt; f64[]</code> Returns the fractional component of each <code>f64</code> element in the array \u2705"},{"location":"built_ins/#buffer-related-functions","title":"Buffer-related functions","text":"Name Type Description Explicit <code>Buffer{T, S}</code> <code>T -&gt; T[S]</code> Creates a fixed buffer with all <code>S</code> elements set to the <code>T</code> value \u274c <code>Buffer{T, S}</code> <code>(T, ...) -&gt; T[S]</code> Creates a fixed buffer with the <code>T</code> values set. Argument length must match buffer size \u274c <code>.0, .1, etc</code> <code>T[S] -&gt; T</code> Explicit property-based buffer value lookups guaranteed to return the value, as it is a compile-time failure to access out-of-bounds indexes \u274c <code>get{T, S}</code> <code>(T[S], i64) -&gt; T?</code> Returns the value at the specified index, or <code>void</code> if out-of-bounds. Can also be written <code>buf[idx]</code> \u2705 <code>map{T, S, U}</code> <code>(T[S], T -&gt; U) -&gt; U[S]</code> Maps the elements of the <code>T[S]</code> buffer into a <code>U[S]</code> buffer using the <code>T -&gt; U</code> function \u2705 <code>map{T, S, U}</code> <code>(T[S], (T, i64) -&gt; U) -&gt; U[S]</code> Maps the elements and indexes of the <code>T[S]</code> buffer into a <code>U[S]</code> buffer using the <code>(T, i64) -&gt; U</code> function \u2705 <code>reduce{T, S}</code> <code>(T[S], (T, T) -&gt; T) -&gt; T?</code> Combines the <code>T[S]</code> elements into a singular <code>T</code> value. Returns <code>void</code> if <code>S</code> is <code>0</code> \u2705 <code>reduce{T, S, U}</code> <code>(T[S], U, (U, T) -&gt; U) -&gt; U</code> Combines the <code>T[S]</code> elements and an initial <code>U</code> value into a new <code>U</code> value \u2705 <code>has{T, S}</code> <code>(T[S], T) -&gt; bool</code> Returns <code>true</code> if the <code>T</code> value is anywhere within the <code>T[S]</code> buffer \u2705 <code>has{T, S}</code> <code>(T[S], T -&gt; bool) -&gt; bool</code> Returns <code>true</code> if any <code>T</code> value in the <code>T[S]</code> returns <code>true</code> when passed to the <code>T -&gt; bool</code> function \u2705 <code>find{T, S}</code> <code>(T[S], T -&gt; bool) -&gt; T?</code> Returns the first <code>T</code> value that returns <code>true</code> when passed to the <code>T -&gt; bool</code> function. Returns `void otherwise \u2705 <code>every{T, S}</code> <code>(T[S], T -&gt; bool) -&gt; bool</code> Returns <code>true</code> if every <code>T</code> value returns <code>true</code> when passed to the <code>T -&gt; bool</code> function \u2705 <code>concatInner{T, S, N}</code> <code>(Mut{T[S + N]}, T[S], T[N]) -&gt; ()</code> Replaces the values in <code>T[S + N]</code> with the values in <code>T[S]</code> and <code>T[N]</code>. Likely won't be used directly \u2705 <code>concat{T, S, N}</code> <code>(T[S], T[N]) -&gt; T[S + N]</code> Concatenates two buffers together, creating a new buffer with a fixed length derived from the input buffer lengths \u2705 <code>repeat{T, S}</code> <code>(T[S], i64) -&gt; T[]</code> Repeats the input buffer the number of times specified in the <code>i64</code> into a new <code>T[]</code>. Length is determined at runtime so it must be an array \u2705 <code>store{T, S}</code> <code>(Mut{T[S]}, i64, T) -&gt; T!</code> Stores the new <code>T</code> value in the index specified by the <code>i64</code> into the <code>T[S]</code>. As buffers do not grow, it returns the old value, or an <code>Error</code> \u2705 <code>cross</code> <code>(f32[3], f32[3]) -&gt; f32[3]</code> Computes the cross product of two 3-element vectors \u2705 <code>cross</code> <code>(f64[3], f64[3]) -&gt; f64[3]</code> Computes the cross product of two 3-element vectors \u2705 <code>dot{I}</code> <code>(I[2], I[2]) -&gt; I</code> Computes the dot product of the 2-element vectors. <code>I</code> must implement <code>add</code> and <code>mul</code> \u2705 <code>dot{I}</code> <code>(I[3], I[3]) -&gt; I</code> Computes the dot product of the 3-element vectors. <code>I</code> must implement <code>add</code> and <code>mul</code> \u2705 <code>dot{I}</code> <code>(I[4], I[4]) -&gt; I</code> Computes the dot product of the 4-element vectors. <code>I</code> must implement <code>add</code> and <code>mul</code> \u2705 <code>swap{T, S}</code> <code>(Mut{T[S]}, i64, i64) -&gt; void!</code> Swaps the values at the two specified indexes. Returns an <code>Error</code> if either index is out-of-bounds \u2705 <code>sort{T, S}</code> <code>(Mut{T[S]}, (T, T) -&gt; i8) -&gt; ()</code> Sorts the buffer using the provided sorting function. <code>0</code> means the elements are equal, negative for keeping the order, positive for swap \u2705 <code>sort{T, S}</code> <code>Mut{T[S]} -&gt; void</code> Sorts the buffer using the <code>T</code> type's built-in ordering logic. Requires <code>eq</code> and <code>lt</code> to have been implemented for the type \u2705 <code>magnitude{S}</code> <code>f32[S] -&gt; f32</code> Computes the magnitude of the vector represented by the <code>f32[S]</code> \u2705 <code>magnitude{S}</code> <code>f64[S] -&gt; f64</code> Computes the magnitude of the vector represented by the <code>f64[S]</code> \u2705 <code>normalize{S}</code> <code>f32[S] -&gt; f32[S]</code> Converts the vector represented by the buffer into a unit vector (magnitude of <code>1</code>) \u2705 <code>normalize{S}</code> <code>f64[S] -&gt; f64[S]</code> Converts the vector represented by the buffer into a unit vector (magnitude of <code>1</code>) \u2705 <code>inverseSqrt{S}</code> <code>f32[S] -&gt; f32[S]</code> Calculates the inverse square root for all elements of the buffer \u2705 <code>inverseSqrt{S}</code> <code>f64[S] -&gt; f64[S]</code> Calculates the inverse square root for all elements of the buffer \u2705 <code>fma{S}</code> <code>(f32[S], f32[S], f32[S]) -&gt; f32[S]</code> Calculates the fused multiply add operation for all three buffers \u2705 <code>fma{S}</code> <code>(f64[S], f64[S], f64[S]) -&gt; f64[S]</code> Calculates the fused multiply add operation for all three buffers \u2705 <code>fract{S}</code> <code>f32[S] -&gt; f32[S]</code> Returns the fractional component of each <code>f32</code> element in the array \u2705 <code>fract{S}</code> <code>f64[S] -&gt; f64[S]</code> Returns the fractional component of each <code>f64</code> element in the array \u2705 <code>determinant{T}</code> <code>T[4] -&gt; T</code> Calculates the determinant of a 2x2 matrix. <code>T</code> must implement <code>add</code>, <code>sub</code>, and <code>mul</code> \u2705 <code>determinant{T}</code> <code>T[9] -&gt; T</code> Calculates the determinant of a 3x3 matrix. <code>T</code> must implement <code>add</code>, <code>sub</code>, and <code>mul</code> \u2705 <code>determinant{T}</code> <code>T[16] -&gt; T</code> Calculates the determinant of a 4x4 matrix. <code>T</code> must implement <code>add</code>, <code>sub</code>, and <code>mul</code> \u2705"},{"location":"built_ins/#dictionary-related-functions","title":"Dictionary-related functions","text":"Name Type Description <code>Dict{K, V}</code> <code>() -&gt; Dict{K, V}</code> Constructs a new dictionary <code>Dict{K, V}</code> <code>(K, V) -&gt; Dict{K, V}</code> Constructs a new dictionary with an inital key-value pair <code>Dict{K, V}</code> <code>Array{(K, V)} -&gt; Dict{K, V}</code> Construct a new dictionary from an array of key-value tuples <code>has{K, V}</code> <code>(Dict{K, V}, K) -&gt; bool</code> Returns <code>true</code> if the <code>K</code> value is used as a key <code>get{K, V}</code> <code>(Dict{K, V}, K) -&gt; V?</code> Returns the value if the <code>K</code> value is used as a key, otherwise returns <code>void</code>. Can also be written <code>dict[key]</code> <code>store{K, V}</code> <code>(Mut{Dict{K, V}}, K, V) -&gt; void</code> Stores the value <code>V</code> referenceable by the key <code>K</code>. Can also be written <code>dict[key] = val</code> <code>len{K, V}</code> <code>Dict{K, V} -&gt; i64</code> Returns the number of key-value pairs in the dictionary <code>keys{K, V}</code> <code>Dict{K, V} -&gt; K[]</code> Returns an array of all of the keys in the dictionary. The array is in insertion order <code>vals{K, V}</code> <code>Dict{K, V} -&gt; V[]</code> Returns an array of all of the values in the dictionary. The array is in insertion order <code>Array{K, V}</code> <code>Dict{K, V} -&gt; Array{(K, V)}</code> Returns an array of all key-value pairs in the dictionary as tuples. The array is in insertion order <code>concat{K, V}</code> <code>(Dict{K, V}, Dict{K, V}) -&gt; Dict{K, V}</code> Returns a new dictionary that is the concatenation of the two input dictionaries"},{"location":"built_ins/#set-related-functions","title":"Set-related functions","text":"Name Type Description <code>Set{V}</code> <code>() -&gt; Set{V}</code> Constructs a new set <code>Set{V}</code> <code>V -&gt; Set{V}</code> Constructs a new set with an initial value <code>Set{V}</code> <code>V[] -&gt; Set{V}</code> Constructs a new set from an array of values <code>store{V}</code> <code>(Mut{Set{V}}, V) -&gt; ()</code> Stores the value <code>V</code> in the set. Can be written as <code>set = val</code> but please don't <code>has{V}</code> <code>(Set{V}, V) -&gt; bool</code> Returns <code>true</code> if the value <code>V</code> is in the set <code>len{V}</code> <code>Set{V} -&gt; i64</code> Returns the number of values in the set <code>Array{V}</code> <code>Set{V} -&gt; V[]</code> Returns an array of values in the set. No guarantee on ordering <code>union{V}</code> <code>(Set{V}, Set{V}) -&gt; Set{V}</code> Returns a new set that is the union of the input sets (all values from both sets, deduplicated) <code>or{V}</code> <code>(Set{V}, Set{V}) -&gt; Set{V}</code> An alias for <code>union{V}</code> (for binding to the <code>||</code> operator) <code>intersect{V}</code> <code>(Set{V}, Set{V}) -&gt; Set{V}</code> Returns a new set that is the intersection of the input sets (only values in both sets) <code>and{V}</code> <code>(Set{V}, Set{V}) -&gt; Set{V}</code> An alias for <code>intersect{V}</code> (for binding to the <code>&amp;&amp;</code> operator) <code>difference{V}</code> <code>(Set{V}, Set{V}) -&gt; Set{V}</code> Returns a new set that is the difference of the input sets (only values only in the first set) <code>div{V}</code> <code>(Set{V}, Set{V}) -&gt; Set{V}</code> An alias for <code>difference{V}</code> (for binding to the <code>/</code> operator) <code>symmetricDifference{V}</code> <code>(Set{V}, Set{V}) -&gt; Set{V}</code> Returns a new set that is the symmetric difference of the input sets (all values from both sets, except those in both) <code>xor{V}</code> <code>(Set{V}, Set{V}) -&gt; Set{V}</code> An alias for <code>symmetricDifference{V}</code> (for binding to the <code>^</code> operator) <code>product{V}</code> <code>(Set{V}, Set{V}) -&gt; Set{(V, V)}</code> Returns a new set that is the product of the input sets (tuples of all values from each set paired together) <code>mul{V}</code> <code>(Set{V}, Set{V}) -&gt; Set{(V, V)}</code> An alias for <code>product{V}</code> (for binding to the <code>*</code> operator)"},{"location":"built_ins/#tree-related-functions","title":"Tree-related functions","text":"Name Type Description Explicit <code>Tree{T}</code> <code>(Array{T}, Array{Maybe{i64}}, Array{Array{i64}}) -&gt; Tree{T}</code> Constructs a new tree by manually defining its internals. You probably don't want this \u274c <code>Node{T}</code> <code>(i64, Tree{T}) -&gt; Node{T}</code> Constructs a new node by manually specifying the node id and the tree it references. You probably don't want this \u274c <code>Tree{T}</code> <code>T -&gt; Tree{T}</code> Constructs a new tree with the provided <code>T</code> value as the root node \u2705 <code>Tree{T}</code> <code>Node{T} -&gt; Tree{T}</code> Returns the tree the node is associated with \u2705 <code>rootNode{T}</code> <code>Tree{T} -&gt; Node{T}</code> Returns the root node of the provided tree \u2705 <code>len{T}</code> <code>Tree{T} -&gt; i64</code> Returns the number of nodes in the tree \u2705 <code>Node{T}</code> <code>(Tree{T}, i64) -&gt; Node{T}?</code> Constructs a new node for the specified node id, but will return <code>void</code> if the node id doesn't exist \u2705 <code>parent{T}</code> <code>Node{T} -&gt; Node{T}?</code> Returns the parent node of the current node, or <code>void</code> if the current node is the root node \u2705 <code>children{T}</code> <code>Node{T} -&gt; Node{T}[]</code> Returns an array of nodes that are children of the current node \u2705 <code>children{T}</code> <code>Tree{T} -&gt; Node{T}[]</code> Returns an array of nodes that are children of the root node of the tree \u2705 <code>addChild{T}</code> <code>(Node{T}, T) -&gt; Node{T}</code> Adds the provided <code>T</code> as a child of the provided node, returning the new node for that value \u2705 <code>addChild{T}</code> <code>(Node{T}, Tree{T}) -&gt; Node{T}</code> Adds the provided tree as a child of the provided node, returning the new node that represents the root node of the tree \u2705 <code>addChild{T}</code> <code>(Tree{T}, T) -&gt; Node{T}</code> Adds the provided <code>T</code> as a child of the root node of the provided tree, returning the new node for that value \u2705 <code>getOr{T}</code> <code>(Node{T}, T) -&gt; T</code> Returns the value the node points to or the default <code>T</code> value provided if the node is invalid \u2705 <code>Array{T}</code> <code>Tree{T} -&gt; Array{Node{T}}</code> Returns an array of all nodes in the tree \u2705 <code>map{T, U}</code> <code>(Tree{T}, Node{T} -&gt; Node{U}) -&gt; Tree{U}</code> Maps a tree from type <code>T</code> to <code>U</code> using a function that converts from one node type to the other \u2705 <code>map{T, U}</code> <code>(Tree{T}, (Node{T}, i64) -&gt; Node{U}) -&gt; Tree{U}</code> Maps a tree from type <code>T</code> to <code>U</code> using a function that converts from one node type (and node id) to the other \u2705 <code>every{T}</code> <code>(Tree{T}, Node{T} -&gt; bool) -&gt; bool</code> Returns <code>true</code> if every node in the tree returns <code>true</code> when passed to the provided function \u2705 <code>some{T}</code> <code>(Tree{T}, Node{T} -&gt; bool) -&gt; bool</code> Returns <code>true</code> if any node in the tree returns <code>true</code> when passed to the provided function \u2705 <code>reduce{T}</code> <code>(Tree{T}, (Node{T}, Node{T}) -&gt; Node{T}) -&gt; Node{T}?</code> Reduces the entire tree to a singular node using the provided function, or <code>void</code> if the tree is empty \u2705 <code>reduce{T}</code> <code>(Tree{T}, (Node{T}, Node{T}, i64) -&gt; Node{T}) -&gt; Node{T}?</code> Reduces the entire tree to a singular node using the provided function and node index, or <code>void</code> if the tree is empty \u2705 <code>reduce{T, U}</code> <code>(Tree{T}, U, (U, Node{T}) -&gt; U) -&gt; U</code> Reduces the entire tree to a singular <code>U</code> value, or returns the initial <code>U</code> value if the tree is empty \u2705 <code>reduce{T, U}</code> <code>(Tree{T}, U, (U, Node{T}, i64) -&gt; U) -&gt; U</code> Reduces the entire tree to a singular <code>U</code> value using the node indexes, or returns the initial <code>U</code> value if the tree is empty \u2705 <code>find{T}</code> <code>(Tree{T}, Node{T} -&gt; bool) -&gt; Node{T}?</code> Finds the first node in the tree that returns <code>true</code> when passed to the provided function, otherwise <code>void</code> \u2705"},{"location":"built_ins/#thread-related-functions","title":"Thread-related functions","text":"Name Type Description <code>wait</code> <code>i64 -&gt; ()</code> Sleeps the current thread for the specified number of milliseconds."},{"location":"built_ins/#time-related-functions","title":"Time-related functions","text":"Name Type Description <code>now</code> <code>() -&gt; Instant</code> Returns a representation of the current time (opaque, Rust-only) <code>now</code> <code>() -&gt; Performance</code> Returns a representation of the curent time (opaque, Javascript-only) <code>elapsed</code> <code>Instant -&gt; Duration</code> Calculates the delta between the tagged time and now (opaque, Rust-only) <code>elasped</code> <code>Performance -&gt; f64</code> Calculates the delta between the tagged time and now (<code>f64</code> seconds, Javascript-only) <code>f64</code> <code>Duration -&gt; f64</code> Converts the opaque duration into an <code>f64</code> in seconds, (Rust-only)"},{"location":"built_ins/#uuid-related-functions","title":"Uuid-related functions","text":"Name Type Description <code>uuid</code> <code>() -&gt; uuid</code> Generates a new UUID (opaque) <code>string</code> <code>uuid -&gt; string</code> Creates a string representation of the UUID"},{"location":"built_ins/#gpu-related-functions","title":"GPU-related functions","text":"Name Type Description Explicit <code>mapReadBuffer</code> <code>() -&gt; BufferUsages</code> Returns the buffer usages needed for a GPU -&gt; CPU read buffer \u2705 <code>mapWriteBuffer</code> <code>() -&gt; BufferUsages</code> Returns the buffer usages needed for a CPU -&gt; GPU write buffer \u2705 <code>storageBuffer</code> <code>() -&gt; BufferUsages</code> Returns the buffer usages needed for a GPU-only read/write storage buffer \u2705 <code>GBuffer{T}</code> <code>(GBufferRaw, String{T}) -&gt; GBuffer{T}</code> Constructs the wrapper for a raw buffer on the GPU with the related CPU type as a compile-time string \u274c <code>GBuffer{T}</code> <code>(BufferUsages, T[]) -&gt; GBuffer{T}</code> Constructs a buffer on the GPU using the provided array as data \u2705 <code>GBuffer{T}</code> <code>(BufferUsages, i64) -&gt; GBuffer{T}</code> Constructs an empty buffer on the GPU using the <code>i64</code> as the size in bytes \u2705 <code>GBuffer{T}</code> <code>T[] -&gt; GBuffer{T}</code> Constructs a storage buffer using the provided array as data \u2705 <code>GBuffer{T}</code> <code>i64 -&gt; GBuffer{T}</code> Constructs an empty storage buffer on the GPU using the <code>i64</code> as the size in bytes \u2705 <code>GBufferTagged</code> <code>(GBufferRaw, string) -&gt; GBufferTagged</code> Constructs the wrapper for a raw buffer on the GPU with the related GPU type as a run-time string \u274c <code>GBufferTagged{T}</code> <code>GBuffer{T} -&gt; GBufferTagged</code> Constructs the tagged version of a <code>GBuffer{T}</code> for you. This is the version meant to be used \u2705 <code>cpulen{T}</code> <code>GBuffer{T} -&gt; i64</code> Returns the size in bytes of the buffer. CPU-only, not GPGPU \u2705 <code>id</code> <code>GBufferRaw -&gt; string</code> Returns a unique ID string for the buffer \u2705 <code>id{T}</code> <code>GBuffer{T} -&gt; string</code> Returns a unique ID string for the buffer \u2705 <code>id</code> <code>GBufferTagged -&gt; string</code> Returns a unique ID string for the buffer \u2705 <code>GPGPU</code> <code>(string, Array{Array{GBufferRaw}}, i64[3]) -&gt; GPGPU</code> Constructs a representation of <code>GPGPU</code> work to be done. The <code>string</code> is the WGSL shader code working on the provided buffers executing with the number of X, Y, and Z workgroups specified in the <code>i64[3]</code> \u2705 <code>GPGPU{T}</code> <code>(string, GBuffer{T}) -&gt; GPGPU</code> Constructs a representation of <code>GPGPU</code> work to be done. The <code>string</code> is the WGSL shader code using the singular buffer. The set of workgroups is automatically derived from the buffer size \u2705 <code>run</code> <code>Mut{GPGPU} -&gt; ()</code> Runs the representation of <code>GPGPU</code> work. Mutates the underlying buffers (by design) and compiles the shader code, if necessary, and caches it \u2705 <code>run</code> <code>Mut{GPGPU[]} -&gt; ()</code> Runs the array of <code>GPGPU</code> work sequentially on the GPU. Mutates the underlying buffers (by design) and compiles the shader code, if necessary, and caches it \u2705 <code>shader</code> <code>GPGPU -&gt; string</code> Extracts the shader code from the <code>GPGPU</code> value \u2705 <code>read{T}</code> <code>GBuffer{T} -&gt; T[]</code> Reads the data stored in the GPU buffer as an array of <code>T</code> values \u2705 <code>replace{T}</code> <code>(GBuffer{T}, T[]) -&gt; ()!</code> Replaces the data stored in the GPU buffer with the array of <code>T</code> values. Returns an <code>Error</code> if unsuccessful \u2705"},{"location":"built_ins/#ergonomic-gpgpu-functions","title":"Ergonomic GPGPU functions","text":"Name Type Description Explicit <code>WgpuType{N}</code> <code>(N, string, Dict{string, string}, Set{GBufferTagged}) -&gt; WgpuType{N}</code> Manually construct a WGSL value for any type of data. <code>N</code> must be a compile-time <code>String</code> representing the WGSL type, the <code>string</code> is the name of the value, <code>Dict{string, string}</code> is the set of value-definition pairs needed to create the value, and <code>Set{GBuffer}</code> is the set of GPU buffers needed to create it. You probably won't use this directly \u274c <code>build{N}</code> <code>N -&gt; GPGPU</code> Builds a representation of <code>GPGPU</code> work to be done. The <code>N</code> type must be derived from the <code>WgpuType{N}</code> for it to work. The dictionary of value definitions is used to construct a compute shader to generate the value represented by the <code>string</code>, and the set of GPU buffers is turned into an array of GPU buffers for the shader to use \u2705 <code>build{N}</code> <code>N[] -&gt; GPGPU</code> Builds a representation of <code>GPGPU</code> work to be done. The <code>N</code> type must be derived from the <code>WgpuType{N}</code> for it to work. This variant allows for multiple values to be calculated within a single shader (generally assignments to the GPU buffers to cause side-effects since they cannot by definition explicitly depend on each other ) \u2705"},{"location":"built_ins/#gpgpu-primitive-type-functions","title":"GPGPU Primitive Type functions","text":"Name Type Description Explicit <code>gu32</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gu32</code> Manually construct a GPU <code>u32</code> value. You probably won't use this directly \u274c <code>gi32</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gi32</code> Manually construct a GPU <code>i32</code> value. You probably won't use this directly \u274c <code>gf32</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gf32</code> Manually construct a GPU <code>f32</code> value. You probably won't use this directly \u274c <code>gbool</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gbool</code> Manually construct a GPU <code>bool</code> value. You probably won't use this directly \u274c <code>gPrimitiveConvert{I, O}</code> <code>I -&gt; O</code> Manually construct a GPU type cast from the input type to the output type. You probably won't use this directly \u2705 <code>gu32</code> <code>u32 -&gt; gu32</code> Converts a <code>u32</code> into a GPU <code>u32</code> \u2705 <code>gu32</code> <code>gu32 -&gt; gu32</code> Returns the original value back \u2705 <code>gu32</code> <code>gi32 -&gt; gu32</code> Converts a <code>gi32</code> to a <code>gu32</code> \u2705 <code>gu32</code> <code>gf32 -&gt; gu32</code> Converts a <code>gf32</code> to a <code>gu32</code> \u2705 <code>gu32</code> <code>gbool -&gt; gu32</code> Converts a <code>gbool</code> to a <code>gu32</code> \u2705 <code>gu32{T}</code> <code>T -&gt; gu32</code> Converts the input type into a <code>u32</code> and then converts that into a <code>gu32</code> \u2705 <code>gi32</code> <code>i32 -&gt; gi32</code> Converts a <code>i32</code> into a GPU <code>i32</code> \u2705 <code>gi32</code> <code>gu32 -&gt; gi32</code> Converts a <code>gu32</code> to a <code>gi32</code> \u2705 <code>gi32</code> <code>gi32 -&gt; gi32</code> Returns the original value back \u2705 <code>gi32</code> <code>gf32 -&gt; gi32</code> Converts a <code>gf32</code> to a <code>gi32</code> \u2705 <code>gi32</code> <code>gbool -&gt; gi32</code> Converts a <code>gbool</code> to a <code>gi32</code> \u2705 <code>gi32{T}</code> <code>T -&gt; gi32</code> Converts the input type into a <code>i32</code> and then converts that into a <code>gi32</code> \u2705 <code>gf32</code> <code>f32 -&gt; gf32</code> Converts a <code>f32</code> into a GPU <code>f32</code> \u2705 <code>gf32</code> <code>gu32 -&gt; gf32</code> Converts a <code>gu32</code> to a <code>gf32</code> \u2705 <code>gf32</code> <code>gi32 -&gt; gf32</code> Converts a <code>gi32</code> to a <code>gf32</code> \u2705 <code>gf32</code> <code>gf32 -&gt; gf32</code> Returns the original value back \u2705 <code>gf32</code> <code>gbool -&gt; gf32</code> Converts a <code>gbool</code> to a <code>gf32</code> \u2705 <code>gf32{T}</code> <code>T -&gt; gf32</code> Converts the input type into a <code>f32</code> and then converts that into a <code>gf32</code> \u2705 <code>gbool</code> <code>bool -&gt; gbool</code> Converts a <code>bool</code> into a GPU <code>bool</code> \u2705 <code>gbool</code> <code>gu32 -&gt; gbool</code> Converts a <code>gu32</code> to a <code>gbool</code> \u2705 <code>gbool</code> <code>gi32 -&gt; gbool</code> Converts a <code>gi32</code> to a <code>gbool</code> \u2705 <code>gbool</code> <code>gf32 -&gt; gbool</code> Converts a <code>gf32</code> to a <code>gbool</code> \u2705 <code>gbool</code> <code>gbool -&gt; gbool</code> Returns the original value back \u2705 <code>gbool{T}</code> <code>T -&gt; gbool</code> Converts the input type into a <code>bool</code> and then converts that into a <code>gbool</code> \u2705 <code>len{T}</code> <code>GBuffer{T} -&gt; gu32</code> Returns the length of the specified GPU buffer as a <code>gu32</code> to use in GPGPU computation \u2705"},{"location":"built_ins/#gpgpu-vector-constructor-functions","title":"GPGPU Vector Constructor functions","text":"Name Type Description Explicit <code>gvec2u</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gvec2u</code> Manually construct a GPU 2-element <code>u32</code> vector. You probably won't use this directly \u274c <code>gvec2i</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gvec2u</code> Manually construct a GPU 2-element <code>i32</code> vector. You probably won't use this directly \u274c <code>gvec2f</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gvec2u</code> Manually construct a GPU 2-element <code>f32</code> vector. You probably won't use this directly \u274c <code>gvec2b</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gvec2u</code> Manually construct a GPU 2-element <code>bool</code> vector. You probably won't use this directly \u274c <code>gvec3u</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gvec3u</code> Manually construct a GPU 3-element <code>u32</code> vector. You probably won't use this directly \u274c <code>gvec3i</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gvec3u</code> Manually construct a GPU 3-element <code>i32</code> vector. You probably won't use this directly \u274c <code>gvec3f</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gvec3u</code> Manually construct a GPU 3-element <code>f32</code> vector. You probably won't use this directly \u274c <code>gvec3b</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gvec3u</code> Manually construct a GPU 3-element <code>bool</code> vector. You probably won't use this directly \u274c <code>gvec4u</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gvec4u</code> Manually construct a GPU 4-element <code>u32</code> vector. You probably won't use this directly \u274c <code>gvec4i</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gvec4u</code> Manually construct a GPU 4-element <code>i32</code> vector. You probably won't use this directly \u274c <code>gvec4f</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gvec4u</code> Manually construct a GPU 4-element <code>f32</code> vector. You probably won't use this directly \u274c <code>gvec4b</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gvec4u</code> Manually construct a GPU 4-element <code>bool</code> vector. You probably won't use this directly \u274c <code>gvec2Primitive{I, O}</code> <code>(I, I) -&gt; O</code> Manually construct a GPU type cast from the input types into the output type. You probably won't use this directly \u2705 <code>gvec2u</code> <code>() -&gt; gvec2u</code> Returns a default GPU 2-element <code>u32</code> vector \u2705 <code>gvec2u</code> <code>(gu32, gu32) -&gt; gvec2u</code> Constructs a GPU 2-element <code>u32</code> vector with GPU <code>u32</code> values \u2705 <code>gvec2u{T}</code> <code>(T, T) -&gt; gvec2u</code> Converts the provided values into GPU <code>u32</code> values and then constructs a GPU 2-element <code>u32</code> vector \u2705 <code>gvec2u{T}</code> <code>T -&gt; gvec2u</code> Converts the provided value into a GPU <code>u32</code> value and the constructs a GPU 2-element <code>u32</code> vector with both values set to this value \u2705 <code>gvec2i</code> <code>() -&gt; gvec2i</code> Returns a default GPU 2-element <code>i32</code> vector \u2705 <code>gvec2i</code> <code>(gi32, gi32) -&gt; gvec2i</code> Constructs a GPU 2-element <code>i32</code> vector with GPU <code>i32</code> values \u2705 <code>gvec2i{T}</code> <code>(T, T) -&gt; gvec2i</code> Converts the provided values into GPU <code>i32</code> values and then constructs a GPU 2-element <code>i32</code> vector \u2705 <code>gvec2i{T}</code> <code>T -&gt; gvec2i</code> Converts the provided value into a GPU <code>i32</code> value and the constructs a GPU 2-element <code>i32</code> vector with both values set to this value \u2705 <code>gvec2f</code> <code>() -&gt; gvec2f</code> Returns a default GPU 2-element <code>f32</code> vector \u2705 <code>gvec2f</code> <code>(gf32, gf32) -&gt; gvec2f</code> Constructs a GPU 2-element <code>f32</code> vector with GPU <code>f32</code> values \u2705 <code>gvec2f{T}</code> <code>(T, T) -&gt; gvec2f</code> Converts the provided values into GPU <code>f32</code> values and then constructs a GPU 2-element <code>f32</code> vector \u2705 <code>gvec2f{T}</code> <code>T -&gt; gvec2f</code> Converts the provided value into a GPU <code>f32</code> value and the constructs a GPU 2-element <code>f32</code> vector with both values set to this value \u2705 <code>gvec2b</code> <code>() -&gt; gvec2b</code> Returns a default GPU 2-element <code>bool</code> vector \u2705 <code>gvec2b</code> <code>(gbool, gbool) -&gt; gvec2b</code> Constructs a GPU 2-element <code>bool</code> vector with GPU <code>bool</code> values \u2705 <code>gvec2b{T}</code> <code>(T, T) -&gt; gvec2b</code> Converts the provided values into GPU <code>bool</code> values and then constructs a GPU 2-element <code>bool</code> vector \u2705 <code>gvec2b{T}</code> <code>T -&gt; gvec2b</code> Converts the provided value into a GPU <code>bool</code> value and the constructs a GPU 2-element <code>bool</code> vector with both values set to this value \u2705 <code>gvec3Primitive{I, O}</code> <code>(I, I, I) -&gt; O</code> Manually construct a GPU type cast from the input types into the output type. You probably won't use this directly \u2705 <code>gvec3u</code> <code>() -&gt; gvec3u</code> Returns a default GPU 3-element <code>u32</code> vector \u2705 <code>gvec3u</code> <code>(gu32, gu32, gu32) -&gt; gvec3u</code> Constructs a GPU 3-element <code>u32</code> vector with GPU <code>u32</code> values \u2705 <code>gvec3u{T}</code> <code>(T, T, T) -&gt; gvec3u</code> Converts the provided values into GPU <code>u32</code> values and then constructs a GPU 3-element <code>u32</code> vector \u2705 <code>gvec3u{T}</code> <code>T -&gt; gvec3u</code> Converts the provided value into a GPU <code>u32</code> value and the constructs a GPU 3-element <code>u32</code> vector with all values set to this value \u2705 <code>gvec3i</code> <code>() -&gt; gvec3i</code> Returns a default GPU 3-element <code>i32</code> vector \u2705 <code>gvec3i</code> <code>(gi32, gi32, gi32) -&gt; gvec3i</code> Constructs a GPU 3-element <code>i32</code> vector with GPU <code>i32</code> values \u2705 <code>gvec3i{T}</code> <code>(T, T, T) -&gt; gvec3i</code> Converts the provided values into GPU <code>i32</code> values and then constructs a GPU 3-element <code>i32</code> vector \u2705 <code>gvec3i{T}</code> <code>T -&gt; gvec3i</code> Converts the provided value into a GPU <code>i32</code> value and the constructs a GPU 3-element <code>i32</code> vector with all values set to this value \u2705 <code>gvec3f</code> <code>() -&gt; gvec3f</code> Returns a default GPU 3-element <code>f32</code> vector \u2705 <code>gvec3f</code> <code>(gf32, gf32, gf32) -&gt; gvec3f</code> Constructs a GPU 3-element <code>f32</code> vector with GPU <code>f32</code> values \u2705 <code>gvec3f{T}</code> <code>(T, T, T) -&gt; gvec3f</code> Converts the provided values into GPU <code>f32</code> values and then constructs a GPU 3-element <code>f32</code> vector \u2705 <code>gvec3f{T}</code> <code>T -&gt; gvec3f</code> Converts the provided value into a GPU <code>f32</code> value and the constructs a GPU 3-element <code>f32</code> vector with all values set to this value \u2705 <code>gvec3b</code> <code>() -&gt; gvec3b</code> Returns a default GPU 3-element <code>bool</code> vector \u2705 <code>gvec3b</code> <code>(gbool, gbool, gbool) -&gt; gvec3b</code> Constructs a GPU 3-element <code>bool</code> vector with GPU <code>bool</code> values \u2705 <code>gvec3b{T}</code> <code>(T, T, T) -&gt; gvec3b</code> Converts the provided values into GPU <code>bool</code> values and then constructs a GPU 3-element <code>bool</code> vector \u2705 <code>gvec3b{T}</code> <code>T -&gt; gvec3b</code> Converts the provided value into a GPU <code>bool</code> value and the constructs a GPU 3-element <code>bool</code> vector with all values set to this value \u2705 <code>gvec4Primitive{I, O}</code> <code>(I, I, I, I) -&gt; O</code> Manually construct a GPU type cast from the input types into the output type. You probably won't use this directly \u2705 <code>gvec4u</code> <code>() -&gt; gvec4u</code> Returns a default GPU 4-element <code>u32</code> vector \u2705 <code>gvec4u</code> <code>(gu32, gu32, gu32, gu32) -&gt; gvec4u</code> Constructs a GPU 4-element <code>u32</code> vector with GPU <code>u32</code> values \u2705 <code>gvec4u{T}</code> <code>(T, T, T, T) -&gt; gvec4u</code> Converts the provided values into GPU <code>u32</code> values and then constructs a GPU 4-element <code>u32</code> vector \u2705 <code>gvec4u{T}</code> <code>T -&gt; gvec4u</code> Converts the provided value into a GPU <code>u32</code> value and the constructs a GPU 4-element <code>u32</code> vector with all values set to this value \u2705 <code>gvec4i</code> <code>() -&gt; gvec4i</code> Returns a default GPU 4-element <code>i32</code> vector \u2705 <code>gvec4i</code> <code>(gi32, gi32, gi32, gi32) -&gt; gvec4i</code> Constructs a GPU 4-element <code>i32</code> vector with GPU <code>i32</code> values \u2705 <code>gvec4i{T}</code> <code>(T, T, T, T) -&gt; gvec4i</code> Converts the provided values into GPU <code>i32</code> values and then constructs a GPU 4-element <code>i32</code> vector \u2705 <code>gvec4i{T}</code> <code>T -&gt; gvec4i</code> Converts the provided value into a GPU <code>i32</code> value and the constructs a GPU 4-element <code>i32</code> vector with all values set to this value \u2705 <code>gvec4f</code> <code>() -&gt; gvec4f</code> Returns a default GPU 4-element <code>f32</code> vector \u2705 <code>gvec4f</code> <code>(gf32, gf32, gf32, gf32) -&gt; gvec4f</code> Constructs a GPU 4-element <code>f32</code> vector with GPU <code>f32</code> values \u2705 <code>gvec4f{T}</code> <code>(T, T, T, T) -&gt; gvec4f</code> Converts the provided values into GPU <code>f32</code> values and then constructs a GPU 4-element <code>f32</code> vector \u2705 <code>gvec4f{T}</code> <code>T -&gt; gvec4f</code> Converts the provided value into a GPU <code>f32</code> value and the constructs a GPU 4-element <code>f32</code> vector with all values set to this value \u2705 <code>gvec4b</code> <code>() -&gt; gvec4b</code> Returns a default GPU 4-element <code>bool</code> vector \u2705 <code>gvec4b</code> <code>(gbool, gbool, gbool, gbool) -&gt; gvec4b</code> Constructs a GPU 4-element <code>bool</code> vector with GPU <code>bool</code> values \u2705 <code>gvec4b{T}</code> <code>(T, T, T, T) -&gt; gvec4b</code> Converts the provided values into GPU <code>bool</code> values and then constructs a GPU 4-element <code>bool</code> vector \u2705 <code>gvec4b{T}</code> <code>T -&gt; gvec4b</code> Converts the provided value into a GPU <code>bool</code> value and the constructs a GPU 4-element <code>bool</code> vector with all values set to this value \u2705 <code>gFor</code> <code>(u32, u32, u32) -&gt; gvec3u</code> Constructs the special global invocation id. This special type can only be constructed CPU side and read GPU side. Used for compute shader parallelism \u2705 <code>gFor{T}</code> <code>(T, T, T) -&gt; gvec3u</code> Converts the <code>T</code> values to <code>u32</code> and constructs a global invocation id \u2705 <code>gFor{T}</code> <code>(T, T) -&gt; gvec3u</code> Converts the <code>T</code> values to <code>u32</code> and constructs a global invocation id. The <code>Z</code> value is set to <code>1</code> \u2705 <code>gFor{T}</code> <code>T -&gt; gvec3u</code> Converts the <code>T</code> value to <code>u32</code> and constructs a global invocation id. The <code>Y</code> and <code>Z</code> values are set to <code>1</code> \u2705"},{"location":"built_ins/#gpgpu-matrix-constructor-functions","title":"GPGPU Matrix Constructor functions","text":"Name Type Description Explicit <code>gmat2x2f</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gmat2x2f</code> Manually construct a GPU 2x2 matrix. You probably won't use this directly \u274c <code>gmat2x3f</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gmat2x2f</code> Manually construct a GPU 2x3 matrix. You probably won't use this directly \u274c <code>gmat2x4f</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gmat2x2f</code> Manually construct a GPU 2x4 matrix. You probably won't use this directly \u274c <code>gmat3x2f</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gmat3x2f</code> Manually construct a GPU 3x2 matrix. You probably won't use this directly \u274c <code>gmat3x3f</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gmat3x2f</code> Manually construct a GPU 3x3 matrix. You probably won't use this directly \u274c <code>gmat3x4f</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gmat3x2f</code> Manually construct a GPU 3x4 matrix. You probably won't use this directly \u274c <code>gmat4x2f</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gmat4x2f</code> Manually construct a GPU 4x2 matrix. You probably won't use this directly \u274c <code>gmat4x3f</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gmat4x2f</code> Manually construct a GPU 4x3 matrix. You probably won't use this directly \u274c <code>gmat4x4f</code> <code>(string, Dict{string, string}, Set{GBufferTagged}) -&gt; gmat4x2f</code> Manually construct a GPU 4x4 matrix. You probably won't use this directly \u274c <code>gmat2x2f</code> <code>() -&gt; gmat2x2f</code> Returns a default GPU 2x2 matrix \u2705 <code>gmat2x2f</code> <code>(gvec2f, gvec2f) -&gt; gmat2x2f</code> Returns a GPU 2x2 matrix assembled from two vector columns \u2705 <code>gmat2x2f{I}</code> <code>(I, I, I, I) -&gt; gmat2x2f</code> Converts the input values to <code>gf32</code> and stores them column by column \u2705 <code>gmat2x2f</code> <code>(gf32, gf32, gf32, gf32) -&gt; gmat2x2f</code> Returns a GPU 2x2 matrix assembled from <code>gf32</code> values in column order \u2705 <code>gmat2x3f</code> <code>() -&gt; gmat2x3f</code> Returns a default GPU 2x3 matrix \u2705 <code>gmat2x3f</code> <code>(gvec3f, gvec3f) -&gt; gmat2x3f</code> Returns a GPU 2x3 matrix assembled from two vector columns \u2705 <code>gmat2x3f{I}</code> <code>(I, I, I, I, I, I) -&gt; gmat2x3f</code> Converts the input values to <code>gf32</code> and stores them column by column \u2705 <code>gmat2x3f</code> <code>(gf32, gf32, gf32, gf32, gf32, gf32) -&gt; gmat2x3f</code> Returns a GPU 2x3 matrix assembled from <code>gf32</code> values in column order \u2705 <code>gmat2x4f</code> <code>() -&gt; gmat2x4f</code> Returns a default GPU 2x4 matrix \u2705 <code>gmat2x4f</code> <code>(gvec4f, gvec4f) -&gt; gmat2x4f</code> Returns a GPU 2x4 matrix assembled from two vector columns \u2705 <code>gmat2x4f{I}</code> <code>(I, I, I, I, I, I, I, I) -&gt; gmat2x4f</code> Converts the input values to <code>gf32</code> and stores them column by column \u2705 <code>gmat2x4f</code> <code>(gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32) -&gt; gmat2x4f</code> Returns a GPU 2x4 matrix assembled from <code>gf32</code> values in column order \u2705 <code>gmat3x2f</code> <code>() -&gt; gmat3x2f</code> Returns a default GPU 3x2 matrix \u2705 <code>gmat3x2f</code> <code>(gvec2f, gvec2f, gvec2f) -&gt; gmat3x2f</code> Returns a GPU 3x2 matrix assembled from three vector columns \u2705 <code>gmat3x2f{I}</code> <code>(I, I, I, I, I, I) -&gt; gmat3x2f</code> Converts the input values to <code>gf32</code> and stores them column by column \u2705 <code>gmat3x2f</code> <code>(gf32, gf32, gf32, gf32, gf32, gf32) -&gt; gmat3x2f</code> Returns a GPU 3x2 matrix assembled from <code>gf32</code> values in column order \u2705 <code>gmat3x3f</code> <code>() -&gt; gmat3x3f</code> Returns a default GPU 3x3 matrix \u2705 <code>gmat3x3f</code> <code>(gvec3f, gvec3f, gvec3f) -&gt; gmat3x3f</code> Returns a GPU 3x3 matrix assembled from three vector columns \u2705 <code>gmat3x3f{I}</code> <code>(I, I, I, I, I, I, I, I, I) -&gt; gmat3x3f</code> Converts the input values to <code>gf32</code> and stores them column by column \u2705 <code>gmat3x3f</code> <code>(gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32) -&gt; gmat3x3f</code> Returns a GPU 3x3 matrix assembled from <code>gf32</code> values in column order \u2705 <code>gmat3x4f</code> <code>() -&gt; gmat3x4f</code> Returns a default GPU 3x4 matrix \u2705 <code>gmat3x4f</code> <code>(gvec4f, gvec4f, gvec4f) -&gt; gmat3x4f</code> Returns a GPU 3x4 matrix assembled from three vector columns \u2705 <code>gmat3x4f{I}</code> <code>(I, I, I, I, I, I, I, I, I, I, I, I) -&gt; gmat3x4f</code> Converts the input values to <code>gf32</code> and stores them column by column \u2705 <code>gmat3x4f</code> <code>(gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32) -&gt; gmat3x4f</code> Returns a GPU 3x4 matrix assembled from <code>gf32</code> values in column order \u2705 <code>gmat4x2f</code> <code>() -&gt; gmat4x2f</code> Returns a default GPU 4x2 matrix \u2705 <code>gmat4x2f</code> <code>(gvec2f, gvec2f, gvec2f, gvec2f) -&gt; gmat4x2f</code> Returns a GPU 4x2 matrix assembled from four vector columns \u2705 <code>gmat4x2f{I}</code> <code>(I, I, I, I, I, I, I, I) -&gt; gmat4x2f</code> Converts the input values to <code>gf32</code> and stores them column by column \u2705 <code>gmat4x2f</code> <code>(gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32) -&gt; gmat4x2f</code> Returns a GPU 4x2 matrix assembled from <code>gf32</code> values in column order \u2705 <code>gmat4x3f</code> <code>() -&gt; gmat4x3f</code> Returns a default GPU 4x3 matrix \u2705 <code>gmat4x3f</code> <code>(gvec3f, gvec3f, gvec3f, gvec3f) -&gt; gmat4x3f</code> Returns a GPU 4x3 matrix assembled from four vector columns \u2705 <code>gmat4x3f{I}</code> <code>(I, I, I, I, I, I, I, I, I, I, I, I) -&gt; gmat4x3f</code> Converts the input values to <code>gf32</code> and stores them column by column \u2705 <code>gmat4x3f</code> <code>(gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32) -&gt; gmat4x3f</code> Returns a GPU 4x3 matrix assembled from <code>gf32</code> values in column order \u2705 <code>gmat4x4f</code> <code>() -&gt; gmat4x4f</code> Returns a default GPU 4x4 matrix \u2705 <code>gmat4x4f</code> <code>(gvec4f, gvec4f, gvec4f, gvec4f) -&gt; gmat4x4f</code> Returns a GPU 4x4 matrix assembled from four vector columns \u2705 <code>gmat4x4f{I}</code> <code>(I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I) -&gt; gmat4x4f</code> Converts the input values to <code>gf32</code> and stores them column by column \u2705 <code>gmat4x4f</code> <code>(gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32, gf32) -&gt; gmat4x4f</code> Returns a GPU 4x4 matrix assembled from <code>gf32</code> values in column order \u2705"},{"location":"built_ins/#gpgpu-accessor-functions","title":"GPGPU Accessor functions","text":"Name Type Description <code>x</code> <code>gvec2u -&gt; gu32</code> Accesses the first <code>u32</code> value from the 2-element vector <code>y</code> <code>gvec2u -&gt; gu32</code> Accesses the second <code>u32</code> value from the 2-element vector <code>i</code> <code>gvec2u -&gt; gu32</code> Accesses the first <code>u32</code> value from the 2-element vector <code>j</code> <code>gvec2u -&gt; gu32</code> Accesses the second <code>u32</code> value from the 2-element vector <code>r</code> <code>gvec2u -&gt; gu32</code> Accesses the first <code>u32</code> value from the 2-element vector <code>g</code> <code>gvec2u -&gt; gu32</code> Accesses the second <code>u32</code> value from the 2-element vector <code>gvec22u</code> <code>(gvec2u, string) -&gt; gvec2u</code> Manually construct a method intended to reorder the vector. You probably won't use this directly <code>xy</code> <code>gvec2u -&gt; gvec2u</code> Returns the original 2-element vector <code>yx</code> <code>gvec2u -&gt; gvec2u</code> Reverses the order of the 2-element vector <code>ij</code> <code>gvec2u -&gt; gvec2u</code> Returns the original 2-element vector <code>ji</code> <code>gvec2u -&gt; gvec2u</code> Reverses the order of the 2-element vector <code>rg</code> <code>gvec2u -&gt; gvec2u</code> Returns the original 2-element vector <code>gr</code> <code>gvec2u -&gt; gvec2u</code> Reverses the order of the 2-element vector <code>x</code> <code>gvec2i -&gt; gi32</code> Accesses the first <code>i32</code> value from the 2-element vector <code>y</code> <code>gvec2i -&gt; gi32</code> Accesses the second <code>i32</code> value from the 2-element vector <code>i</code> <code>gvec2i -&gt; gi32</code> Accesses the first <code>i32</code> value from the 2-element vector <code>j</code> <code>gvec2i -&gt; gi32</code> Accesses the second <code>i32</code> value from the 2-element vector <code>r</code> <code>gvec2i -&gt; gi32</code> Accesses the first <code>i32</code> value from the 2-element vector <code>g</code> <code>gvec2i -&gt; gi32</code> Accesses the second <code>i32</code> value from the 2-element vector <code>gvec22i</code> <code>(gvec2i, string) -&gt; gvec2i</code> Manually construct a method intended to reorder the vector. You probably won't use this directly <code>xy</code> <code>gvec2i -&gt; gvec2i</code> Returns the original 2-element vector <code>yx</code> <code>gvec2i -&gt; gvec2i</code> Reverses the order of the 2-element vector <code>ij</code> <code>gvec2i -&gt; gvec2i</code> Returns the original 2-element vector <code>ji</code> <code>gvec2i -&gt; gvec2i</code> Reverses the order of the 2-element vector <code>rg</code> <code>gvec2i -&gt; gvec2i</code> Returns the original 2-element vector <code>gr</code> <code>gvec2i -&gt; gvec2i</code> Reverses the order of the 2-element vector <code>x</code> <code>gvec2f -&gt; gf32</code> Accesses the first <code>f32</code> value from the 2-element vector <code>y</code> <code>gvec2f -&gt; gf32</code> Accesses the second <code>f32</code> value from the 2-element vector <code>i</code> <code>gvec2f -&gt; gf32</code> Accesses the first <code>f32</code> value from the 2-element vector <code>j</code> <code>gvec2f -&gt; gf32</code> Accesses the second <code>f32</code> value from the 2-element vector <code>r</code> <code>gvec2f -&gt; gf32</code> Accesses the first <code>f32</code> value from the 2-element vector <code>g</code> <code>gvec2f -&gt; gf32</code> Accesses the second <code>f32</code> value from the 2-element vector <code>gvec22f</code> <code>(gvec2f, string) -&gt; gvec2f</code> Manually construct a method intended to reorder the vector. You probably won't use this directly <code>xy</code> <code>gvec2f -&gt; gvec2f</code> Returns the original 2-element vector <code>yx</code> <code>gvec2f -&gt; gvec2f</code> Reverses the order of the 2-element vector <code>ij</code> <code>gvec2f -&gt; gvec2f</code> Returns the original 2-element vector <code>ji</code> <code>gvec2f -&gt; gvec2f</code> Reverses the order of the 2-element vector <code>rg</code> <code>gvec2f -&gt; gvec2f</code> Returns the original 2-element vector <code>gr</code> <code>gvec2f -&gt; gvec2f</code> Reverses the order of the 2-element vector <code>x</code> <code>gvec2b -&gt; gbool</code> Accesses the first <code>bool</code> value from the 2-element vector <code>y</code> <code>gvec2b -&gt; gbool</code> Accesses the second <code>bool</code> value from the 2-element vector <code>i</code> <code>gvec2b -&gt; gbool</code> Accesses the first <code>bool</code> value from the 2-element vector <code>j</code> <code>gvec2b -&gt; gbool</code> Accesses the second <code>bool</code> value from the 2-element vector <code>r</code> <code>gvec2b -&gt; gbool</code> Accesses the first <code>bool</code> value from the 2-element vector <code>g</code> <code>gvec2b -&gt; gbool</code> Accesses the second <code>bool</code> value from the 2-element vector <code>gvec22b</code> <code>(gvec2b, string) -&gt; gvec2b</code> Manually construct a method intended to reorder the vector. You probably won't use this directly <code>xy</code> <code>gvec2b -&gt; gvec2b</code> Returns the original 2-element vector <code>yx</code> <code>gvec2b -&gt; gvec2b</code> Reverses the order of the 2-element vector <code>ij</code> <code>gvec2b -&gt; gvec2b</code> Returns the original 2-element vector <code>ji</code> <code>gvec2b -&gt; gvec2b</code> Reverses the order of the 2-element vector <code>rg</code> <code>gvec2b -&gt; gvec2b</code> Returns the original 2-element vector <code>gr</code> <code>gvec2b -&gt; gvec2b</code> Reverses the order of the 2-element vector <code>x</code> <code>gvec3u -&gt; gu32</code> Accesses value 0 from the 3-element vector <code>y</code> <code>gvec3u -&gt; gu32</code> Accesses value 1 from the 3-element vector <code>z</code> <code>gvec3u -&gt; gu32</code> Accesses value 2 from the 3-element vector <code>i</code> <code>gvec3u -&gt; gu32</code> Accesses value 0 from the 3-element vector <code>j</code> <code>gvec3u -&gt; gu32</code> Accesses value 1 from the 3-element vector <code>k</code> <code>gvec3u -&gt; gu32</code> Accesses value 2 from the 3-element vector <code>r</code> <code>gvec3u -&gt; gu32</code> Accesses value 0 from the 3-element vector <code>g</code> <code>gvec3u -&gt; gu32</code> Accesses value 1 from the 3-element vector <code>b</code> <code>gvec3u -&gt; gu32</code> Accesses value 2 from the 3-element vector <code>gvec32u</code> <code>(gvec3u, string) -&gt; gvec2u</code> Manually constructs a method intended to extract a 2-element vector. You probably won't use this directly <code>xy</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[0, 1]</code> elements <code>yx</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[1, 0]</code> elements <code>xz</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[0, 2]</code> elements <code>zx</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[2, 0]</code> elements <code>yz</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[1, 2]</code> elements <code>zy</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[2, 1]</code> elements <code>ij</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[0, 1]</code> elements <code>ji</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[1, 0]</code> elements <code>ik</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[0, 2]</code> elements <code>ki</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[2, 0]</code> elements <code>jk</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[1, 2]</code> elements <code>kj</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[2, 1]</code> elements <code>rg</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[0, 1]</code> elements <code>gr</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[1, 0]</code> elements <code>rb</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[0, 2]</code> elements <code>br</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[2, 0]</code> elements <code>gb</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[1, 2]</code> elements <code>bg</code> <code>gvec3u -&gt; gvec2u</code> Returns a vector using the <code>[2, 1]</code> elements <code>gvec33u</code> <code>(gvec3u, string) -&gt; gvec2u</code> Manually construct a method intended to reorder the vector. You probably won't use this directly <code>xyz</code> <code>gvec3u -&gt; gvec3u</code> Returns the original 3-element vector <code>xzy</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[0, 2, 1]</code> ordering <code>yxz</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[1, 0, 2]</code> ordering <code>yzx</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[1, 2, 0]</code> ordering <code>zxy</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[2, 0, 1]</code> ordering <code>zyx</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[2, 1, 0]</code> ordering <code>ijk</code> <code>gvec3u -&gt; gvec3u</code> Returns the original 3-element vector <code>ikj</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[0, 2, 1]</code> ordering <code>jik</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[1, 0, 2]</code> ordering <code>jki</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[1, 2, 0]</code> ordering <code>kij</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[2, 0, 1]</code> ordering <code>kji</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[2, 1, 0]</code> ordering <code>rgb</code> <code>gvec3u -&gt; gvec3u</code> Returns the original 3-element vector <code>rbg</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[0, 2, 1]</code> ordering <code>grb</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[1, 0, 2]</code> ordering <code>gbr</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[1, 2, 0]</code> ordering <code>brg</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[2, 0, 1]</code> ordering <code>bgr</code> <code>gvec3u -&gt; gvec3u</code> Returns a vector using <code>[2, 1, 0]</code> ordering <code>x</code> <code>gvec3i -&gt; gi32</code> Accesses value 0 from the 3-element vector <code>y</code> <code>gvec3i -&gt; gi32</code> Accesses value 1 from the 3-element vector <code>z</code> <code>gvec3i -&gt; gi32</code> Accesses value 2 from the 3-element vector <code>i</code> <code>gvec3i -&gt; gi32</code> Accesses value 0 from the 3-element vector <code>j</code> <code>gvec3i -&gt; gi32</code> Accesses value 1 from the 3-element vector <code>k</code> <code>gvec3i -&gt; gi32</code> Accesses value 2 from the 3-element vector <code>r</code> <code>gvec3i -&gt; gi32</code> Accesses value 0 from the 3-element vector <code>g</code> <code>gvec3i -&gt; gi32</code> Accesses value 1 from the 3-element vector <code>b</code> <code>gvec3i -&gt; gi32</code> Accesses value 2 from the 3-element vector <code>gvec32i</code> <code>(gvec3i, string) -&gt; gvec2i</code> Manually constructs a method intended to extract a 2-element vector. You probably won't use this directly <code>xy</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[0, 1]</code> elements <code>yx</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[1, 0]</code> elements <code>xz</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[0, 2]</code> elements <code>zx</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[2, 0]</code> elements <code>yz</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[1, 2]</code> elements <code>zy</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[2, 1]</code> elements <code>ij</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[0, 1]</code> elements <code>ji</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[1, 0]</code> elements <code>ik</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[0, 2]</code> elements <code>ki</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[2, 0]</code> elements <code>jk</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[1, 2]</code> elements <code>kj</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[2, 1]</code> elements <code>rg</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[0, 1]</code> elements <code>gr</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[1, 0]</code> elements <code>rb</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[0, 2]</code> elements <code>br</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[2, 0]</code> elements <code>gb</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[1, 2]</code> elements <code>bg</code> <code>gvec3i -&gt; gvec2i</code> Returns a vector using the <code>[2, 1]</code> elements <code>gvec33i</code> <code>(gvec3i, string) -&gt; gvec2i</code> Manually construct a method intended to reorder the vector. You probably won't use this directly <code>xyz</code> <code>gvec3i -&gt; gvec3i</code> Returns the original 3-element vector <code>xzy</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[0, 2, 1]</code> ordering <code>yxz</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[1, 0, 2]</code> ordering <code>yzx</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[1, 2, 0]</code> ordering <code>zxy</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[2, 0, 1]</code> ordering <code>zyx</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[2, 1, 0]</code> ordering <code>ijk</code> <code>gvec3i -&gt; gvec3i</code> Returns the original 3-element vector <code>ikj</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[0, 2, 1]</code> ordering <code>jik</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[1, 0, 2]</code> ordering <code>jki</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[1, 2, 0]</code> ordering <code>kij</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[2, 0, 1]</code> ordering <code>kji</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[2, 1, 0]</code> ordering <code>rgb</code> <code>gvec3i -&gt; gvec3i</code> Returns the original 3-element vector <code>rbg</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[0, 2, 1]</code> ordering <code>grb</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[1, 0, 2]</code> ordering <code>gbr</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[1, 2, 0]</code> ordering <code>brg</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[2, 0, 1]</code> ordering <code>bgr</code> <code>gvec3i -&gt; gvec3i</code> Returns a vector using <code>[2, 1, 0]</code> ordering <code>x</code> <code>gvec3f -&gt; gf32</code> Accesses value 0 from the 3-element vector <code>y</code> <code>gvec3f -&gt; gf32</code> Accesses value 1 from the 3-element vector <code>z</code> <code>gvec3f -&gt; gf32</code> Accesses value 2 from the 3-element vector <code>i</code> <code>gvec3f -&gt; gf32</code> Accesses value 0 from the 3-element vector <code>j</code> <code>gvec3f -&gt; gf32</code> Accesses value 1 from the 3-element vector <code>k</code> <code>gvec3f -&gt; gf32</code> Accesses value 2 from the 3-element vector <code>r</code> <code>gvec3f -&gt; gf32</code> Accesses value 0 from the 3-element vector <code>g</code> <code>gvec3f -&gt; gf32</code> Accesses value 1 from the 3-element vector <code>b</code> <code>gvec3f -&gt; gf32</code> Accesses value 2 from the 3-element vector <code>gvec32f</code> <code>(gvec3f, string) -&gt; gvec2f</code> Manually constructs a method intended to extract a 2-element vector. You probably won't use this directly <code>xy</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[0, 1]</code> elements <code>yx</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[1, 0]</code> elements <code>xz</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[0, 2]</code> elements <code>zx</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[2, 0]</code> elements <code>yz</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[1, 2]</code> elements <code>zy</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[2, 1]</code> elements <code>ij</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[0, 1]</code> elements <code>ji</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[1, 0]</code> elements <code>ik</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[0, 2]</code> elements <code>ki</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[2, 0]</code> elements <code>jk</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[1, 2]</code> elements <code>kj</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[2, 1]</code> elements <code>rg</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[0, 1]</code> elements <code>gr</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[1, 0]</code> elements <code>rb</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[0, 2]</code> elements <code>br</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[2, 0]</code> elements <code>gb</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[1, 2]</code> elements <code>bg</code> <code>gvec3f -&gt; gvec2f</code> Returns a vector using the <code>[2, 1]</code> elements <code>gvec33f</code> <code>(gvec3f, string) -&gt; gvec2f</code> Manually construct a method intended to reorder the vector. You probably won't use this directly <code>xyz</code> <code>gvec3f -&gt; gvec3f</code> Returns the original 3-element vector <code>xzy</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[0, 2, 1]</code> ordering <code>yxz</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[1, 0, 2]</code> ordering <code>yzx</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[1, 2, 0]</code> ordering <code>zxy</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[2, 0, 1]</code> ordering <code>zyx</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[2, 1, 0]</code> ordering <code>ijk</code> <code>gvec3f -&gt; gvec3f</code> Returns the original 3-element vector <code>ikj</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[0, 2, 1]</code> ordering <code>jik</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[1, 0, 2]</code> ordering <code>jki</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[1, 2, 0]</code> ordering <code>kij</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[2, 0, 1]</code> ordering <code>kji</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[2, 1, 0]</code> ordering <code>rgb</code> <code>gvec3f -&gt; gvec3f</code> Returns the original 3-element vector <code>rbg</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[0, 2, 1]</code> ordering <code>grb</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[1, 0, 2]</code> ordering <code>gbr</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[1, 2, 0]</code> ordering <code>brg</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[2, 0, 1]</code> ordering <code>bgr</code> <code>gvec3f -&gt; gvec3f</code> Returns a vector using <code>[2, 1, 0]</code> ordering <code>x</code> <code>gvec3b -&gt; gbool</code> Accesses value 0 from the 3-element vector <code>y</code> <code>gvec3b -&gt; gbool</code> Accesses value 1 from the 3-element vector <code>z</code> <code>gvec3b -&gt; gbool</code> Accesses value 2 from the 3-element vector <code>i</code> <code>gvec3b -&gt; gbool</code> Accesses value 0 from the 3-element vector <code>j</code> <code>gvec3b -&gt; gbool</code> Accesses value 1 from the 3-element vector <code>k</code> <code>gvec3b -&gt; gbool</code> Accesses value 2 from the 3-element vector <code>r</code> <code>gvec3b -&gt; gbool</code> Accesses value 0 from the 3-element vector <code>g</code> <code>gvec3b -&gt; gbool</code> Accesses value 1 from the 3-element vector <code>b</code> <code>gvec3b -&gt; gbool</code> Accesses value 2 from the 3-element vector <code>gvec32b</code> <code>(gvec3b, string) -&gt; gvec2b</code> Manually constructs a method intended to extract a 2-element vector. You probably won't use this directly <code>xy</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[0, 1]</code> elements <code>yx</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[1, 0]</code> elements <code>xz</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[0, 2]</code> elements <code>zx</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[2, 0]</code> elements <code>yz</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[1, 2]</code> elements <code>zy</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[2, 1]</code> elements <code>ij</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[0, 1]</code> elements <code>ji</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[1, 0]</code> elements <code>ik</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[0, 2]</code> elements <code>ki</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[2, 0]</code> elements <code>jk</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[1, 2]</code> elements <code>kj</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[2, 1]</code> elements <code>rg</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[0, 1]</code> elements <code>gr</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[1, 0]</code> elements <code>rb</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[0, 2]</code> elements <code>br</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[2, 0]</code> elements <code>gb</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[1, 2]</code> elements <code>bg</code> <code>gvec3b -&gt; gvec2b</code> Returns a vector using the <code>[2, 1]</code> elements <code>gvec33b</code> <code>(gvec3b, string) -&gt; gvec2b</code> Manually construct a method intended to reorder the vector. You probably won't use this directly <code>xyz</code> <code>gvec3b -&gt; gvec3b</code> Returns the original 3-element vector <code>xzy</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[0, 2, 1]</code> ordering <code>yxz</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[1, 0, 2]</code> ordering <code>yzx</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[1, 2, 0]</code> ordering <code>zxy</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[2, 0, 1]</code> ordering <code>zyx</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[2, 1, 0]</code> ordering <code>ijk</code> <code>gvec3b -&gt; gvec3b</code> Returns the original 3-element vector <code>ikj</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[0, 2, 1]</code> ordering <code>jik</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[1, 0, 2]</code> ordering <code>jki</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[1, 2, 0]</code> ordering <code>kij</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[2, 0, 1]</code> ordering <code>kji</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[2, 1, 0]</code> ordering <code>rgb</code> <code>gvec3b -&gt; gvec3b</code> Returns the original 3-element vector <code>rbg</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[0, 2, 1]</code> ordering <code>grb</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[1, 0, 2]</code> ordering <code>gbr</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[1, 2, 0]</code> ordering <code>brg</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[2, 0, 1]</code> ordering <code>bgr</code> <code>gvec3b -&gt; gvec3b</code> Returns a vector using <code>[2, 1, 0]</code> ordering <code>x</code> <code>gvec4u -&gt; gu32</code> Accesses value 0 from the 4-element vector <code>y</code> <code>gvec4u -&gt; gu32</code> Accesses value 1 from the 4-element vector <code>z</code> <code>gvec4u -&gt; gu32</code> Accesses value 2 from the 4-element vector <code>w</code> <code>gvec4u -&gt; gu32</code> Accesses value 3 from the 4-element vector <code>i</code> <code>gvec4u -&gt; gu32</code> Accesses value 0 from the 4-element vector <code>j</code> <code>gvec4u -&gt; gu32</code> Accesses value 1 from the 4-element vector <code>k</code> <code>gvec4u -&gt; gu32</code> Accesses value 2 from the 4-element vector <code>l</code> <code>gvec4u -&gt; gu32</code> Accesses value 3 from the 4-element vector <code>r</code> <code>gvec4u -&gt; gu32</code> Accesses value 0 from the 4-element vector <code>g</code> <code>gvec4u -&gt; gu32</code> Accesses value 1 from the 4-element vector <code>b</code> <code>gvec4u -&gt; gu32</code> Accesses value 2 from the 4-element vector <code>a</code> <code>gvec4u -&gt; gu32</code> Accesses value 3 from the 4-element vector <code>gvec42u</code> <code>(gvec4u, string) -&gt; gvec2u</code> Manually constructs a method intended to extract a 2-element vector. You probably won't use this directly <code>xy</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[0, 1]</code> elements <code>yx</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[1, 0]</code> elements <code>xz</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[0, 2]</code> elements <code>zx</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[2, 0]</code> elements <code>xw</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[0, 3]</code> elements <code>wx</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[3, 0]</code> elements <code>yz</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[1, 2]</code> elements <code>zy</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[2, 1]</code> elements <code>yw</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[1, 3]</code> elements <code>wy</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[3, 1]</code> elements <code>zw</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[2, 3]</code> elements <code>wz</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[3, 2]</code> elements <code>ij</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[0, 1]</code> elements <code>ji</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[1, 0]</code> elements <code>ik</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[0, 2]</code> elements <code>ki</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[2, 0]</code> elements <code>il</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[0, 3]</code> elements <code>li</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[3, 0]</code> elements <code>jk</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[1, 2]</code> elements <code>kj</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[2, 1]</code> elements <code>jl</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[1, 3]</code> elements <code>lj</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[3, 1]</code> elements <code>kl</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[2, 3]</code> elements <code>lk</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[3, 2]</code> elements <code>rg</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[0, 1]</code> elements <code>gr</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[1, 0]</code> elements <code>rb</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[0, 2]</code> elements <code>br</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[2, 0]</code> elements <code>ra</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[0, 3]</code> elements <code>ar</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[3, 0]</code> elements <code>gb</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[1, 2]</code> elements <code>bg</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[2, 1]</code> elements <code>ga</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[1, 3]</code> elements <code>ag</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[3, 1]</code> elements <code>ba</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[2, 3]</code> elements <code>ab</code> <code>gvec4u -&gt; gvec2u</code> Returns a vector using the <code>[3, 2]</code> elements <code>gvec43u</code> <code>(gvec4u, string) -&gt; gvec3u</code> Manually constructs a method intended to extract a 3-element vector. You probably won't use this directly <code>xyz</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 1, 2]</code> elements <code>xyw</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 1, 3]</code> elements <code>xzy</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 2, 1]</code> elements <code>xzw</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 2, 3]</code> elements <code>xwy</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 3, 1]</code> elements <code>xwz</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 3, 2]</code> elements <code>yxz</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 0, 2]</code> elements <code>yxw</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 0, 3]</code> elements <code>yzx</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 2, 0]</code> elements <code>yzw</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 2, 3]</code> elements <code>ywx</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 3, 0]</code> elements <code>ywz</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 3, 2]</code> elements <code>zxy</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 0, 1]</code> elements <code>zxw</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 0, 3]</code> elements <code>zyx</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 1, 0]</code> elements <code>zyw</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 1, 3]</code> elements <code>zwx</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 3, 0]</code> elements <code>zwy</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 3, 1]</code> elements <code>wxy</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 0, 1]</code> elements <code>wxz</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 0, 2]</code> elements <code>wyx</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 1, 0]</code> elements <code>wyz</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 1, 2]</code> elements <code>wzx</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 2, 0]</code> elements <code>wzy</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 2, 1]</code> elements <code>ijk</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 1, 2]</code> elements <code>ijl</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 1, 3]</code> elements <code>ikj</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 2, 1]</code> elements <code>ikl</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 2, 3]</code> elements <code>ilj</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 3, 1]</code> elements <code>ilk</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 3, 2]</code> elements <code>jik</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 0, 2]</code> elements <code>jil</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 0, 3]</code> elements <code>jki</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 2, 0]</code> elements <code>jkl</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 2, 3]</code> elements <code>jli</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 3, 0]</code> elements <code>jlk</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 3, 2]</code> elements <code>kij</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 0, 1]</code> elements <code>kil</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 0, 3]</code> elements <code>kji</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 1, 0]</code> elements <code>kjl</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 1, 3]</code> elements <code>kli</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 3, 0]</code> elements <code>klj</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 3, 1]</code> elements <code>lij</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 0, 1]</code> elements <code>lik</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 0, 2]</code> elements <code>lji</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 1, 0]</code> elements <code>ljk</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 1, 2]</code> elements <code>lki</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 2, 0]</code> elements <code>lkj</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 2, 1]</code> elements <code>rgb</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 1, 2]</code> elements <code>rga</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 1, 3]</code> elements <code>rbg</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 2, 1]</code> elements <code>rba</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 2, 3]</code> elements <code>rag</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 3, 1]</code> elements <code>rab</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[0, 3, 2]</code> elements <code>grb</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 0, 2]</code> elements <code>gra</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 0, 3]</code> elements <code>gbr</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 2, 0]</code> elements <code>gba</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 2, 3]</code> elements <code>gar</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 3, 0]</code> elements <code>gab</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[1, 3, 2]</code> elements <code>brg</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 0, 1]</code> elements <code>bra</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 0, 3]</code> elements <code>bgr</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 1, 0]</code> elements <code>bgr</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 1, 3]</code> elements <code>bar</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 3, 0]</code> elements <code>bag</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[2, 3, 1]</code> elements <code>arg</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 0, 1]</code> elements <code>arb</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 0, 2]</code> elements <code>agr</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 1, 0]</code> elements <code>agb</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 1, 2]</code> elements <code>abr</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 2, 0]</code> elements <code>abg</code> <code>gvec4u -&gt; gvec3u</code> Returns a vector using the <code>[3, 2, 1]</code> elements <code>gvec44u</code> <code>(gvec4u, string) -&gt; gvec4u</code> Manually constructs a method intended to extract a 4-element vector. You probably won't use this directly <code>xyzw</code> <code>gvec4u -&gt; gvec4u</code> Returns the original 4-element vector <code>xywz</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 1, 3, 2]</code> ordering <code>xzyw</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 2, 1, 3]</code> ordering <code>xzwy</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 2, 3, 1]</code> ordering <code>xwyz</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 3, 1, 2]</code> ordering <code>xwzy</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 3, 2, 1]</code> ordering <code>yxzw</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 0, 2, 3]</code> ordering <code>yxwz</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 0, 3, 2]</code> ordering <code>yzxw</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 2, 0, 3]</code> ordering <code>yzwx</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 2, 3, 0]</code> ordering <code>ywxz</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 3, 0, 2]</code> ordering <code>ywzx</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 3, 2, 0]</code> ordering <code>zxyw</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 0, 1, 3]</code> ordering <code>zxwy</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 0, 3, 1]</code> ordering <code>zyxw</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 1, 0, 3]</code> ordering <code>zywx</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 1, 3, 0]</code> ordering <code>zwxy</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 3, 0, 1]</code> ordering <code>zwyx</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 3, 1, 0]</code> ordering <code>wxyz</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 0, 1, 2]</code> ordering <code>wxzy</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 0, 2, 1]</code> ordering <code>wyxz</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 1, 0, 2]</code> ordering <code>wyzx</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 1, 2, 0]</code> ordering <code>wzxy</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 2, 0, 1]</code> ordering <code>wzyx</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 2, 1, 0]</code> ordering <code>ijkl</code> <code>gvec4u -&gt; gvec4u</code> Returns the original 4-element vector <code>ijlk</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 1, 3, 2]</code> ordering <code>ikjl</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 2, 1, 3]</code> ordering <code>iklj</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 2, 3, 1]</code> ordering <code>iljk</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 3, 1, 2]</code> ordering <code>ilkj</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 3, 2, 1]</code> ordering <code>jikl</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 0, 2, 3]</code> ordering <code>jilk</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 0, 3, 2]</code> ordering <code>jkil</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 2, 0, 3]</code> ordering <code>jkli</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 2, 3, 0]</code> ordering <code>jlik</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 3, 0, 2]</code> ordering <code>jlki</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 3, 2, 0]</code> ordering <code>kijl</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 0, 1, 3]</code> ordering <code>kilj</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 0, 3, 1]</code> ordering <code>kjil</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 1, 0, 3]</code> ordering <code>kjli</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 1, 3, 0]</code> ordering <code>klij</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 3, 0, 1]</code> ordering <code>klji</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 3, 1, 0]</code> ordering <code>lijk</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 0, 1, 2]</code> ordering <code>likj</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 0, 2, 1]</code> ordering <code>ljik</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 1, 0, 2]</code> ordering <code>ljki</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 1, 2, 0]</code> ordering <code>lkij</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 2, 0, 1]</code> ordering <code>lkji</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 2, 1, 0]</code> ordering <code>rgba</code> <code>gvec4u -&gt; gvec4u</code> Returns the original 4-element vector <code>rgab</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 1, 3, 2]</code> ordering <code>rbga</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 2, 1, 3]</code> ordering <code>rbag</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 2, 3, 1]</code> ordering <code>ragb</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 3, 1, 2]</code> ordering <code>rabg</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[0, 3, 2, 1]</code> ordering <code>grba</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 0, 2, 3]</code> ordering <code>grab</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 0, 3, 2]</code> ordering <code>gbra</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 2, 0, 3]</code> ordering <code>gbar</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 2, 3, 0]</code> ordering <code>garb</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 3, 0, 2]</code> ordering <code>gabr</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[1, 3, 2, 0]</code> ordering <code>brga</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 0, 1, 3]</code> ordering <code>brag</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 0, 3, 1]</code> ordering <code>bgra</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 1, 0, 3]</code> ordering <code>bgar</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 1, 3, 0]</code> ordering <code>barg</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 3, 0, 1]</code> ordering <code>bagr</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[2, 3, 1, 0]</code> ordering <code>argb</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 0, 1, 2]</code> ordering <code>arbg</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 0, 2, 1]</code> ordering <code>agrb</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 1, 0, 2]</code> ordering <code>agbr</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 1, 2, 0]</code> ordering <code>abrg</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 2, 0, 1]</code> ordering <code>abgr</code> <code>gvec4u -&gt; gvec4u</code> Returns a vector using <code>[3, 2, 1, 0]</code> ordering <code>x</code> <code>gvec4i -&gt; gi32</code> Accesses value 0 from the 4-element vector <code>y</code> <code>gvec4i -&gt; gi32</code> Accesses value 1 from the 4-element vector <code>z</code> <code>gvec4i -&gt; gi32</code> Accesses value 2 from the 4-element vector <code>w</code> <code>gvec4i -&gt; gi32</code> Accesses value 3 from the 4-element vector <code>i</code> <code>gvec4i -&gt; gi32</code> Accesses value 0 from the 4-element vector <code>j</code> <code>gvec4i -&gt; gi32</code> Accesses value 1 from the 4-element vector <code>k</code> <code>gvec4i -&gt; gi32</code> Accesses value 2 from the 4-element vector <code>l</code> <code>gvec4i -&gt; gi32</code> Accesses value 3 from the 4-element vector <code>r</code> <code>gvec4i -&gt; gi32</code> Accesses value 0 from the 4-element vector <code>g</code> <code>gvec4i -&gt; gi32</code> Accesses value 1 from the 4-element vector <code>b</code> <code>gvec4i -&gt; gi32</code> Accesses value 2 from the 4-element vector <code>a</code> <code>gvec4i -&gt; gi32</code> Accesses value 3 from the 4-element vector <code>gvec42i</code> <code>(gvec4i, string) -&gt; gvec2i</code> Manually constructs a method intended to extract a 2-element vector. You probably won't use this directly <code>xy</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[0, 1]</code> elements <code>yx</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[1, 0]</code> elements <code>xz</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[0, 2]</code> elements <code>zx</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[2, 0]</code> elements <code>xw</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[0, 3]</code> elements <code>wx</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[3, 0]</code> elements <code>yz</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[1, 2]</code> elements <code>zy</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[2, 1]</code> elements <code>yw</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[1, 3]</code> elements <code>wy</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[3, 1]</code> elements <code>zw</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[2, 3]</code> elements <code>wz</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[3, 2]</code> elements <code>ij</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[0, 1]</code> elements <code>ji</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[1, 0]</code> elements <code>ik</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[0, 2]</code> elements <code>ki</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[2, 0]</code> elements <code>il</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[0, 3]</code> elements <code>li</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[3, 0]</code> elements <code>jk</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[1, 2]</code> elements <code>kj</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[2, 1]</code> elements <code>jl</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[1, 3]</code> elements <code>lj</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[3, 1]</code> elements <code>kl</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[2, 3]</code> elements <code>lk</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[3, 2]</code> elements <code>rg</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[0, 1]</code> elements <code>gr</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[1, 0]</code> elements <code>rb</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[0, 2]</code> elements <code>br</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[2, 0]</code> elements <code>ra</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[0, 3]</code> elements <code>ar</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[3, 0]</code> elements <code>gb</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[1, 2]</code> elements <code>bg</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[2, 1]</code> elements <code>ga</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[1, 3]</code> elements <code>ag</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[3, 1]</code> elements <code>ba</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[2, 3]</code> elements <code>ab</code> <code>gvec4i -&gt; gvec2i</code> Returns a vector using the <code>[3, 2]</code> elements <code>gvec43i</code> <code>(gvec4i, string) -&gt; gvec3i</code> Manually constructs a method intended to extract a 3-element vector. You probably won't use this directly <code>xyz</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 1, 2]</code> elements <code>xyw</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 1, 3]</code> elements <code>xzy</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 2, 1]</code> elements <code>xzw</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 2, 3]</code> elements <code>xwy</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 3, 1]</code> elements <code>xwz</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 3, 2]</code> elements <code>yxz</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 0, 2]</code> elements <code>yxw</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 0, 3]</code> elements <code>yzx</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 2, 0]</code> elements <code>yzw</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 2, 3]</code> elements <code>ywx</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 3, 0]</code> elements <code>ywz</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 3, 2]</code> elements <code>zxy</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 0, 1]</code> elements <code>zxw</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 0, 3]</code> elements <code>zyx</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 1, 0]</code> elements <code>zyw</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 1, 3]</code> elements <code>zwx</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 3, 0]</code> elements <code>zwy</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 3, 1]</code> elements <code>wxy</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 0, 1]</code> elements <code>wxz</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 0, 2]</code> elements <code>wyx</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 1, 0]</code> elements <code>wyz</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 1, 2]</code> elements <code>wzx</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 2, 0]</code> elements <code>wzy</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 2, 1]</code> elements <code>ijk</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 1, 2]</code> elements <code>ijl</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 1, 3]</code> elements <code>ikj</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 2, 1]</code> elements <code>ikl</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 2, 3]</code> elements <code>ilj</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 3, 1]</code> elements <code>ilk</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 3, 2]</code> elements <code>jik</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 0, 2]</code> elements <code>jil</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 0, 3]</code> elements <code>jki</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 2, 0]</code> elements <code>jkl</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 2, 3]</code> elements <code>jli</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 3, 0]</code> elements <code>jlk</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 3, 2]</code> elements <code>kij</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 0, 1]</code> elements <code>kil</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 0, 3]</code> elements <code>kji</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 1, 0]</code> elements <code>kjl</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 1, 3]</code> elements <code>kli</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 3, 0]</code> elements <code>klj</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 3, 1]</code> elements <code>lij</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 0, 1]</code> elements <code>lik</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 0, 2]</code> elements <code>lji</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 1, 0]</code> elements <code>ljk</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 1, 2]</code> elements <code>lki</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 2, 0]</code> elements <code>lkj</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 2, 1]</code> elements <code>rgb</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 1, 2]</code> elements <code>rga</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 1, 3]</code> elements <code>rbg</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 2, 1]</code> elements <code>rba</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 2, 3]</code> elements <code>rag</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 3, 1]</code> elements <code>rab</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[0, 3, 2]</code> elements <code>grb</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 0, 2]</code> elements <code>gra</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 0, 3]</code> elements <code>gbr</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 2, 0]</code> elements <code>gba</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 2, 3]</code> elements <code>gar</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 3, 0]</code> elements <code>gab</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[1, 3, 2]</code> elements <code>brg</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 0, 1]</code> elements <code>bra</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 0, 3]</code> elements <code>bgr</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 1, 0]</code> elements <code>bgr</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 1, 3]</code> elements <code>bar</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 3, 0]</code> elements <code>bag</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[2, 3, 1]</code> elements <code>arg</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 0, 1]</code> elements <code>arb</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 0, 2]</code> elements <code>agr</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 1, 0]</code> elements <code>agb</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 1, 2]</code> elements <code>abr</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 2, 0]</code> elements <code>abg</code> <code>gvec4i -&gt; gvec3i</code> Returns a vector using the <code>[3, 2, 1]</code> elements <code>gvec44i</code> <code>(gvec4i, string) -&gt; gvec4i</code> Manually constructs a method intended to extract a 4-element vector. You probably won't use this directly <code>xyzw</code> <code>gvec4i -&gt; gvec4i</code> Returns the original 4-element vector <code>xywz</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 1, 3, 2]</code> ordering <code>xzyw</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 2, 1, 3]</code> ordering <code>xzwy</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 2, 3, 1]</code> ordering <code>xwyz</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 3, 1, 2]</code> ordering <code>xwzy</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 3, 2, 1]</code> ordering <code>yxzw</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 0, 2, 3]</code> ordering <code>yxwz</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 0, 3, 2]</code> ordering <code>yzxw</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 2, 0, 3]</code> ordering <code>yzwx</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 2, 3, 0]</code> ordering <code>ywxz</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 3, 0, 2]</code> ordering <code>ywzx</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 3, 2, 0]</code> ordering <code>zxyw</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 0, 1, 3]</code> ordering <code>zxwy</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 0, 3, 1]</code> ordering <code>zyxw</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 1, 0, 3]</code> ordering <code>zywx</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 1, 3, 0]</code> ordering <code>zwxy</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 3, 0, 1]</code> ordering <code>zwyx</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 3, 1, 0]</code> ordering <code>wxyz</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 0, 1, 2]</code> ordering <code>wxzy</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 0, 2, 1]</code> ordering <code>wyxz</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 1, 0, 2]</code> ordering <code>wyzx</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 1, 2, 0]</code> ordering <code>wzxy</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 2, 0, 1]</code> ordering <code>wzyx</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 2, 1, 0]</code> ordering <code>ijkl</code> <code>gvec4i -&gt; gvec4i</code> Returns the original 4-element vector <code>ijlk</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 1, 3, 2]</code> ordering <code>ikjl</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 2, 1, 3]</code> ordering <code>iklj</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 2, 3, 1]</code> ordering <code>iljk</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 3, 1, 2]</code> ordering <code>ilkj</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 3, 2, 1]</code> ordering <code>jikl</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 0, 2, 3]</code> ordering <code>jilk</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 0, 3, 2]</code> ordering <code>jkil</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 2, 0, 3]</code> ordering <code>jkli</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 2, 3, 0]</code> ordering <code>jlik</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 3, 0, 2]</code> ordering <code>jlki</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 3, 2, 0]</code> ordering <code>kijl</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 0, 1, 3]</code> ordering <code>kilj</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 0, 3, 1]</code> ordering <code>kjil</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 1, 0, 3]</code> ordering <code>kjli</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 1, 3, 0]</code> ordering <code>klij</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 3, 0, 1]</code> ordering <code>klji</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 3, 1, 0]</code> ordering <code>lijk</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 0, 1, 2]</code> ordering <code>likj</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 0, 2, 1]</code> ordering <code>ljik</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 1, 0, 2]</code> ordering <code>ljki</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 1, 2, 0]</code> ordering <code>lkij</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 2, 0, 1]</code> ordering <code>lkji</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 2, 1, 0]</code> ordering <code>rgba</code> <code>gvec4i -&gt; gvec4i</code> Returns the original 4-element vector <code>rgab</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 1, 3, 2]</code> ordering <code>rbga</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 2, 1, 3]</code> ordering <code>rbag</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 2, 3, 1]</code> ordering <code>ragb</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 3, 1, 2]</code> ordering <code>rabg</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[0, 3, 2, 1]</code> ordering <code>grba</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 0, 2, 3]</code> ordering <code>grab</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 0, 3, 2]</code> ordering <code>gbra</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 2, 0, 3]</code> ordering <code>gbar</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 2, 3, 0]</code> ordering <code>garb</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 3, 0, 2]</code> ordering <code>gabr</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[1, 3, 2, 0]</code> ordering <code>brga</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 0, 1, 3]</code> ordering <code>brag</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 0, 3, 1]</code> ordering <code>bgra</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 1, 0, 3]</code> ordering <code>bgar</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 1, 3, 0]</code> ordering <code>barg</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 3, 0, 1]</code> ordering <code>bagr</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[2, 3, 1, 0]</code> ordering <code>argb</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 0, 1, 2]</code> ordering <code>arbg</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 0, 2, 1]</code> ordering <code>agrb</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 1, 0, 2]</code> ordering <code>agbr</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 1, 2, 0]</code> ordering <code>abrg</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 2, 0, 1]</code> ordering <code>abgr</code> <code>gvec4i -&gt; gvec4i</code> Returns a vector using <code>[3, 2, 1, 0]</code> ordering <code>x</code> <code>gvec4f -&gt; gf32</code> Accesses value 0 from the 4-element vector <code>y</code> <code>gvec4f -&gt; gf32</code> Accesses value 1 from the 4-element vector <code>z</code> <code>gvec4f -&gt; gf32</code> Accesses value 2 from the 4-element vector <code>w</code> <code>gvec4f -&gt; gf32</code> Accesses value 3 from the 4-element vector <code>i</code> <code>gvec4f -&gt; gf32</code> Accesses value 0 from the 4-element vector <code>j</code> <code>gvec4f -&gt; gf32</code> Accesses value 1 from the 4-element vector <code>k</code> <code>gvec4f -&gt; gf32</code> Accesses value 2 from the 4-element vector <code>l</code> <code>gvec4f -&gt; gf32</code> Accesses value 3 from the 4-element vector <code>r</code> <code>gvec4f -&gt; gf32</code> Accesses value 0 from the 4-element vector <code>g</code> <code>gvec4f -&gt; gf32</code> Accesses value 1 from the 4-element vector <code>b</code> <code>gvec4f -&gt; gf32</code> Accesses value 2 from the 4-element vector <code>a</code> <code>gvec4f -&gt; gf32</code> Accesses value 3 from the 4-element vector <code>gvec42f</code> <code>(gvec4f, string) -&gt; gvec2f</code> Manually constructs a method intended to extract a 2-element vector. You probably won't use this directly <code>xy</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[0, 1]</code> elements <code>yx</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[1, 0]</code> elements <code>xz</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[0, 2]</code> elements <code>zx</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[2, 0]</code> elements <code>xw</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[0, 3]</code> elements <code>wx</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[3, 0]</code> elements <code>yz</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[1, 2]</code> elements <code>zy</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[2, 1]</code> elements <code>yw</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[1, 3]</code> elements <code>wy</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[3, 1]</code> elements <code>zw</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[2, 3]</code> elements <code>wz</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[3, 2]</code> elements <code>ij</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[0, 1]</code> elements <code>ji</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[1, 0]</code> elements <code>ik</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[0, 2]</code> elements <code>ki</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[2, 0]</code> elements <code>il</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[0, 3]</code> elements <code>li</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[3, 0]</code> elements <code>jk</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[1, 2]</code> elements <code>kj</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[2, 1]</code> elements <code>jl</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[1, 3]</code> elements <code>lj</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[3, 1]</code> elements <code>kl</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[2, 3]</code> elements <code>lk</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[3, 2]</code> elements <code>rg</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[0, 1]</code> elements <code>gr</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[1, 0]</code> elements <code>rb</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[0, 2]</code> elements <code>br</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[2, 0]</code> elements <code>ra</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[0, 3]</code> elements <code>ar</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[3, 0]</code> elements <code>gb</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[1, 2]</code> elements <code>bg</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[2, 1]</code> elements <code>ga</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[1, 3]</code> elements <code>ag</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[3, 1]</code> elements <code>ba</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[2, 3]</code> elements <code>ab</code> <code>gvec4f -&gt; gvec2f</code> Returns a vector using the <code>[3, 2]</code> elements <code>gvec43f</code> <code>(gvec4f, string) -&gt; gvec3f</code> Manually constructs a method intended to extract a 3-element vector. You probably won't use this directly <code>xyz</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 1, 2]</code> elements <code>xyw</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 1, 3]</code> elements <code>xzy</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 2, 1]</code> elements <code>xzw</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 2, 3]</code> elements <code>xwy</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 3, 1]</code> elements <code>xwz</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 3, 2]</code> elements <code>yxz</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 0, 2]</code> elements <code>yxw</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 0, 3]</code> elements <code>yzx</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 2, 0]</code> elements <code>yzw</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 2, 3]</code> elements <code>ywx</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 3, 0]</code> elements <code>ywz</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 3, 2]</code> elements <code>zxy</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 0, 1]</code> elements <code>zxw</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 0, 3]</code> elements <code>zyx</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 1, 0]</code> elements <code>zyw</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 1, 3]</code> elements <code>zwx</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 3, 0]</code> elements <code>zwy</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 3, 1]</code> elements <code>wxy</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 0, 1]</code> elements <code>wxz</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 0, 2]</code> elements <code>wyx</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 1, 0]</code> elements <code>wyz</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 1, 2]</code> elements <code>wzx</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 2, 0]</code> elements <code>wzy</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 2, 1]</code> elements <code>ijk</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 1, 2]</code> elements <code>ijl</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 1, 3]</code> elements <code>ikj</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 2, 1]</code> elements <code>ikl</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 2, 3]</code> elements <code>ilj</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 3, 1]</code> elements <code>ilk</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 3, 2]</code> elements <code>jik</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 0, 2]</code> elements <code>jil</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 0, 3]</code> elements <code>jki</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 2, 0]</code> elements <code>jkl</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 2, 3]</code> elements <code>jli</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 3, 0]</code> elements <code>jlk</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 3, 2]</code> elements <code>kij</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 0, 1]</code> elements <code>kil</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 0, 3]</code> elements <code>kji</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 1, 0]</code> elements <code>kjl</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 1, 3]</code> elements <code>kli</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 3, 0]</code> elements <code>klj</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 3, 1]</code> elements <code>lij</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 0, 1]</code> elements <code>lik</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 0, 2]</code> elements <code>lji</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 1, 0]</code> elements <code>ljk</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 1, 2]</code> elements <code>lki</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 2, 0]</code> elements <code>lkj</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 2, 1]</code> elements <code>rgb</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 1, 2]</code> elements <code>rga</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 1, 3]</code> elements <code>rbg</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 2, 1]</code> elements <code>rba</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 2, 3]</code> elements <code>rag</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 3, 1]</code> elements <code>rab</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[0, 3, 2]</code> elements <code>grb</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 0, 2]</code> elements <code>gra</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 0, 3]</code> elements <code>gbr</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 2, 0]</code> elements <code>gba</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 2, 3]</code> elements <code>gar</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 3, 0]</code> elements <code>gab</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[1, 3, 2]</code> elements <code>brg</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 0, 1]</code> elements <code>bra</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 0, 3]</code> elements <code>bgr</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 1, 0]</code> elements <code>bgr</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 1, 3]</code> elements <code>bar</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 3, 0]</code> elements <code>bag</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[2, 3, 1]</code> elements <code>arg</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 0, 1]</code> elements <code>arb</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 0, 2]</code> elements <code>agr</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 1, 0]</code> elements <code>agb</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 1, 2]</code> elements <code>abr</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 2, 0]</code> elements <code>abg</code> <code>gvec4f -&gt; gvec3f</code> Returns a vector using the <code>[3, 2, 1]</code> elements <code>gvec44f</code> <code>(gvec4f, string) -&gt; gvec4f</code> Manually constructs a method intended to extract a 4-element vector. You probably won't use this directly <code>xyzw</code> <code>gvec4f -&gt; gvec4f</code> Returns the original 4-element vector <code>xywz</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 1, 3, 2]</code> ordering <code>xzyw</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 2, 1, 3]</code> ordering <code>xzwy</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 2, 3, 1]</code> ordering <code>xwyz</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 3, 1, 2]</code> ordering <code>xwzy</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 3, 2, 1]</code> ordering <code>yxzw</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 0, 2, 3]</code> ordering <code>yxwz</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 0, 3, 2]</code> ordering <code>yzxw</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 2, 0, 3]</code> ordering <code>yzwx</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 2, 3, 0]</code> ordering <code>ywxz</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 3, 0, 2]</code> ordering <code>ywzx</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 3, 2, 0]</code> ordering <code>zxyw</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 0, 1, 3]</code> ordering <code>zxwy</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 0, 3, 1]</code> ordering <code>zyxw</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 1, 0, 3]</code> ordering <code>zywx</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 1, 3, 0]</code> ordering <code>zwxy</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 3, 0, 1]</code> ordering <code>zwyx</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 3, 1, 0]</code> ordering <code>wxyz</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 0, 1, 2]</code> ordering <code>wxzy</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 0, 2, 1]</code> ordering <code>wyxz</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 1, 0, 2]</code> ordering <code>wyzx</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 1, 2, 0]</code> ordering <code>wzxy</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 2, 0, 1]</code> ordering <code>wzyx</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 2, 1, 0]</code> ordering <code>ijkl</code> <code>gvec4f -&gt; gvec4f</code> Returns the original 4-element vector <code>ijlk</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 1, 3, 2]</code> ordering <code>ikjl</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 2, 1, 3]</code> ordering <code>iklj</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 2, 3, 1]</code> ordering <code>iljk</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 3, 1, 2]</code> ordering <code>ilkj</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 3, 2, 1]</code> ordering <code>jikl</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 0, 2, 3]</code> ordering <code>jilk</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 0, 3, 2]</code> ordering <code>jkil</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 2, 0, 3]</code> ordering <code>jkli</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 2, 3, 0]</code> ordering <code>jlik</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 3, 0, 2]</code> ordering <code>jlki</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 3, 2, 0]</code> ordering <code>kijl</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 0, 1, 3]</code> ordering <code>kilj</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 0, 3, 1]</code> ordering <code>kjil</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 1, 0, 3]</code> ordering <code>kjli</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 1, 3, 0]</code> ordering <code>klij</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 3, 0, 1]</code> ordering <code>klji</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 3, 1, 0]</code> ordering <code>lijk</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 0, 1, 2]</code> ordering <code>likj</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 0, 2, 1]</code> ordering <code>ljik</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 1, 0, 2]</code> ordering <code>ljki</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 1, 2, 0]</code> ordering <code>lkij</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 2, 0, 1]</code> ordering <code>lkji</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 2, 1, 0]</code> ordering <code>rgba</code> <code>gvec4f -&gt; gvec4f</code> Returns the original 4-element vector <code>rgab</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 1, 3, 2]</code> ordering <code>rbga</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 2, 1, 3]</code> ordering <code>rbag</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 2, 3, 1]</code> ordering <code>ragb</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 3, 1, 2]</code> ordering <code>rabg</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[0, 3, 2, 1]</code> ordering <code>grba</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 0, 2, 3]</code> ordering <code>grab</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 0, 3, 2]</code> ordering <code>gbra</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 2, 0, 3]</code> ordering <code>gbar</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 2, 3, 0]</code> ordering <code>garb</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 3, 0, 2]</code> ordering <code>gabr</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[1, 3, 2, 0]</code> ordering <code>brga</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 0, 1, 3]</code> ordering <code>brag</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 0, 3, 1]</code> ordering <code>bgra</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 1, 0, 3]</code> ordering <code>bgar</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 1, 3, 0]</code> ordering <code>barg</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 3, 0, 1]</code> ordering <code>bagr</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[2, 3, 1, 0]</code> ordering <code>argb</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 0, 1, 2]</code> ordering <code>arbg</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 0, 2, 1]</code> ordering <code>agrb</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 1, 0, 2]</code> ordering <code>agbr</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 1, 2, 0]</code> ordering <code>abrg</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 2, 0, 1]</code> ordering <code>abgr</code> <code>gvec4f -&gt; gvec4f</code> Returns a vector using <code>[3, 2, 1, 0]</code> ordering <code>x</code> <code>gvec4b -&gt; gbool</code> Accesses value 0 from the 4-element vector <code>y</code> <code>gvec4b -&gt; gbool</code> Accesses value 1 from the 4-element vector <code>z</code> <code>gvec4b -&gt; gbool</code> Accesses value 2 from the 4-element vector <code>w</code> <code>gvec4b -&gt; gbool</code> Accesses value 3 from the 4-element vector <code>i</code> <code>gvec4b -&gt; gbool</code> Accesses value 0 from the 4-element vector <code>j</code> <code>gvec4b -&gt; gbool</code> Accesses value 1 from the 4-element vector <code>k</code> <code>gvec4b -&gt; gbool</code> Accesses value 2 from the 4-element vector <code>l</code> <code>gvec4b -&gt; gbool</code> Accesses value 3 from the 4-element vector <code>r</code> <code>gvec4b -&gt; gbool</code> Accesses value 0 from the 4-element vector <code>g</code> <code>gvec4b -&gt; gbool</code> Accesses value 1 from the 4-element vector <code>b</code> <code>gvec4b -&gt; gbool</code> Accesses value 2 from the 4-element vector <code>a</code> <code>gvec4b -&gt; gbool</code> Accesses value 3 from the 4-element vector <code>gvec42b</code> <code>(gvec4b, string) -&gt; gvec2b</code> Manually constructs a method intended to extract a 2-element vector. You probably won't use this directly <code>xy</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[0, 1]</code> elements <code>yx</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[1, 0]</code> elements <code>xz</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[0, 2]</code> elements <code>zx</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[2, 0]</code> elements <code>xw</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[0, 3]</code> elements <code>wx</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[3, 0]</code> elements <code>yz</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[1, 2]</code> elements <code>zy</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[2, 1]</code> elements <code>yw</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[1, 3]</code> elements <code>wy</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[3, 1]</code> elements <code>zw</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[2, 3]</code> elements <code>wz</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[3, 2]</code> elements <code>ij</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[0, 1]</code> elements <code>ji</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[1, 0]</code> elements <code>ik</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[0, 2]</code> elements <code>ki</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[2, 0]</code> elements <code>il</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[0, 3]</code> elements <code>li</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[3, 0]</code> elements <code>jk</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[1, 2]</code> elements <code>kj</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[2, 1]</code> elements <code>jl</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[1, 3]</code> elements <code>lj</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[3, 1]</code> elements <code>kl</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[2, 3]</code> elements <code>lk</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[3, 2]</code> elements <code>rg</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[0, 1]</code> elements <code>gr</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[1, 0]</code> elements <code>rb</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[0, 2]</code> elements <code>br</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[2, 0]</code> elements <code>ra</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[0, 3]</code> elements <code>ar</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[3, 0]</code> elements <code>gb</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[1, 2]</code> elements <code>bg</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[2, 1]</code> elements <code>ga</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[1, 3]</code> elements <code>ag</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[3, 1]</code> elements <code>ba</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[2, 3]</code> elements <code>ab</code> <code>gvec4b -&gt; gvec2b</code> Returns a vector using the <code>[3, 2]</code> elements <code>gvec43b</code> <code>(gvec4b, string) -&gt; gvec3b</code> Manually constructs a method intended to extract a 3-element vector. You probably won't use this directly <code>xyz</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 1, 2]</code> elements <code>xyw</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 1, 3]</code> elements <code>xzy</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 2, 1]</code> elements <code>xzw</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 2, 3]</code> elements <code>xwy</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 3, 1]</code> elements <code>xwz</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 3, 2]</code> elements <code>yxz</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 0, 2]</code> elements <code>yxw</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 0, 3]</code> elements <code>yzx</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 2, 0]</code> elements <code>yzw</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 2, 3]</code> elements <code>ywx</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 3, 0]</code> elements <code>ywz</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 3, 2]</code> elements <code>zxy</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 0, 1]</code> elements <code>zxw</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 0, 3]</code> elements <code>zyx</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 1, 0]</code> elements <code>zyw</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 1, 3]</code> elements <code>zwx</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 3, 0]</code> elements <code>zwy</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 3, 1]</code> elements <code>wxy</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 0, 1]</code> elements <code>wxz</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 0, 2]</code> elements <code>wyx</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 1, 0]</code> elements <code>wyz</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 1, 2]</code> elements <code>wzx</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 2, 0]</code> elements <code>wzy</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 2, 1]</code> elements <code>ijk</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 1, 2]</code> elements <code>ijl</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 1, 3]</code> elements <code>ikj</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 2, 1]</code> elements <code>ikl</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 2, 3]</code> elements <code>ilj</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 3, 1]</code> elements <code>ilk</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 3, 2]</code> elements <code>jik</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 0, 2]</code> elements <code>jil</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 0, 3]</code> elements <code>jki</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 2, 0]</code> elements <code>jkl</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 2, 3]</code> elements <code>jli</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 3, 0]</code> elements <code>jlk</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 3, 2]</code> elements <code>kij</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 0, 1]</code> elements <code>kil</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 0, 3]</code> elements <code>kji</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 1, 0]</code> elements <code>kjl</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 1, 3]</code> elements <code>kli</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 3, 0]</code> elements <code>klj</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 3, 1]</code> elements <code>lij</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 0, 1]</code> elements <code>lik</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 0, 2]</code> elements <code>lji</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 1, 0]</code> elements <code>ljk</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 1, 2]</code> elements <code>lki</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 2, 0]</code> elements <code>lkj</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 2, 1]</code> elements <code>rgb</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 1, 2]</code> elements <code>rga</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 1, 3]</code> elements <code>rbg</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 2, 1]</code> elements <code>rba</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 2, 3]</code> elements <code>rag</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 3, 1]</code> elements <code>rab</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[0, 3, 2]</code> elements <code>grb</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 0, 2]</code> elements <code>gra</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 0, 3]</code> elements <code>gbr</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 2, 0]</code> elements <code>gba</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 2, 3]</code> elements <code>gar</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 3, 0]</code> elements <code>gab</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[1, 3, 2]</code> elements <code>brg</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 0, 1]</code> elements <code>bra</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 0, 3]</code> elements <code>bgr</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 1, 0]</code> elements <code>bgr</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 1, 3]</code> elements <code>bar</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 3, 0]</code> elements <code>bag</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[2, 3, 1]</code> elements <code>arg</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 0, 1]</code> elements <code>arb</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 0, 2]</code> elements <code>agr</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 1, 0]</code> elements <code>agb</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 1, 2]</code> elements <code>abr</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 2, 0]</code> elements <code>abg</code> <code>gvec4b -&gt; gvec3b</code> Returns a vector using the <code>[3, 2, 1]</code> elements <code>gvec44b</code> <code>(gvec4b, string) -&gt; gvec4b</code> Manually constructs a method intended to extract a 4-element vector. You probably won't use this directly <code>xyzw</code> <code>gvec4b -&gt; gvec4b</code> Returns the original 4-element vector <code>xywz</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 1, 3, 2]</code> ordering <code>xzyw</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 2, 1, 3]</code> ordering <code>xzwy</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 2, 3, 1]</code> ordering <code>xwyz</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 3, 1, 2]</code> ordering <code>xwzy</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 3, 2, 1]</code> ordering <code>yxzw</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 0, 2, 3]</code> ordering <code>yxwz</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 0, 3, 2]</code> ordering <code>yzxw</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 2, 0, 3]</code> ordering <code>yzwx</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 2, 3, 0]</code> ordering <code>ywxz</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 3, 0, 2]</code> ordering <code>ywzx</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 3, 2, 0]</code> ordering <code>zxyw</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 0, 1, 3]</code> ordering <code>zxwy</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 0, 3, 1]</code> ordering <code>zyxw</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 1, 0, 3]</code> ordering <code>zywx</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 1, 3, 0]</code> ordering <code>zwxy</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 3, 0, 1]</code> ordering <code>zwyx</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 3, 1, 0]</code> ordering <code>wxyz</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 0, 1, 2]</code> ordering <code>wxzy</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 0, 2, 1]</code> ordering <code>wyxz</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 1, 0, 2]</code> ordering <code>wyzx</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 1, 2, 0]</code> ordering <code>wzxy</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 2, 0, 1]</code> ordering <code>wzyx</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 2, 1, 0]</code> ordering <code>ijkl</code> <code>gvec4b -&gt; gvec4b</code> Returns the original 4-element vector <code>ijlk</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 1, 3, 2]</code> ordering <code>ikjl</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 2, 1, 3]</code> ordering <code>iklj</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 2, 3, 1]</code> ordering <code>iljk</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 3, 1, 2]</code> ordering <code>ilkj</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 3, 2, 1]</code> ordering <code>jikl</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 0, 2, 3]</code> ordering <code>jilk</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 0, 3, 2]</code> ordering <code>jkil</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 2, 0, 3]</code> ordering <code>jkli</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 2, 3, 0]</code> ordering <code>jlik</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 3, 0, 2]</code> ordering <code>jlki</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 3, 2, 0]</code> ordering <code>kijl</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 0, 1, 3]</code> ordering <code>kilj</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 0, 3, 1]</code> ordering <code>kjil</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 1, 0, 3]</code> ordering <code>kjli</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 1, 3, 0]</code> ordering <code>klij</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 3, 0, 1]</code> ordering <code>klji</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 3, 1, 0]</code> ordering <code>lijk</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 0, 1, 2]</code> ordering <code>likj</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 0, 2, 1]</code> ordering <code>ljik</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 1, 0, 2]</code> ordering <code>ljki</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 1, 2, 0]</code> ordering <code>lkij</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 2, 0, 1]</code> ordering <code>lkji</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 2, 1, 0]</code> ordering <code>rgba</code> <code>gvec4b -&gt; gvec4b</code> Returns the original 4-element vector <code>rgab</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 1, 3, 2]</code> ordering <code>rbga</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 2, 1, 3]</code> ordering <code>rbag</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 2, 3, 1]</code> ordering <code>ragb</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 3, 1, 2]</code> ordering <code>rabg</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[0, 3, 2, 1]</code> ordering <code>grba</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 0, 2, 3]</code> ordering <code>grab</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 0, 3, 2]</code> ordering <code>gbra</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 2, 0, 3]</code> ordering <code>gbar</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 2, 3, 0]</code> ordering <code>garb</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 3, 0, 2]</code> ordering <code>gabr</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[1, 3, 2, 0]</code> ordering <code>brga</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 0, 1, 3]</code> ordering <code>brag</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 0, 3, 1]</code> ordering <code>bgra</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 1, 0, 3]</code> ordering <code>bgar</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 1, 3, 0]</code> ordering <code>barg</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 3, 0, 1]</code> ordering <code>bagr</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[2, 3, 1, 0]</code> ordering <code>argb</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 0, 1, 2]</code> ordering <code>arbg</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 0, 2, 1]</code> ordering <code>agrb</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 1, 0, 2]</code> ordering <code>agbr</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 1, 2, 0]</code> ordering <code>abrg</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 2, 0, 1]</code> ordering <code>abgr</code> <code>gvec4b -&gt; gvec4b</code> Returns a vector using <code>[3, 2, 1, 0]</code> ordering <code>get</code> <code>(GBuffer, gu32) -&gt; gi32</code> Returns a value from the GPU buffer as a <code>gi32</code> <code>get</code> <code>(GBuffer, gi32) -&gt; gi32</code> Returns a value from the GPU buffer as a <code>gi32</code> <code>get</code> <code>(GBuffer, i64) -&gt; gi32</code> Returns a value from the GPU buffer as a <code>gi32</code> <code>store</code> <code>(gi32, gi32) -&gt; gi32</code> Replaces the first value with the second value"},{"location":"built_ins/#gpgpu-math-functions","title":"GPGPU Math functions","text":"Name Type Description <code>gneg{I}</code> <code>I -&gt; I</code> Manually constructs a negation of the provided variable. You probably won't use this directly <code>neg</code> <code>gi32 -&gt; gi32</code> Negates the <code>gi32</code> <code>neg</code> <code>gf32 -&gt; gf32</code> Negates the <code>gf32</code> <code>neg</code> <code>gvec2i -&gt; gvec2i</code> Negates each element of the <code>gvec2i</code> <code>neg</code> <code>gvec2f -&gt; gvec2f</code> Negates each element of the <code>gvec2f</code> <code>neg</code> <code>gvec3i -&gt; gvec3i</code> Negates each element of the <code>gvec3i</code> <code>neg</code> <code>gvec3f -&gt; gvec3f</code> Negates each element of the <code>gvec3f</code> <code>neg</code> <code>gvec4i -&gt; gvec4i</code> Negates each element of the <code>gvec4i</code> <code>neg</code> <code>gvec4f -&gt; gvec4f</code> Negates each element of the <code>gvec4f</code> <code>gabs{I}</code> <code>I -&gt; I</code> Manually constructs an absolute value of the provided variable. You probably won't use this directly <code>abs</code> <code>gi32 -&gt; gi32</code> Computes the absolute value of the <code>gi32</code> <code>abs</code> <code>gf32 -&gt; gf32</code> Computes the absolute value of the <code>gf32</code> <code>abs</code> <code>gvec2i -&gt; gvec2i</code> Computes the absolute value of each element of the <code>gvec2i</code> <code>abs</code> <code>gvec2f -&gt; gvec2f</code> Computes the absolute value of each element of the <code>gvec2f</code> <code>abs</code> <code>gvec3i -&gt; gvec3i</code> Computes the absolute value of each element of the <code>gvec3i</code> <code>abs</code> <code>gvec3f -&gt; gvec3f</code> Computes the absolute value of each element of the <code>gvec3f</code> <code>abs</code> <code>gvec4i -&gt; gvec4i</code> Computes the absolute value of each element of the <code>gvec4i</code> <code>abs</code> <code>gvec4f -&gt; gvec4f</code> Computes the absolute value of each element of the <code>gvec4f</code> <code>gclz{I}</code> <code>I -&gt; I</code> Manually constructs a count-leading-zeroes call on the provided variable. You probably won't use this directly <code>clz</code> <code>gi32 -&gt; gi32</code> Computes the leading zeroes of the <code>gi32</code> <code>clz</code> <code>gu32 -&gt; gu32</code> Computes the leading zeroes of the <code>gu32</code> <code>clz</code> <code>gvec2i -&gt; gvec2i</code> Computes the leading zeroes of each element of the <code>gvec2i</code> <code>clz</code> <code>gvec2u -&gt; gvec2u</code> Computes the leading zeroes of each element of the <code>gvec2u</code> <code>clz</code> <code>gvec3i -&gt; gvec3i</code> Computes the leading zeroes of each element of the <code>gvec3i</code> <code>clz</code> <code>gvec3u -&gt; gvec3u</code> Computes the leading zeroes of each element of the <code>gvec3u</code> <code>clz</code> <code>gvec4i -&gt; gvec4i</code> Computes the leading zeroes of each element of the <code>gvec4i</code> <code>clz</code> <code>gvec4u -&gt; gvec4u</code> Computes the leading zeroes of each element of the <code>gvec4u</code> <code>gones{I}</code> <code>I -&gt; I</code> Manually constructs a count-one-bits call on the provided variable. You probably won't use this directly <code>ones</code> <code>gi32 -&gt; gi32</code> Computes the count of one bits of the <code>gi32</code> <code>ones</code> <code>gu32 -&gt; gu32</code> Computes the count of one bits of the <code>gu32</code> <code>ones</code> <code>gvec2i -&gt; gvec2i</code> Computes the count of one bits of each element of the <code>gvec2i</code> <code>ones</code> <code>gvec2u -&gt; gvec2u</code> Computes the count of one bits of each element of the <code>gvec2u</code> <code>ones</code> <code>gvec3i -&gt; gvec3i</code> Computes the count of one bits of each element of the <code>gvec3i</code> <code>ones</code> <code>gvec3u -&gt; gvec3u</code> Computes the count of one bits of each element of the <code>gvec3u</code> <code>ones</code> <code>gvec4i -&gt; gvec4i</code> Computes the count of one bits of each element of the <code>gvec4i</code> <code>ones</code> <code>gvec4u -&gt; gvec4u</code> Computes the count of one bits of each element of the <code>gvec4u</code> <code>gctz{I}</code> <code>I -&gt; I</code> Manually constructs a count-trailing-zeroes call on the provided variable. You probably won't use this directly <code>ctz</code> <code>gi32 -&gt; gi32</code> Computes the trailing zeroes of the <code>gi32</code> <code>ctz</code> <code>gu32 -&gt; gu32</code> Computes the trailing zeroes of the <code>gu32</code> <code>ctz</code> <code>gvec2i -&gt; gvec2i</code> Computes the trailing zeroes of each element of the <code>gvec2i</code> <code>ctz</code> <code>gvec2u -&gt; gvec2u</code> Computes the trailing zeroes of each element of the <code>gvec2u</code> <code>ctz</code> <code>gvec3i -&gt; gvec3i</code> Computes the trailing zeroes of each element of the <code>gvec3i</code> <code>ctz</code> <code>gvec3u -&gt; gvec3u</code> Computes the trailing zeroes of each element of the <code>gvec3u</code> <code>ctz</code> <code>gvec4i -&gt; gvec4i</code> Computes the trailing zeroes of each element of the <code>gvec4i</code> <code>ctz</code> <code>gvec4u -&gt; gvec4u</code> Computes the trailing zeroes of each element of the <code>gvec4u</code> <code>gReverseBits{I}</code> <code>I -&gt; I</code> Manually constructs a reverse-bits call on the provided variable. You probably won't use this directly <code>reverseBits</code> <code>gi32 -&gt; gi32</code> Reverses the bits of the <code>gi32</code> <code>reverseBits</code> <code>gu32 -&gt; gu32</code> Reverses the bits of the <code>gu32</code> <code>reverseBits</code> <code>gvec2i -&gt; gvec2i</code> Reverses the bits of each element of the <code>gvec2i</code> <code>reverseBits</code> <code>gvec2u -&gt; gvec2u</code> Reverses the bits of each element of the <code>gvec2u</code> <code>reverseBits</code> <code>gvec3i -&gt; gvec3i</code> Reverses the bits of each element of the <code>gvec3i</code> <code>reverseBits</code> <code>gvec3u -&gt; gvec3u</code> Reverses the bits of each element of the <code>gvec3u</code> <code>reverseBits</code> <code>gvec4i -&gt; gvec4i</code> Reverses the bits of each element of the <code>gvec4i</code> <code>reverseBits</code> <code>gvec4u -&gt; gvec4u</code> Reverses the bits of each element of the <code>gvec4u</code> <code>gExtractBits{I}</code> <code>(I, gu32, gu32) -&gt; I</code> Manually constructs an extract-bits call on the provided variable. You probably won't use this directly <code>extractBits{A, B}</code> <code>(gu32, A, B) -&gt; gu32</code> Extracts the bits from the <code>gu32</code> <code>extractBits{A, B}</code> <code>(gvec2u, A, B) -&gt; gvec2u</code> Extracts the bits from each element of the <code>gvec2u</code> <code>extractBits{A, B}</code> <code>(gvec3u, A, B) -&gt; gvec3u</code> Extracts the bits from each element of the <code>gvec3u</code> <code>extractBits{A, B}</code> <code>(gvec4u, A, B) -&gt; gvec4u</code> Extracts the bits from each element of the <code>gvec4u</code> <code>gInsertBits{I}</code> <code>(I, I,</code>gu32<code>, gu32</code>) -&gt; I` Manually constructs an insert-bits call on the provided variable. You probably won't use this directly <code>insertBits{A, B, C}</code> <code>(gu32, A, B, C) -&gt; gu32</code> Inserts <code>C</code> number of bits in <code>A</code> at offset <code>B</code> into the <code>gu32</code> <code>insertBits{A, B, C}</code> <code>(gi32, A, B, C) -&gt; gi32</code> Inserts <code>C</code> number of bits in <code>A</code> at offset <code>B</code> into the <code>gi32</code> <code>insertBits{A, B, C}</code> <code>(gvec2u, A, B, C) -&gt; gvec2u</code> Inserts <code>C</code> number of bits in <code>A</code> at offset <code>B</code> into the <code>gvec2u</code> <code>insertBits{A, B, C}</code> <code>(gvec2i, A, B, C) -&gt; gvec2i</code> Inserts <code>C</code> number of bits in <code>A</code> at offset <code>B</code> into the <code>gvec2i</code> <code>insertBits{A, B, C}</code> <code>(gvec3u, A, B, C) -&gt; gvec3u</code> Inserts <code>C</code> number of bits in <code>A</code> at offset <code>B</code> into the <code>gvec3u</code> <code>insertBits{A, B, C}</code> <code>(gvec3i, A, B, C) -&gt; gvec3i</code> Inserts <code>C</code> number of bits in <code>A</code> at offset <code>B</code> into the <code>gvec3i</code> <code>insertBits{A, B, C}</code> <code>(gvec4u, A, B, C) -&gt; gvec4u</code> Inserts <code>C</code> number of bits in <code>A</code> at offset <code>B</code> into the <code>gvec4u</code> <code>insertBits{A, B, C}</code> <code>(gvec4i, A, B, C) -&gt; gvec4i</code> Inserts <code>C</code> number of bits in <code>A</code> at offset <code>B</code> into the <code>gvec4i</code> <code>cross</code> <code>(gvec3f, gvec3f) -&gt; gvec3f</code> Computes the cross product of two 3-element floating point vectors <code>gTranspose{I, O}</code> <code>I -&gt; O</code> Manually constructs a matrix transpose call on the provided variable. You probably won't use this directly <code>transpose</code> <code>gmat2x2f -&gt; gmat2x2f</code> Transposes a 2x2 matrix into a 2x2 matrix <code>transpose</code> <code>gmat2x3f -&gt; gmat3x2f</code> Transposes a 2x3 matrix into a 3x2 matrix <code>transpose</code> <code>gmat2x4f -&gt; gmat4x2f</code> Transposes a 2x4 matrix into a 4x2 matrix <code>transpose</code> <code>gmat3x2f -&gt; gmat2x3f</code> Transposes a 3x2 matrix into a 2x3 matrix <code>transpose</code> <code>gmat3x3f -&gt; gmat3x3f</code> Transposes a 3x3 matrix into a 3x3 matrix <code>transpose</code> <code>gmat3x4f -&gt; gmat4x3f</code> Transposes a 3x4 matrix into a 4x3 matrix <code>transpose</code> <code>gmat4x2f -&gt; gmat2x4f</code> Transposes a 4x2 matrix into a 2x4 matrix <code>transpose</code> <code>gmat4x3f -&gt; gmat3x4f</code> Transposes a 4x3 matrix into a 3x4 matrix <code>transpose</code> <code>gmat4x4f -&gt; gmat4x4f</code> Transposes a 4x4 matrix into a 4x4 matrix <code>gdot{I, O}</code> <code>(I, I) -&gt; O</code> Manually constructs a vector dot product on the provided variables. You probably won't use this directly <code>dot</code> <code>(gvec2f, gvec2f) -&gt; gf32</code> Computes the dot product of two 2-element <code>f32</code> vectors <code>dot</code> <code>(gvec3f, gvec3f) -&gt; gf32</code> Computes the dot product of two 3-element <code>f32</code> vectors <code>dot</code> <code>(gvec4f, gvec4f) -&gt; gf32</code> Computes the dot product of two 4-element <code>f32</code> vectors <code>dot</code> <code>(gvec2u, gvec2u) -&gt; gu32</code> Computes the dot product of two 2-element <code>u32</code> vectors <code>dot</code> <code>(gvec3u, gvec3u) -&gt; gu32</code> Computes the dot product of two 3-element <code>u32</code> vectors <code>dot</code> <code>(gvec4u, gvec4u) -&gt; gu32</code> Computes the dot product of two 4-element <code>u32</code> vectors <code>dot</code> <code>(gvec2i, gvec2i) -&gt; gi32</code> Computes the dot product of two 2-element <code>i32</code> vectors <code>dot</code> <code>(gvec3i, gvec3i) -&gt; gi32</code> Computes the dot product of two 3-element <code>i32</code> vectors <code>dot</code> <code>(gvec4i, gvec4i) -&gt; gi32</code> Computes the dot product of two 4-element <code>i32</code> vectors <code>gMagnitude{I}</code> <code>I -&gt; gf32</code> Manually constructs a magnitude call on the provided variable. You probably won't use this directly <code>magnitude</code> <code>gf32 -&gt; gf32</code> Computes the magnitude of an <code>f32</code> (essentially the same as an absolute value call) <code>magnitude</code> <code>gvec2f -&gt; gf32</code> Computes the magnitude of a 2-element vector <code>magnitude</code> <code>gvec3f -&gt; gf32</code> Computes the magnitude of a 3-element vector <code>magnitude</code> <code>gvec4f -&gt; gf32</code> Computes the magnitude of a 4-element vector <code>gInverseSqrt{I}</code> <code>I -&gt; I</code> Manually constructs an inverse square root call on the provided variable. You probably won't use this directly <code>inverseSqrt</code> <code>gf32 -&gt; gf32</code> Computes the inverse square root of an <code>f32</code> <code>inverseSqrt</code> <code>gvec2f -&gt; gvec2f</code> Computes the inverse square root on each element of a 2-element vector <code>inverseSqrt</code> <code>gvec3f -&gt; gvec3f</code> Computes the inverse square root on each element of a 3-element vector <code>inverseSqrt</code> <code>gvec4f -&gt; gvec4f</code> Computes the inverse square root on each element of a 4-element vector <code>gNormalize{I}</code> <code>I -&gt; I</code> Manually constructs a normalize call on the provided variable. You probably won't use this directly <code>normalize</code> <code>gvec2f -&gt; gvec2f</code> Normalizes the 2-element vector <code>normalize</code> <code>gvec3f -&gt; gvec3f</code> Normalizes the 3-element vector <code>normalize</code> <code>gvec4f -&gt; gvec4f</code> Normalizes the 4-element vector <code>gRound{I}</code> <code>I -&gt; I</code> Manually constructs a round call on the provided variable. You probably won't use this directly <code>round</code> <code>gf32 -&gt; gf32</code> Rounds the <code>f32</code> (ties break even) <code>round</code> <code>gvec2f -&gt; gvec2f</code> Rounds each element of a 2-element vector <code>round</code> <code>gvec3f -&gt; gvec3f</code> Rounds each element of a 3-element vector <code>round</code> <code>gvec4f -&gt; gvec4f</code> Rounds each element of a 4-element vector <code>gFma{I}</code> <code>(I, I, I) -&gt; I</code> Manually constructs a fused multiply add call on the provided variable. You probably won't use this directly <code>fma</code> <code>(gf32, gf32, gf32) -&gt; gf32</code> Computes a fused multiply add on the provided <code>f32</code> values <code>fma</code> <code>(gvec2f, gvec2f, gvec2f) -&gt; gvec2f</code> Computes a fused multiply add piecewise on the provided 2-element vectors <code>fma</code> <code>(gvec3f, gvec3f, gvec3f) -&gt; gvec3f</code> Computes a fused multiply add piecewise on the provided 3-element vectors <code>fma</code> <code>(gvec4f, gvec4f, gvec4f) -&gt; gvec4f</code> Computes a fused multiply add piecewise on the provided 4-element vectors <code>gFract{I}</code> <code>I -&gt; I</code> Manually constructs a fractional call on the provided values. You probably won't use this directly <code>fract</code> <code>gf32 -&gt; gf32</code> Returns the fractional portion of the <code>f32</code> value <code>fract</code> <code>gvec2f -&gt; gvec2f</code> Returns the fractional portion of the 2-element vector piecewise <code>fract</code> <code>gvec3f -&gt; gvec3f</code> Returns the fractional portion of the 3-element vector piecewise <code>fract</code> <code>gvec4f -&gt; gvec4f</code> Returns the fractional portion of the 4-element vector piecewise <code>gDeterminant{I}</code> <code>I -&gt; gf32</code> Manually constructs a determinant call on the provided values. You probably won't use this directly <code>determinant</code> <code>gmat2x2f -&gt; gf32</code> Returns the determinant of a 2x2 matrix <code>determinant</code> <code>gmat3x3f -&gt; gf32</code> Returns the determinant of a 3x3 matrix <code>determinant</code> <code>gmat4x4f -&gt; gf32</code> Returns the determinant of a 4x4 matrix <code>gadd{A, B}</code> <code>(A, B) -&gt; A</code> Manually constructs an addition operation on the provided values. You probably won't use this directly <code>add</code> <code>(gu32, gu32) -&gt; gu32</code> Returns the addition of two <code>gu32</code> values <code>add{T}</code> <code>(gu32, T) -&gt; gu32</code> Casts the second value to <code>gu32</code> and adds it to the first <code>add{T}</code> <code>(T, gu32) -&gt; gu32</code> Casts the first value to <code>gu32</code> and adds it to the first <code>add</code> <code>(gi32, gi32) -&gt; gi32</code> Returns the addition of two <code>gi32</code> values <code>add{T}</code> <code>(gi32, T) -&gt; gi32</code> Casts the second value to <code>gi32</code> and adds it to the first <code>add{T}</code> <code>(T, gi32) -&gt; gi32</code> Casts the first value to <code>gi32</code> and adds it to the first <code>add</code> <code>(gf32, gf32) -&gt; gf32</code> Returns the addition of two <code>gf32</code> values <code>add{T}</code> <code>(gf32, T) -&gt; gf32</code> Casts the second value to <code>gf32</code> and adds it to the first <code>add{T}</code> <code>(T, gf32) -&gt; gf32</code> Casts the first value to <code>gf32</code> and adds it to the first <code>add</code> <code>(gvec2u, gvec2u) -&gt; gvec2u</code> Piecewise adds the two vectors together <code>add</code> <code>(gvec2u, gu32) -&gt; gvec2u</code> Adds the <code>gu32</code> to each element of the vector <code>add</code> <code>(gu32, gvec2u) -&gt; gvec2u</code> Adds the <code>gu32</code> to each element of the vector <code>add</code> <code>(gvec2i, gvec2i) -&gt; gvec2i</code> Piecewise adds the two vectors together <code>add</code> <code>(gvec2i, gi32) -&gt; gvec2i</code> Adds the <code>gi32</code> to each element of the vector <code>add</code> <code>(gi32, gvec2i) -&gt; gvec2i</code> Adds the <code>gi32</code> to each element of the vector <code>add</code> <code>(gvec2f, gvec2f) -&gt; gvec2f</code> Piecewise adds the two vectors together <code>add</code> <code>(gvec2f, gf32) -&gt; gvec2f</code> Adds the <code>gf32</code> to each element of the vector <code>add</code> <code>(gf32, gvec2f) -&gt; gvec2f</code> Adds the <code>gf32</code> to each element of the vector <code>add</code> <code>(gvec3u, gvec3u) -&gt; gvec3u</code> Piecewise adds the two vectors together <code>add</code> <code>(gvec3u, gu32) -&gt; gvec3u</code> Adds the <code>gu32</code> to each element of the vector <code>add</code> <code>(gu32, gvec3u) -&gt; gvec3u</code> Adds the <code>gu32</code> to each element of the vector <code>add</code> <code>(gvec3i, gvec3i) -&gt; gvec3i</code> Piecewise adds the two vectors together <code>add</code> <code>(gvec3i, gi32) -&gt; gvec3i</code> Adds the <code>gi32</code> to each element of the vector <code>add</code> <code>(gi32, gvec3i) -&gt; gvec3i</code> Adds the <code>gi32</code> to each element of the vector <code>add</code> <code>(gvec3f, gvec3f) -&gt; gvec3f</code> Piecewise adds the two vectors together <code>add</code> <code>(gvec3f, gf32) -&gt; gvec3f</code> Adds the <code>gf32</code> to each element of the vector <code>add</code> <code>(gf32, gvec3f) -&gt; gvec3f</code> Adds the <code>gf32</code> to each element of the vector <code>add</code> <code>(gvec4u, gvec4u) -&gt; gvec4u</code> Piecewise adds the two vectors together <code>add</code> <code>(gvec4u, gu32) -&gt; gvec4u</code> Adds the <code>gu32</code> to each element of the vector <code>add</code> <code>(gu32, gvec4u) -&gt; gvec4u</code> Adds the <code>gu32</code> to each element of the vector <code>add</code> <code>(gvec4i, gvec4i) -&gt; gvec4i</code> Piecewise adds the two vectors together <code>add</code> <code>(gvec4i, gi32) -&gt; gvec4i</code> Adds the <code>gi32</code> to each element of the vector <code>add</code> <code>(gi32, gvec4i) -&gt; gvec4i</code> Adds the <code>gi32</code> to each element of the vector <code>add</code> <code>(gvec4f, gvec4f) -&gt; gvec4f</code> Piecewise adds the two vectors together <code>add</code> <code>(gvec4f, gf32) -&gt; gvec4f</code> Adds the <code>gf32</code> to each element of the vector <code>add</code> <code>(gf32, gvec4f) -&gt; gvec4f</code> Adds the <code>gf32</code> to each element of the vector <code>add</code> <code>(gmat2x2f, gmat2x2f) -&gt; gmat2x2f</code> Piecewise adds the two matrices together <code>add</code> <code>(gmat2x3f, gmat2x3f) -&gt; gmat2x3f</code> Piecewise adds the two matrices together <code>add</code> <code>(gmat2x4f, gmat2x4f) -&gt; gmat2x4f</code> Piecewise adds the two matrices together <code>add</code> <code>(gmat3x2f, gmat3x2f) -&gt; gmat3x2f</code> Piecewise adds the two matrices together <code>add</code> <code>(gmat3x3f, gmat3x3f) -&gt; gmat3x3f</code> Piecewise adds the two matrices together <code>add</code> <code>(gmat3x4f, gmat3x4f) -&gt; gmat3x4f</code> Piecewise adds the two matrices together <code>add</code> <code>(gmat4x2f, gmat4x2f) -&gt; gmat4x2f</code> Piecewise adds the two matrices together <code>add</code> <code>(gmat4x3f, gmat4x3f) -&gt; gmat4x3f</code> Piecewise adds the two matrices together <code>add</code> <code>(gmat4x4f, gmat4x4f) -&gt; gmat4x4f</code> Piecewise adds the two matrices together <code>gSub{A, B}</code> <code>(A, B) -&gt; A</code> Manually constructs a subtraction operation on the provided values, producing the first type as output. You probably won't use this directly <code>gSubRev{A, B}</code> <code>(A, B) -&gt; B</code> Manually constructs a subtraction operation on the provided values, producing the second type as output. You probably won't use this directly <code>sub</code> <code>(gu32, gu32) -&gt; gu32</code> Subtracts the <code>gu32</code> from each other <code>sub{T}</code> <code>(gu32, T) -&gt; gu32</code> Casts the second value to <code>gu32</code> and subtracts it from the first <code>sub{T}</code> <code>(T, gu32) -&gt; gu32</code> Casts the first value to <code>gu32</code> and subtracts the second from it <code>sub</code> <code>(gi32, gi32) -&gt; gi32</code> Subtracts the <code>gi32</code> from each other <code>sub{T}</code> <code>(gi32, T) -&gt; gi32</code> Casts the second value to <code>gi32</code> and subtracts it from the first <code>sub{T}</code> <code>(T, gi32) -&gt; gi32</code> Casts the first value to <code>gi32</code> and subtracts the second from it <code>sub</code> <code>(gf32, gf32) -&gt; gf32</code> Subtracts the <code>gf32</code> from each other <code>sub{T}</code> <code>(gf32, T) -&gt; gf32</code> Casts the second value to <code>gf32</code> and subtracts it from the first <code>sub{T}</code> <code>(T, gf32) -&gt; gf32</code> Casts the first value to <code>gf32</code> and subtracts the second from it <code>sub</code> <code>(gvec2u, gvec2u) -&gt; gvec2u</code> Piecewise subtracts the elements of the two vectors <code>sub</code> <code>(gvec2u, gu32) -&gt; gvec2u</code> Subtracts the <code>gu32</code> from each element of the vector <code>sub</code> <code>(gu32, gvec2u) -&gt; gvec2u</code> Subtracts each element of the vector from the <code>gu32</code> <code>sub</code> <code>(gvec2i, gvec2i) -&gt; gvec2i</code> Piecewise subtracts the elements of the two vectors <code>sub</code> <code>(gvec2i, gi32) -&gt; gvec2i</code> Subtracts the <code>gi32</code> from each element of the vector <code>sub</code> <code>(gi32, gvec2i) -&gt; gvec2i</code> Subtracts each element of the vector from the <code>gi32</code> <code>sub</code> <code>(gvec2f, gvec2f) -&gt; gvec2f</code> Piecewise subtracts the elements of the two vectors <code>sub</code> <code>(gvec2f, gf32) -&gt; gvec2f</code> Subtracts the <code>gf32</code> from each element of the vector <code>sub</code> <code>(gf32, gvec2f) -&gt; gvec2f</code> Subtracts each element of the vector from the <code>gf32</code> <code>sub</code> <code>(gvec3u, gvec3u) -&gt; gvec3u</code> Piecewise subtracts the elements of the two vectors <code>sub</code> <code>(gvec3u, gu32) -&gt; gvec3u</code> Subtracts the <code>gu32</code> from each element of the vector <code>sub</code> <code>(gu32, gvec3u) -&gt; gvec3u</code> Subtracts each element of the vector from the <code>gu32</code> <code>sub</code> <code>(gvec3i, gvec3i) -&gt; gvec3i</code> Piecewise subtracts the elements of the two vectors <code>sub</code> <code>(gvec3i, gi32) -&gt; gvec3i</code> Subtracts the <code>gi32</code> from each element of the vector <code>sub</code> <code>(gi32, gvec3i) -&gt; gvec3i</code> Subtracts each element of the vector from the <code>gi32</code> <code>sub</code> <code>(gvec3f, gvec3f) -&gt; gvec3f</code> Piecewise subtracts the elements of the two vectors <code>sub</code> <code>(gvec3f, gf32) -&gt; gvec3f</code> Subtracts the <code>gf32</code> from each element of the vector <code>sub</code> <code>(gf32, gvec3f) -&gt; gvec3f</code> Subtracts each element of the vector from the <code>gf32</code> <code>sub</code> <code>(gvec4u, gvec4u) -&gt; gvec4u</code> Piecewise subtracts the elements of the two vectors <code>sub</code> <code>(gvec4u, gu32) -&gt; gvec4u</code> Subtracts the <code>gu32</code> from each element of the vector <code>sub</code> <code>(gu32, gvec4u) -&gt; gvec4u</code> Subtracts each element of the vector from the <code>gu32</code> <code>sub</code> <code>(gvec4i, gvec4i) -&gt; gvec4i</code> Piecewise subtracts the elements of the two vectors <code>sub</code> <code>(gvec4i, gi32) -&gt; gvec4i</code> Subtracts the <code>gi32</code> from each element of the vector <code>sub</code> <code>(gi32, gvec4i) -&gt; gvec4i</code> Subtracts each element of the vector from the <code>gi32</code> <code>sub</code> <code>(gvec4f, gvec4f) -&gt; gvec4f</code> Piecewise subtracts the elements of the two vectors <code>sub</code> <code>(gvec4f, gf32) -&gt; gvec4f</code> Subtracts the <code>gf32</code> from each element of the vector <code>sub</code> <code>(gf32, gvec4f) -&gt; gvec4f</code> Subtracts each element of the vector from the <code>gf32</code> <code>sub</code> <code>(gmat2x2f, gmat2x2f) -&gt; gmat2x2f</code> Piecewise subtracts the two matrices together <code>sub</code> <code>(gmat2x3f, gmat2x3f) -&gt; gmat2x3f</code> Piecewise subtracts the two matrices together <code>sub</code> <code>(gmat2x4f, gmat2x4f) -&gt; gmat2x4f</code> Piecewise subtracts the two matrices together <code>sub</code> <code>(gmat3x2f, gmat3x2f) -&gt; gmat3x2f</code> Piecewise subtracts the two matrices together <code>sub</code> <code>(gmat3x3f, gmat3x3f) -&gt; gmat3x3f</code> Piecewise subtracts the two matrices together <code>sub</code> <code>(gmat3x4f, gmat3x4f) -&gt; gmat3x4f</code> Piecewise subtracts the two matrices together <code>sub</code> <code>(gmat4x2f, gmat4x2f) -&gt; gmat4x2f</code> Piecewise subtracts the two matrices together <code>sub</code> <code>(gmat4x3f, gmat4x3f) -&gt; gmat4x3f</code> Piecewise subtracts the two matrices together <code>sub</code> <code>(gmat4x4f, gmat4x4f) -&gt; gmat4x4f</code> Piecewise subtracts the two matrices together <code>gmul{A, B, C}</code> <code>(A, B) -&gt; C</code> Manually constructs a multiplication operation on the provided values. You probably won't use this directly <code>gmul{A, B}</code> <code>(A, B) -&gt; A</code> Manually constructs a multiplication operation on the provided values, producing the first type as output. You probably won't use this directly <code>mul</code> <code>(gu32, gu32) -&gt; gu32</code> Multiplies the <code>gu32</code> values together <code>mul{T}</code> <code>(gu32, T) -&gt; gu32</code> Casts the second value to <code>gu32</code> and multiplies it to the first <code>mul{T}</code> <code>(T, gu32) -&gt; gu32</code> Casts the first value to <code>gu32</code> and multiplies it to the second <code>mul</code> <code>(gi32, gi32) -&gt; gi32</code> Multiplies the <code>gi32</code> values together <code>mul{T}</code> <code>(gi32, T) -&gt; gi32</code> Casts the second value to <code>gi32</code> and multiplies it to the first <code>mul{T}</code> <code>(T, gi32) -&gt; gi32</code> Casts the first value to <code>gi32</code> and multiplies it to the second <code>mul</code> <code>(gf32, gf32) -&gt; gf32</code> Multiplies the <code>gf32</code> values together <code>mul{T}</code> <code>(gf32, T) -&gt; gf32</code> Casts the second value to <code>gf32</code> and multiplies it to the first <code>mul{T}</code> <code>(T, gf32) -&gt; gf32</code> Casts the first value to <code>gf32</code> and multiplies it to the second <code>mul</code> <code>(gvec2u, gvec2u) -&gt; gvec2u</code> Piecewise multiplies the two vectors together <code>mul</code> <code>(gvec2u, gu32) -&gt; gvec2u</code> Multiplies the <code>gu32</code> to each element of the vector <code>mul</code> <code>(gu32, gvec2u) -&gt; gvec2u</code> Multiplies the <code>gu32</code> to each element of the vector <code>mul</code> <code>(gvec2i, gvec2i) -&gt; gvec2i</code> Piecewise multiplies the two vectors together <code>mul</code> <code>(gvec2i, gi32) -&gt; gvec2i</code> Multiplies the <code>gi32</code> to each element of the vector <code>mul</code> <code>(gi32, gvec2i) -&gt; gvec2i</code> Multiplies the <code>gi32</code> to each element of the vector <code>mul</code> <code>(gvec2f, gvec2f) -&gt; gvec2f</code> Piecewise multiplies the two vectors together <code>mul</code> <code>(gvec2f, gf32) -&gt; gvec2f</code> Multiplies the <code>gf32</code> to each element of the vector <code>mul</code> <code>(gf32, gvec2f) -&gt; gvec2f</code> Multiplies the <code>gf32</code> to each element of the vector <code>mul</code> <code>(gvec3u, gvec3u) -&gt; gvec3u</code> Piecewise multiplies the two vectors together <code>mul</code> <code>(gvec3u, gu32) -&gt; gvec3u</code> Multiplies the <code>gu32</code> to each element of the vector <code>mul</code> <code>(gu32, gvec3u) -&gt; gvec3u</code> Multiplies the <code>gu32</code> to each element of the vector <code>mul</code> <code>(gvec3i, gvec3i) -&gt; gvec3i</code> Piecewise multiplies the two vectors together <code>mul</code> <code>(gvec3i, gi32) -&gt; gvec3i</code> Multiplies the <code>gi32</code> to each element of the vector <code>mul</code> <code>(gi32, gvec3i) -&gt; gvec3i</code> Multiplies the <code>gi32</code> to each element of the vector <code>mul</code> <code>(gvec3f, gvec3f) -&gt; gvec3f</code> Piecewise multiplies the two vectors together <code>mul</code> <code>(gvec3f, gf32) -&gt; gvec3f</code> Multiplies the <code>gf32</code> to each element of the vector <code>mul</code> <code>(gf32, gvec3f) -&gt; gvec3f</code> Multiplies the <code>gf32</code> to each element of the vector <code>mul</code> <code>(gvec4u, gvec4u) -&gt; gvec4u</code> Piecewise multiplies the two vectors together <code>mul</code> <code>(gvec4u, gu32) -&gt; gvec4u</code> Multiplies the <code>gu32</code> to each element of the vector <code>mul</code> <code>(gu32, gvec4u) -&gt; gvec4u</code> Multiplies the <code>gu32</code> to each element of the vector <code>mul</code> <code>(gvec4i, gvec4i) -&gt; gvec4i</code> Piecewise multiplies the two vectors together <code>mul</code> <code>(gvec4i, gi32) -&gt; gvec4i</code> Multiplies the <code>gi32</code> to each element of the vector <code>mul</code> <code>(gi32, gvec4i) -&gt; gvec4i</code> Multiplies the <code>gi32</code> to each element of the vector <code>mul</code> <code>(gvec4f, gvec4f) -&gt; gvec4f</code> Piecewise multiplies the two vectors together <code>mul</code> <code>(gvec4f, gf32) -&gt; gvec4f</code> Multiplies the <code>gf32</code> to each element of the vector <code>mul</code> <code>(gf32, gvec4f) -&gt; gvec4f</code> Multiplies the <code>gf32</code> to each element of the vector <code>mul</code> <code>(gmat2x2f, gf32) -&gt; gmat2x2f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gf32, gmat2x2f) -&gt; gmat2x2f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gmat2x2f, gvec2f) -&gt; gvec2f</code> Multiplies the 2x2 matrix with the 2-element vector (acting as a 1x2 matrix) to produce a 2-element vector (acting as a 1x2 matrix) <code>mul</code> <code>(gvec2f, gmat2x2f) -&gt; gvec2f</code> Multiplies the 2-element vector (acting as a 2x1 matrix) with a 2x2 matrix to produce a 2-element vector (acting as a 2x1 matrix) <code>mul</code> <code>(gmat2x2f, gmat2x2f) -&gt; gmat2x2f</code> Multiplies the two 2x2 matrices together <code>mul</code> <code>(gmat2x2f, gmat3x2f) -&gt; gmat3x2f</code> Multiplies the 2x2 matrix to a 3x2 matrix producing a 3x2 matrix <code>mul</code> <code>(gmat2x2f, gmat4x2f) -&gt; gmat4x2f</code> Multiplies the 2x2 matrix to a 4x2 matrix producing a 4x2 matrix <code>mul</code> <code>(gmat2x3f, gf32) -&gt; gmat2x3f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gf32, gmat2x3f) -&gt; gmat2x3f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gmat2x3f, gvec2f) -&gt; gvec3f</code> Multiplies the 2x3 matrix with the 2-element vector (acting as a 1x2 matrix) to produce a 3-element vector (acting as a 1x3 matrix) <code>mul</code> <code>(gvec3f, gmat2x3f) -&gt; gvec2f</code> Multiplies the 3-element vector (acting as a 3x1 matrix) with a 2x3 matrix to produce a 2-element vector (acting as a 2x1 matrix) <code>mul</code> <code>(gmat2x3f, gmat2x2f) -&gt; gmat2x3f</code> Multiplies the 2x3 matrix to a 2x2 matrix producing a 2x3 matrix <code>mul</code> <code>(gmat2x3f, gmat3x2f) -&gt; gmat3x3f</code> Multiplies the 2x3 matrix to a 3x2 matrix producing a 3x3 matrix <code>mul</code> <code>(gmat2x3f, gmat4x2f) -&gt; gmat4x3f</code> Multiplies the 2x3 matrix to a 4x2 matrix producing a 4x3 matrix <code>mul</code> <code>(gmat2x4f, gf32) -&gt; gmat2x4f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gf32, gmat2x4f) -&gt; gmat2x4f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gmat2x4f, gvec2f) -&gt; gvec4f</code> Multiplies the 2x4 matrix with the 2-element vector (acting as a 1x2 matrix) to produce a 4-element vector (acting as a 1x4 matrix) <code>mul</code> <code>(gvec4f, gmat2x4f) -&gt; gvec2f</code> Multiplies the 4-element vector (acting as a 4x1 matrix) with a 2x4 matrix to produce a 2-element vector (acting as a 2x1 matrix) <code>mul</code> <code>(gmat2x4f, gmat2x2f) -&gt; gmat2x4f</code> Multiplies the 2x4 matrix to a 2x2 matrix producing a 2x4 matrix <code>mul</code> <code>(gmat2x4f, gmat3x2f) -&gt; gmat3x4f</code> Multiplies the 2x4 matrix to a 3x2 matrix producing a 3x4 matrix <code>mul</code> <code>(gmat2x4f, gmat4x2f) -&gt; gmat4x4f</code> Multiplies the 2x4 matrix to a 4x2 matrix producing a 4x4 matrix <code>mul</code> <code>(gmat3x2f, gf32) -&gt; gmat3x2f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gf32, gmat3x2f) -&gt; gmat3x2f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gmat3x2f, gvec3f) -&gt; gvec2f</code> Multiplies the 3x2 matrix with the 3-element vector (acting as a 1x3 matrix) to produce a 2-element vector (acting as a 1x2 matrix) <code>mul</code> <code>(gvec2f, gmat3x2f) -&gt; gvec3f</code> Multiplies the 2-element vector (acting as a 2x1 matrix) with a 3x2 matrix to produce a 3-element vector (acting as a 3x1 matrix) <code>mul</code> <code>(gmat3x2f, gmat2x3f) -&gt; gmat2x2f</code> Multiplies the 3x2 matrix to a 2x3 matrix producing a 2x2 matrix <code>mul</code> <code>(gmat3x2f, gmat3x3f) -&gt; gmat3x2f</code> Multiplies the 3x2 matrix to a 3x3 matrix producing a 3x2 matrix <code>mul</code> <code>(gmat3x2f, gmat4x3f) -&gt; gmat4x2f</code> Multiplies the 3x2 matrix to a 4x3 matrix producing a 4x2 matrix <code>mul</code> <code>(gmat3x3f, gf32) -&gt; gmat3x3f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gf32, gmat3x3f) -&gt; gmat3x3f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gmat3x3f, gvec3f) -&gt; gvec2f</code> Multiplies the 3x3 matrix with the 3-element vector (acting as a 1x3 matrix) to produce a 3-element vector (acting as a 1x3 matrix) <code>mul</code> <code>(gvec3f, gmat3x3f) -&gt; gvec3f</code> Multiplies the 3-element vector (acting as a 3x1 matrix) with a 3x3 matrix to produce a 3-element vector (acting as a 3x1 matrix) <code>mul</code> <code>(gmat3x3f, gmat2x3f) -&gt; gmat2x3f</code> Multiplies the 3x3 matrix to a 2x3 matrix producing a 2x3 matrix <code>mul</code> <code>(gmat3x3f, gmat3x3f) -&gt; gmat3x3f</code> Multiplies the 3x3 matrices together <code>mul</code> <code>(gmat3x3f, gmat4x3f) -&gt; gmat4x3f</code> Multiplies the 3x3 matrix to a 4x3 matrix producing a 4x3 matrix <code>mul</code> <code>(gmat3x4f, gf32) -&gt; gmat3x4f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gf32, gmat3x4f) -&gt; gmat3x4f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gmat3x4f, gvec3f) -&gt; gvec4f</code> Multiplies the 3x4 matrix with the 3-element vector (acting as a 1x3 matrix) to produce a 4-element vector (acting as a 1x4 matrix) <code>mul</code> <code>(gvec4f, gmat3x4f) -&gt; gvec3f</code> Multiplies the 4-element vector (acting as a 4x1 matrix) with a 3x4 matrix to produce a 3-element vector (acting as a 3x1 matrix) <code>mul</code> <code>(gmat3x4f, gmat2x3f) -&gt; gmat2x4f</code> Multiplies the 3x4 matrix to a 2x3 matrix producing a 2x4 matrix <code>mul</code> <code>(gmat3x4f, gmat3x3f) -&gt; gmat3x4f</code> Multiplies the 3x4 matrix to a 3x3 matrix producing a 3x4 matrix <code>mul</code> <code>(gmat3x4f, gmat4x3f) -&gt; gmat4x4f</code> Multiplies the 3x4 matrix to a 4x3 matrix producing a 4x4 matrix <code>mul</code> <code>(gmat4x2f, gf32) -&gt; gmat4x2f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gf32, gmat4x2f) -&gt; gmat4x2f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gmat4x2f, gvec4f) -&gt; gvec2f</code> Multiplies the 4x2 matrix with the 4-element vector (acting as a 1x4 matrix) to produce a 2-element vector (acting as a 1x2 matrix) <code>mul</code> <code>(gvec2f, gmat4x2f) -&gt; gvec4f</code> Multiplies the 2-element vector (acting as a 2x1 matrix) with a 4x2 matrix to produce a 4-element vector (acting as a 4x1 matrix) <code>mul</code> <code>(gmat4x2f, gmat2x4f) -&gt; gmat2x2f</code> Multiplies the 4x2 matrix to a 2x4 matrix producing a 2x2 matrix <code>mul</code> <code>(gmat4x2f, gmat3x4f) -&gt; gmat3x2f</code> Multiplies the 4x2 matrix to a 3x4 matrix producing a 3x2 matrix <code>mul</code> <code>(gmat4x2f, gmat4x4f) -&gt; gmat4x2f</code> Multiplies the 4x2 matrix to a 4x4 matrix producing a 4x2 matrix <code>mul</code> <code>(gmat4x3f, gf32) -&gt; gmat4x3f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gf32, gmat4x3f) -&gt; gmat4x3f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gmat4x3f, gvec4f) -&gt; gvec3f</code> Multiplies the 4x3 matrix with the 4-element vector (acting as a 1x4 matrix) to produce a 3-element vector (acting as a 1x3 matrix) <code>mul</code> <code>(gvec3f, gmat4x3f) -&gt; gvec4f</code> Multiplies the 3-element vector (acting as a 3x1 matrix) with a 4x3 matrix to produce a 4-element vector (acting as a 4x1 matrix) <code>mul</code> <code>(gmat4x3f, gmat2x4f) -&gt; gmat2x3f</code> Multiplies the 4x3 matrix to a 2x4 matrix producing a 2x3 matrix <code>mul</code> <code>(gmat4x3f, gmat3x4f) -&gt; gmat3x3f</code> Multiplies the 4x3 matrix to a 3x4 matrix producing a 3x3 matrix <code>mul</code> <code>(gmat4x3f, gmat4x4f) -&gt; gmat4x3f</code> Multiplies the 4x3 matrix to a 4x4 matrix producing a 4x3 matrix <code>mul</code> <code>(gmat4x4f, gf32) -&gt; gmat4x4f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gf32, gmat4x4f) -&gt; gmat4x4f</code> Piecewise multiplies the matrix with the <code>gf32</code> value <code>mul</code> <code>(gmat4x4f, gvec4f) -&gt; gvec4f</code> Multiplies the 4x4 matrix with the 4-element vector (acting as a 1x4 matrix) to produce a 4-element vector (acting as a 1x4 matrix) <code>mul</code> <code>(gvec4f, gmat4x4f) -&gt; gvec4f</code> Multiplies the 4-element vector (acting as a 4x1 matrix) with a 4x4 matrix to produce a 4-element vector (acting as a 4x1 matrix) <code>mul</code> <code>(gmat4x4f, gmat2x4f) -&gt; gmat2x4f</code> Multiplies the 4x4 matrix to a 2x4 matrix producing a 2x4 matrix <code>mul</code> <code>(gmat4x4f, gmat3x4f) -&gt; gmat3x4f</code> Multiplies the 4x4 matrix to a 3x4 matrix producing a 3x4 matrix <code>mul</code> <code>(gmat4x4f, gmat4x4f) -&gt; gmat4x4f</code> Multiplies the 4x4 matrices together <code>gDiv{A, B}</code> <code>(A, B) -&gt; A</code> Manually constructs a division operation on the provided values, producing the first type as output. You probably won't use this directly <code>gDivRev{A, B}</code> <code>(A, B) -&gt; B</code> Manually constructs a division operation on the provided values, producing the second type as output. You probably won't use this directly <code>div</code> <code>(gu32, gu32) -&gt; gu32</code> Divides the <code>gu32</code> values <code>div{T}</code> <code>(gu32, T) -&gt; gu32</code> Casts the second value to <code>gu32</code> and divides the first with it <code>div{T}</code> <code>(T, gu32) -&gt; gu32</code> Casts the first value to <code>gu32</code> and divides it with the second <code>div</code> <code>(gi32, gi32) -&gt; gi32</code> Divides the <code>gi32</code> values <code>div{T}</code> <code>(gi32, T) -&gt; gi32</code> Casts the second value to <code>gi32</code> and divides the first with it <code>div{T}</code> <code>(T, gi32) -&gt; gi32</code> Casts the first value to <code>gi32</code> and divides it with the second <code>div</code> <code>(gf32, gf32) -&gt; gf32</code> Divides the <code>gf32</code> values <code>div{T}</code> <code>(gf32, T) -&gt; gf32</code> Casts the second value to <code>gf32</code> and divides the first with it <code>div{T}</code> <code>(T, gf32) -&gt; gf32</code> Casts the first value to <code>gf32</code> and divides it with the second <code>div</code> <code>(gvec2u, gvec2u) -&gt; gvec2u</code> Piecewise divides the two vectors <code>div</code> <code>(gvec2u, gu32) -&gt; gvec2u</code> Divides the each element of the vector by the <code>gu32</code> <code>div</code> <code>(gu32, gvec2u) -&gt; gvec2u</code> Divides the <code>gu32</code> by each element of the vector <code>div</code> <code>(gvec2i, gvec2i) -&gt; gvec2i</code> Piecewise divides the two vectors <code>div</code> <code>(gvec2i, gi32) -&gt; gvec2i</code> Divides the each element of the vector by the <code>gi32</code> <code>div</code> <code>(gi32, gvec2i) -&gt; gvec2i</code> Divides the <code>gi32</code> by each element of the vector <code>div</code> <code>(gvec2f, gvec2f) -&gt; gvec2f</code> Piecewise divides the two vectors <code>div</code> <code>(gvec2f, gf32) -&gt; gvec2f</code> Divides the each element of the vector by the <code>gf32</code> <code>div</code> <code>(gf32, gvec2f) -&gt; gvec2f</code> Divides the <code>gf32</code> by each element of the vector <code>div</code> <code>(gvec3u, gvec3u) -&gt; gvec3u</code> Piecewise divides the two vectors <code>div</code> <code>(gvec3u, gu32) -&gt; gvec3u</code> Divides the each element of the vector by the <code>gu32</code> <code>div</code> <code>(gu32, gvec3u) -&gt; gvec3u</code> Divides the <code>gu32</code> by each element of the vector <code>div</code> <code>(gvec3i, gvec3i) -&gt; gvec3i</code> Piecewise divides the two vectors <code>div</code> <code>(gvec3i, gi32) -&gt; gvec3i</code> Divides the each element of the vector by the <code>gi32</code> <code>div</code> <code>(gi32, gvec3i) -&gt; gvec3i</code> Divides the <code>gi32</code> by each element of the vector <code>div</code> <code>(gvec3f, gvec3f) -&gt; gvec3f</code> Piecewise divides the two vectors <code>div</code> <code>(gvec3f, gf32) -&gt; gvec3f</code> Divides the each element of the vector by the <code>gf32</code> <code>div</code> <code>(gf32, gvec3f) -&gt; gvec3f</code> Divides the <code>gf32</code> by each element of the vector <code>div</code> <code>(gvec4u, gvec4u) -&gt; gvec4u</code> Piecewise divides the two vectors <code>div</code> <code>(gvec4u, gu32) -&gt; gvec4u</code> Divides the each element of the vector by the <code>gu32</code> <code>div</code> <code>(gu32, gvec4u) -&gt; gvec4u</code> Divides the <code>gu32</code> by each element of the vector <code>div</code> <code>(gvec4i, gvec4i) -&gt; gvec4i</code> Piecewise divides the two vectors <code>div</code> <code>(gvec4i, gi32) -&gt; gvec4i</code> Divides the each element of the vector by the <code>gi32</code> <code>div</code> <code>(gi32, gvec4i) -&gt; gvec4i</code> Divides the <code>gi32</code> by each element of the vector <code>div</code> <code>(gvec4f, gvec4f) -&gt; gvec4f</code> Piecewise divides the two vectors <code>div</code> <code>(gvec4f, gf32) -&gt; gvec4f</code> Divides the each element of the vector by the <code>gf32</code> <code>div</code> <code>(gf32, gvec4f) -&gt; gvec4f</code> Divides the <code>gf32</code> by each element of the vector <code>gMod{A, B}</code> <code>(A, B) -&gt; A</code> Manually constructs a modulus (remainder) operation on the provided values, producing the first type as output. You probably won't use this directly <code>gModRev{A, B}</code> <code>(A, B) -&gt; B</code> Manually constructs a modulus (remainder) operation on the provided values, producing the second type as output. You probably won't use this directly <code>mod</code> <code>(gu32, gu32) -&gt; gu32</code> Divides the <code>gu32</code> values and returns the remainder <code>mod{T}</code> <code>(gu32, T) -&gt; gu32</code> Casts the second value to <code>gu32</code> and divides the first with it, returning the remainder <code>mod{T}</code> <code>(T, gu32) -&gt; gu32</code> Casts the first value to <code>gu32</code> and divides it with the second, returning the remainder <code>mod</code> <code>(gi32, gi32) -&gt; gi32</code> Divides the <code>gi32</code> values and returns the remainder <code>mod{T}</code> <code>(gi32, T) -&gt; gi32</code> Casts the second value to <code>gi32</code> and divides the first with it, returning the remainder <code>mod{T}</code> <code>(T, gi32) -&gt; gi32</code> Casts the first value to <code>gi32</code> and divides it with the second, returning the remainder <code>mod</code> <code>(gf32, gf32) -&gt; gf32</code> Divides the <code>gf32</code> values and returns the remainder <code>mod{T}</code> <code>(gf32, T) -&gt; gf32</code> Casts the second value to <code>gf32</code> and divides the first with it, returning the remainder <code>mod{T}</code> <code>(T, gf32) -&gt; gf32</code> Casts the first value to <code>gf32</code> and divides it with the second, returning the remainder <code>mod</code> <code>(gvec2u, gvec2u) -&gt; gvec2u</code> Piecewise divides the two vectors, returning the remainder <code>mod</code> <code>(gvec2u, gu32) -&gt; gvec2u</code> Divides the each element of the vector by the <code>gu32</code>, returning the remainder <code>mod</code> <code>(gu32, gvec2u) -&gt; gvec2u</code> Divides the <code>gu32</code> by each element of the vector, returning the remainder <code>mod</code> <code>(gvec2i, gvec2i) -&gt; gvec2i</code> Piecewise divides the two vectors, returning the remainder <code>mod</code> <code>(gvec2i, gi32) -&gt; gvec2i</code> Divides the each element of the vector by the <code>gi32</code>, returning the remainder <code>mod</code> <code>(gi32, gvec2i) -&gt; gvec2i</code> Divides the <code>gi32</code> by each element of the vector, returning the remainder <code>mod</code> <code>(gvec2f, gvec2f) -&gt; gvec2f</code> Piecewise divides the two vectors, returning the remainder <code>mod</code> <code>(gvec2f, gf32) -&gt; gvec2f</code> Divides the each element of the vector by the <code>gf32</code>, returning the remainder <code>mod</code> <code>(gf32, gvec2f) -&gt; gvec2f</code> Divides the <code>gf32</code> by each element of the vector, returning the remainder <code>mod</code> <code>(gvec3u, gvec3u) -&gt; gvec3u</code> Piecewise divides the two vectors, returning the remainder <code>mod</code> <code>(gvec3u, gu32) -&gt; gvec3u</code> Divides the each element of the vector by the <code>gu32</code>, returning the remainder <code>mod</code> <code>(gu32, gvec3u) -&gt; gvec3u</code> Divides the <code>gu32</code> by each element of the vector, returning the remainder <code>mod</code> <code>(gvec3i, gvec3i) -&gt; gvec3i</code> Piecewise divides the two vectors, returning the remainder <code>mod</code> <code>(gvec3i, gi32) -&gt; gvec3i</code> Divides the each element of the vector by the <code>gi32</code>, returning the remainder <code>mod</code> <code>(gi32, gvec3i) -&gt; gvec3i</code> Divides the <code>gi32</code> by each element of the vector, returning the remainder <code>mod</code> <code>(gvec3f, gvec3f) -&gt; gvec3f</code> Piecewise divides the two vectors, returning the remainder <code>mod</code> <code>(gvec3f, gf32) -&gt; gvec3f</code> Divides the each element of the vector by the <code>gf32</code>, returning the remainder <code>mod</code> <code>(gf32, gvec3f) -&gt; gvec3f</code> Divides the <code>gf32</code> by each element of the vector, returning the remainder <code>mod</code> <code>(gvec4u, gvec4u) -&gt; gvec4u</code> Piecewise divides the two vectors, returning the remainder <code>mod</code> <code>(gvec4u, gu32) -&gt; gvec4u</code> Divides the each element of the vector by the <code>gu32</code>, returning the remainder <code>mod</code> <code>(gu32, gvec4u) -&gt; gvec4u</code> Divides the <code>gu32</code> by each element of the vector, returning the remainder <code>mod</code> <code>(gvec4i, gvec4i) -&gt; gvec4i</code> Piecewise divides the two vectors, returning the remainder <code>mod</code> <code>(gvec4i, gi32) -&gt; gvec4i</code> Divides the each element of the vector by the <code>gi32</code>, returning the remainder <code>mod</code> <code>(gi32, gvec4i) -&gt; gvec4i</code> Divides the <code>gi32</code> by each element of the vector, returning the remainder <code>mod</code> <code>(gvec4f, gvec4f) -&gt; gvec4f</code> Piecewise divides the two vectors, returning the remainder <code>mod</code> <code>(gvec4f, gf32) -&gt; gvec4f</code> Divides the each element of the vector by the <code>gf32</code>, returning the remainder <code>mod</code> <code>(gf32, gvec4f) -&gt; gvec4f</code> Divides the <code>gf32</code> by each element of the vector, returning the remainder <code>gpow{A, B}</code> <code>(A, B) -&gt; A</code> Manually constructs a power operation on the provided values, producing the first type as output. You probably won't use this directly <code>pow</code> <code>(gf32, gf32) -&gt; gf32</code> Raises the first <code>gf32</code> to the power of the second <code>pow{T}</code> <code>(gf32, T) -&gt; gf32</code> Casts the second value to <code>gf32</code> and raises the first to the power of it <code>pow{T}</code> <code>(T, gf32) -&gt; gf32</code> Casts the first value to <code>gf32</code> and raises it to the power of the second <code>pow</code> <code>(gvec2f, gvec2f) -&gt; gvec2f</code> Piecewise raises the elements of the first vector to the power of the elements of the second <code>pow{T}</code> <code>(gvec2f, T) -&gt; gvec2f</code> Casts the second value to a vector and piecewise raises the elements of the first vector to the power of the elements of the second <code>pow{T}</code> <code>(T, gvec2f) -&gt; gvec2f</code> Casts the first value to a vector and piecewise raises the elements of the first vector to the power of the elements of the second <code>pow</code> <code>(gvec3f, gvec3f) -&gt; gvec3f</code> Piecewise raises the elements of the first vector to the power of the elements of the second <code>pow{T}</code> <code>(gvec3f, T) -&gt; gvec3f</code> Casts the second value to a vector and piecewise raises the elements of the first vector to the power of the elements of the second <code>pow{T}</code> <code>(T, gvec3f) -&gt; gvec3f</code> Casts the first value to a vector and piecewise raises the elements of the first vector to the power of the elements of the second <code>pow</code> <code>(gvec4f, gvec4f) -&gt; gvec4f</code> Piecewise raises the elements of the first vector to the power of the elements of the second <code>pow{T}</code> <code>(gvec4f, T) -&gt; gvec4f</code> Casts the second value to a vector and piecewise raises the elements of the first vector to the power of the elements of the second <code>pow{T}</code> <code>(T, gvec4f) -&gt; gvec4f</code> Casts the first value to a vector and piecewise raises the elements of the first vector to the power of the elements of the second <code>gmin{I}</code> <code>(I, I) -&gt; I</code> Manually constructs a min call on the provided values. You probably won't use this directly <code>min</code> <code>(gf32, gf32) -&gt; gf32</code> Returns the smaller of the two values <code>min{A}</code> <code>(A, gf32) -&gt; gf32</code> Casts the first value to <code>gf32</code> and returns the smaller of the two values <code>min{B}</code> <code>(gf32, B) -&gt; gf32</code> Casts the second value to <code>gf32</code> and returns the smaller of the two values <code>min</code> <code>(gu32, gu32) -&gt; gu32</code> Returns the smaller of the two values <code>min{A}</code> <code>(A, gu32) -&gt; gu32</code> Casts the first value to <code>gu32</code> and returns the smaller of the two values <code>min{B}</code> <code>(gu32, B) -&gt; gu32</code> Casts the second value to <code>gu32</code> and returns the smaller of the two values <code>min</code> <code>(gi32, gi32) -&gt; gi32</code> Returns the smaller of the two values <code>min{A}</code> <code>(A, gi32) -&gt; gi32</code> Casts the first value to <code>gi32</code> and returns the smaller of the two values <code>min{B}</code> <code>(gi32, B) -&gt; gi32</code> Casts the second value to <code>gi32</code> and returns the smaller of the two values <code>gmax{I}</code> <code>(I, I) -&gt; I</code> Manually constructs a max call on the provided values. You probably won't use this directly <code>max</code> <code>(gf32, gf32) -&gt; gf32</code> Returns the smaller of the two values <code>max{A}</code> <code>(A, gf32) -&gt; gf32</code> Casts the first value to <code>gf32</code> and returns the smaller of the two values <code>max{B}</code> <code>(gf32, B) -&gt; gf32</code> Casts the second value to <code>gf32</code> and returns the smaller of the two values <code>max</code> <code>(gu32, gu32) -&gt; gu32</code> Returns the smaller of the two values <code>max{A}</code> <code>(A, gu32) -&gt; gu32</code> Casts the first value to <code>gu32</code> and returns the smaller of the two values <code>max{B}</code> <code>(gu32, B) -&gt; gu32</code> Casts the second value to <code>gu32</code> and returns the smaller of the two values <code>max</code> <code>(gi32, gi32) -&gt; gi32</code> Returns the smaller of the two values <code>max{A}</code> <code>(A, gi32) -&gt; gi32</code> Casts the first value to <code>gi32</code> and returns the smaller of the two values <code>max{B}</code> <code>(gi32, B) -&gt; gi32</code> Casts the second value to <code>gi32</code> and returns the smaller of the two values <code>gsqrt{I}</code> <code>I -&gt; I</code> Manually constructs a square root call on the provided value. You probably won't use this directly <code>sqrt</code> <code>gf32 -&gt; gf32</code> Returns the square root of the value <code>sqrt</code> <code>gvec2f -&gt; gvec2f</code> Returns the square root of each element of the vector <code>sqrt</code> <code>gvec3f -&gt; gvec3f</code> Returns the square root of each element of the vector <code>sqrt</code> <code>gvec4f -&gt; gvec4f</code> Returns the square root of each element of the vector <code>gacos{I}</code> <code>I -&gt; I</code> Manually constructs an arccosine call on the provided value. You probably won't use this directly <code>acos</code> <code>gf32 -&gt; gf32</code> Returns the arccosine of the value <code>acos</code> <code>gvec2f -&gt; gvec2f</code> Returns the arccosine of each element of the vector <code>acos</code> <code>gvec3f -&gt; gvec3f</code> Returns the arccosine of each element of the vector <code>acos</code> <code>gvec4f -&gt; gvec4f</code> Returns the arccosine of each element of the vector <code>gacosh{I}</code> <code>I -&gt; I</code> Manually constructs a hyperbolic arccosine call on the provided value. You probably won't use this directly <code>acosh</code> <code>gf32 -&gt; gf32</code> Returns the hyperbolic arccosine of the value <code>acosh</code> <code>gvec2f -&gt; gvec2f</code> Returns the hyperbolic arccosine of each element of the vector <code>acosh</code> <code>gvec3f -&gt; gvec3f</code> Returns the hyperbolic arccosine of each element of the vector <code>acosh</code> <code>gvec4f -&gt; gvec4f</code> Returns the hyperbolic arccosine of each element of the vector <code>gasin{I}</code> <code>I -&gt; I</code> Manually constructs an arcsine call on the provided value. You probably won't use this directly <code>asin</code> <code>gf32 -&gt; gf32</code> Returns the arcsine of the value <code>asin</code> <code>gvec2f -&gt; gvec2f</code> Returns the arcsine of each element of the vector <code>asin</code> <code>gvec3f -&gt; gvec3f</code> Returns the arcsine of each element of the vector <code>asin</code> <code>gvec4f -&gt; gvec4f</code> Returns the arcsine of each element of the vector <code>gasinh{I}</code> <code>I -&gt; I</code> Manually constructs a hyperbolic arcsine call on the provided value. You probably won't use this directly <code>asinh</code> <code>gf32 -&gt; gf32</code> Returns the hyperbolic arcsine of the value <code>asinh</code> <code>gvec2f -&gt; gvec2f</code> Returns the hyperbolic arcsine of each element of the vector <code>asinh</code> <code>gvec3f -&gt; gvec3f</code> Returns the hyperbolic arcsine of each element of the vector <code>asinh</code> <code>gvec4f -&gt; gvec4f</code> Returns the hyperbolic arcsine of each element of the vector <code>gatan{I}</code> <code>I -&gt; I</code> Manually constructs an arctangent call on the provided value. You probably won't use this directly <code>atan</code> <code>gf32 -&gt; gf32</code> Returns the arctangent of the value <code>atan</code> <code>gvec2f -&gt; gvec2f</code> Returns the arctangent of each element of the vector <code>atan</code> <code>gvec3f -&gt; gvec3f</code> Returns the arctangent of each element of the vector <code>atan</code> <code>gvec4f -&gt; gvec4f</code> Returns the arctangent of each element of the vector <code>gatanh{I}</code> <code>I -&gt; I</code> Manually constructs a hyperbolic arctangent call on the provided value. You probably won't use this directly <code>atanh</code> <code>gf32 -&gt; gf32</code> Returns the hyperbolic arctangent of the value <code>atanh</code> <code>gvec2f -&gt; gvec2f</code> Returns the hyperbolic arctangent of each element of the vector <code>atanh</code> <code>gvec3f -&gt; gvec3f</code> Returns the hyperbolic arctangent of each element of the vector <code>atanh</code> <code>gvec4f -&gt; gvec4f</code> Returns the hyperbolic arctangent of each element of the vector <code>gatan2{A, B}</code> <code>(A, B) -&gt; A</code> Manually constructs an atan2 operation on the provided values, producing the first type as output. You probably won't use this directly <code>atan2</code> <code>(gf32, gf32) -&gt; gf32</code> Calculates the arctangent from the X and Y dimensions <code>atan2{T}</code> <code>(gf32, T) -&gt; gf32</code> Casts the second value to <code>gf32</code> and calculates the arctangent from the X and Y dimensions <code>atan2{T}</code> <code>(T, gf32) -&gt; gf32</code> Casts the first value to <code>gf32</code> and calculates the arctangent from the X and Y dimensions <code>atan2</code> <code>(gvec2f, gvec2f) -&gt; gvec2f</code> Piecewise calculates the arctangent from the two vectors as the X and Y dimensions, respectively <code>atan2{T}</code> <code>(gvec2f, T) -&gt; gvec2f</code> Casts the second value to a vector and piecewise calculates the arctangent from the two vectors as the X and Y dimensions, respectively <code>atan2{T}</code> <code>(T, gvec2f) -&gt; gvec2f</code> Casts the first value to a vector and piecewise calculates the arctangent from the two vectors as the X and Y dimensions, respectively <code>atan2</code> <code>(gvec3f, gvec3f) -&gt; gvec3f</code> Piecewise calculates the arctangent from the two vectors as the X and Y dimensions, respectively <code>atan2{T}</code> <code>(gvec3f, T) -&gt; gvec3f</code> Casts the second value to a vector and piecewise calculates the arctangent from the two vectors as the X and Y dimensions, respectively <code>atan2{T}</code> <code>(T, gvec3f) -&gt; gvec3f</code> Casts the first value to a vector and piecewise calculates the arctangent from the two vectors as the X and Y dimensions, respectively <code>atan2</code> <code>(gvec4f, gvec4f) -&gt; gvec4f</code> Piecewise calculates the arctangent from the two vectors as the X and Y dimensions, respectively <code>atan2{T}</code> <code>(gvec4f, T) -&gt; gvec4f</code> Casts the second value to a vector and piecewise calculates the arctangent from the two vectors as the X and Y dimensions, respectively <code>atan2{T}</code> <code>(T, gvec4f) -&gt; gvec4f</code> Casts the first value to a vector and piecewise calculates the arctangent from the two vectors as the X and Y dimensions, respectively <code>gfloor{I}</code> <code>I -&gt; I</code> Manually constructs a floor call on the provided value. You probably won't use this directly <code>floor</code> <code>gf32 -&gt; gf32</code> Returns the floor (integer component) of the value <code>floor</code> <code>gvec2f -&gt; gvec2f</code> Returns the floor (integer component) of each element of the vector <code>floor</code> <code>gvec3f -&gt; gvec3f</code> Returns the floor (integer component) of each element of the vector <code>floor</code> <code>gvec4f -&gt; gvec4f</code> Returns the floor (integer component) of each element of the vector <code>gceil{I}</code> <code>I -&gt; I</code> Manually constructs a ceil call on the provided value. You probably won't use this directly <code>ceil</code> <code>gf32 -&gt; gf32</code> Returns the ceil (next integer) of the value <code>ceil</code> <code>gvec2f -&gt; gvec2f</code> Returns the ceil (next integer) of each element of the vector <code>ceil</code> <code>gvec3f -&gt; gvec3f</code> Returns the ceil (next integer) of each element of the vector <code>ceil</code> <code>gvec4f -&gt; gvec4f</code> Returns the ceil (next integer) of each element of the vector <code>gclamp{I}</code> <code>(I, I, I) -&gt; I</code> Manually constructs a clamp call on the provided values. You probably won't use this directly <code>clamp</code> <code>(gf32, gf32, gf32) -&gt; gf32</code> Clamps the first value to be greater than or equal to the second and less than or equal to the third <code>clamp{T}</code> <code>(gf32, T, T) -&gt; gf32</code> Casts the clamp values to <code>gf32</code> and clamps the first value to be greater than or equal to the second and less than or equal to the third <code>clamp{T}</code> <code>(gf32, gf32, T) -&gt; gf32</code> Casts the last value to <code>gf32</code> and clamps the first value to be greater than or equal to the second and less than or equal to the third <code>clamp{T}</code> <code>(gf32, T, gf32) -&gt; gf32</code> Casts the second value to <code>gf32</code> and clamps the first value to be greater than or equal to the second and less than or equal to the third <code>clamp</code> <code>(gvec2f, gvec2f, gvec2f) -&gt; gvec2f</code> Piecewise clamps the first vector to be greater than or equal to the second and less than or equal to the third <code>clamp{T}</code> <code>(gvec2f, T, T) -&gt; gvec2f</code> Casts the clamp values to <code>gvec2f</code> and piecewise clamps the first vector to be greater than or equal to the second and less than or equal to the third <code>clamp{T}</code> <code>(gvec2f, gvec2f, T) -&gt; gvec2f</code> Casts the last value to <code>gvec2f</code> and piecewise clamps the first vector to be greater than or equal to the second and less than or equal to the third <code>clamp{T}</code> <code>(gvec2f, T, gvec2f) -&gt; gvec2f</code> Casts the second value to <code>gvec2f</code> and piecewise clamps the first vector to be greater than or equal to the second and less than or equal to the third <code>clamp</code> <code>(gvec3f, gvec3f, gvec3f) -&gt; gvec3f</code> Piecewise clamps the first vector to be greater than or equal to the second and less than or equal to the third <code>clamp{T}</code> <code>(gvec3f, T, T) -&gt; gvec3f</code> Casts the clamp values to <code>gvec3f</code> and piecewise clamps the first vector to be greater than or equal to the second and less than or equal to the third <code>clamp{T}</code> <code>(gvec3f, gvec3f, T) -&gt; gvec3f</code> Casts the last value to <code>gvec3f</code> and piecewise clamps the first vector to be greater than or equal to the second and less than or equal to the third <code>clamp{T}</code> <code>(gvec3f, T, gvec3f) -&gt; gvec3f</code> Casts the second value to <code>gvec3f</code> and piecewise clamps the first vector to be greater than or equal to the second and less than or equal to the third <code>clamp</code> <code>(gvec4f, gvec4f, gvec4f) -&gt; gvec4f</code> Piecewise clamps the first vector to be greater than or equal to the second and less than or equal to the third <code>clamp{T}</code> <code>(gvec4f, T, T) -&gt; gvec4f</code> Casts the clamp values to <code>gvec4f</code> and piecewise clamps the first vector to be greater than or equal to the second and less than or equal to the third <code>clamp{T}</code> <code>(gvec4f, gvec4f, T) -&gt; gvec4f</code> Casts the last value to <code>gvec4f</code> and piecewise clamps the first vector to be greater than or equal to the second and less than or equal to the third <code>clamp{T}</code> <code>(gvec4f, T, gvec4f) -&gt; gvec4f</code> Casts the second value to <code>gvec4f</code> and piecewise clamps the first vector to be greater than or equal to the second and less than or equal to the third <code>gsaturate{I}</code> <code>I -&gt; I</code> Manually constructs a saturate call on the provided value. You probably won't use this directly <code>saturate</code> <code>gf32 -&gt; gf32</code> Returns the saturate (clamp between 0 and 1) of the value <code>saturate</code> <code>gvec2f -&gt; gvec2f</code> Returns the saturate (clamp between 0 and 1) of each element of the vector <code>saturate</code> <code>gvec3f -&gt; gvec3f</code> Returns the saturate (clamp between 0 and 1) of each element of the vector <code>saturate</code> <code>gvec4f -&gt; gvec4f</code> Returns the saturate (clamp between 0 and 1) of each element of the vector <code>gexp{I}</code> <code>I -&gt; I</code> Manually constructs an exp call on the provided value. You probably won't use this directly <code>exp</code> <code>gf32 -&gt; gf32</code> Returns the exp (<code>e ** x</code>) of the value <code>exp</code> <code>gvec2f -&gt; gvec2f</code> Returns the exp (<code>e ** x</code>) of each element of the vector <code>exp</code> <code>gvec3f -&gt; gvec3f</code> Returns the exp (<code>e ** x</code>) of each element of the vector <code>exp</code> <code>gvec4f -&gt; gvec4f</code> Returns the exp (<code>e ** x</code>) of each element of the vector <code>gln{I}</code> <code>I -&gt; I</code> Manually constructs a ln call on the provided value. You probably won't use this directly <code>ln</code> <code>gf32 -&gt; gf32</code> Returns the ln (natural log) of the value <code>ln</code> <code>gvec2f -&gt; gvec2f</code> Returns the ln (natural log) of each element of the vector <code>ln</code> <code>gvec3f -&gt; gvec3f</code> Returns the ln (natural log) of each element of the vector <code>ln</code> <code>gvec4f -&gt; gvec4f</code> Returns the ln (natural log) of each element of the vector <code>glog2{I}</code> <code>I -&gt; I</code> Manually constructs a log2 call on the provided value. You probably won't use this directly <code>log2</code> <code>gf32 -&gt; gf32</code> Returns the log2 (log base 2) of the value <code>log2</code> <code>gvec2f -&gt; gvec2f</code> Returns the log2 (log base 2) of each element of the vector <code>log2</code> <code>gvec3f -&gt; gvec3f</code> Returns the log2 (log base 2) of each element of the vector <code>log2</code> <code>gvec4f -&gt; gvec4f</code> Returns the log2 (log base 2) of each element of the vector <code>glog10{I}</code> <code>I -&gt; I</code> Manually constructs a log10 call on the provided value. You probably won't use this directly <code>log10</code> <code>gf32 -&gt; gf32</code> Returns the log10 (log base 10) of the value <code>log10</code> <code>gvec2f -&gt; gvec2f</code> Returns the log10 (log base 10) of each element of the vector <code>log10</code> <code>gvec3f -&gt; gvec3f</code> Returns the log10 (log base 10) of each element of the vector <code>log10</code> <code>gvec4f -&gt; gvec4f</code> Returns the log10 (log base 10) of each element of the vector <code>gcos{I}</code> <code>I -&gt; I</code> Manually constructs a cosine call on the provided value. You probably won't use this directly <code>cos</code> <code>gf32 -&gt; gf32</code> Returns the cosine of the value <code>cos</code> <code>gvec2f -&gt; gvec2f</code> Returns the cosine of each element of the vector <code>cos</code> <code>gvec3f -&gt; gvec3f</code> Returns the cosine of each element of the vector <code>cos</code> <code>gvec4f -&gt; gvec4f</code> Returns the cosine of each element of the vector <code>gcosh{I}</code> <code>I -&gt; I</code> Manually constructs a hyperbolic cosine call on the provided value. You probably won't use this directly <code>cosh</code> <code>gf32 -&gt; gf32</code> Returns the hyperbolic cosine of the value <code>cosh</code> <code>gvec2f -&gt; gvec2f</code> Returns the hyperbolic cosine of each element of the vector <code>cosh</code> <code>gvec3f -&gt; gvec3f</code> Returns the hyperbolic cosine of each element of the vector <code>cosh</code> <code>gvec4f -&gt; gvec4f</code> Returns the hyperbolic cosine of each element of the vector <code>gsin{I}</code> <code>I -&gt; I</code> Manually constructs a sine call on the provided value. You probably won't use this directly <code>sin</code> <code>gf32 -&gt; gf32</code> Returns the sine of the value <code>sin</code> <code>gvec2f -&gt; gvec2f</code> Returns the sine of each element of the vector <code>sin</code> <code>gvec3f -&gt; gvec3f</code> Returns the sine of each element of the vector <code>sin</code> <code>gvec4f -&gt; gvec4f</code> Returns the sine of each element of the vector <code>gsinh{I}</code> <code>I -&gt; I</code> Manually constructs a hyperbolic sine call on the provided value. You probably won't use this directly <code>sinh</code> <code>gf32 -&gt; gf32</code> Returns the hyperbolic sine of the value <code>sinh</code> <code>gvec2f -&gt; gvec2f</code> Returns the hyperbolic sine of each element of the vector <code>sinh</code> <code>gvec3f -&gt; gvec3f</code> Returns the hyperbolic sine of each element of the vector <code>sinh</code> <code>gvec4f -&gt; gvec4f</code> Returns the hyperbolic sine of each element of the vector <code>gtan{I}</code> <code>I -&gt; I</code> Manually constructs a tangent call on the provided value. You probably won't use this directly <code>tan</code> <code>gf32 -&gt; gf32</code> Returns the tangent of the value <code>tan</code> <code>gvec2f -&gt; gvec2f</code> Returns the tangent of each element of the vector <code>tan</code> <code>gvec3f -&gt; gvec3f</code> Returns the tangent of each element of the vector <code>tan</code> <code>gvec4f -&gt; gvec4f</code> Returns the tangent of each element of the vector <code>gtanh{I}</code> <code>I -&gt; I</code> Manually constructs a hyperbolic tangent call on the provided value. You probably won't use this directly <code>tanh</code> <code>gf32 -&gt; gf32</code> Returns the hyperbolic tangent of the value <code>tanh</code> <code>gvec2f -&gt; gvec2f</code> Returns the hyperbolic tangent of each element of the vector <code>tanh</code> <code>gvec3f -&gt; gvec3f</code> Returns the hyperbolic tangent of each element of the vector <code>tanh</code> <code>gvec4f -&gt; gvec4f</code> Returns the hyperbolic tangent of each element of the vector <code>sec</code> <code>gf32 -&gt; gf32</code> Returns the secant of the value <code>sec</code> <code>gvec2f -&gt; gvec2f</code> Returns the secant of each element of the vector <code>sec</code> <code>gvec3f -&gt; gvec3f</code> Returns the secant of each element of the vector <code>sec</code> <code>gvec4f -&gt; gvec4f</code> Returns the secant of each element of the vector <code>csc</code> <code>gf32 -&gt; gf32</code> Returns the cosecant of the value <code>csc</code> <code>gvec2f -&gt; gvec2f</code> Returns the cosecant of each element of the vector <code>csc</code> <code>gvec3f -&gt; gvec3f</code> Returns the cosecant of each element of the vector <code>csc</code> <code>gvec4f -&gt; gvec4f</code> Returns the cosecant of each element of the vector <code>cot</code> <code>gf32 -&gt; gf32</code> Returns the cotangent of the value <code>cot</code> <code>gvec2f -&gt; gvec2f</code> Returns the cotangent of each element of the vector <code>cot</code> <code>gvec3f -&gt; gvec3f</code> Returns the cotangent of each element of the vector <code>cot</code> <code>gvec4f -&gt; gvec4f</code> Returns the cotangent of each element of the vector <code>asec</code> <code>gf32 -&gt; gf32</code> Returns the arcsecant of the value <code>asec</code> <code>gvec2f -&gt; gvec2f</code> Returns the arcsecant of each element of the vector <code>asec</code> <code>gvec3f -&gt; gvec3f</code> Returns the arcsecant of each element of the vector <code>asec</code> <code>gvec4f -&gt; gvec4f</code> Returns the arcsecant of each element of the vector <code>acsc</code> <code>gf32 -&gt; gf32</code> Returns the arccosecant of the value <code>acsc</code> <code>gvec2f -&gt; gvec2f</code> Returns the arccosecant of each element of the vector <code>acsc</code> <code>gvec3f -&gt; gvec3f</code> Returns the arccosecant of each element of the vector <code>acsc</code> <code>gvec4f -&gt; gvec4f</code> Returns the arccosecant of each element of the vector <code>acot</code> <code>gf32 -&gt; gf32</code> Returns the arccotangent of the value <code>acot</code> <code>gvec2f -&gt; gvec2f</code> Returns the arccotangent of each element of the vector <code>acot</code> <code>gvec3f -&gt; gvec3f</code> Returns the arccotangent of each element of the vector <code>acot</code> <code>gvec4f -&gt; gvec4f</code> Returns the arccotangent of each element of the vector <code>sech</code> <code>gf32 -&gt; gf32</code> Returns the hyperbolic secant of the value <code>sech</code> <code>gvec2f -&gt; gvec2f</code> Returns the hyperbolic secant of each element of the vector <code>sech</code> <code>gvec3f -&gt; gvec3f</code> Returns the hyperbolic secant of each element of the vector <code>sech</code> <code>gvec4f -&gt; gvec4f</code> Returns the hyperbolic secant of each element of the vector <code>csch</code> <code>gf32 -&gt; gf32</code> Returns the hyperbolic cosecant of the value <code>csch</code> <code>gvec2f -&gt; gvec2f</code> Returns the hyperbolic cosecant of each element of the vector <code>csch</code> <code>gvec3f -&gt; gvec3f</code> Returns the hyperbolic cosecant of each element of the vector <code>csch</code> <code>gvec4f -&gt; gvec4f</code> Returns the hyperbolic cosecant of each element of the vector <code>coth</code> <code>gf32 -&gt; gf32</code> Returns the hyperbolic cotangent of the value <code>coth</code> <code>gvec2f -&gt; gvec2f</code> Returns the hyperbolic cotangent of each element of the vector <code>coth</code> <code>gvec3f -&gt; gvec3f</code> Returns the hyperbolic cotangent of each element of the vector <code>coth</code> <code>gvec4f -&gt; gvec4f</code> Returns the hyperbolic cotangent of each element of the vector <code>asech</code> <code>gf32 -&gt; gf32</code> Returns the hyperbolic arcsecant of the value <code>asech</code> <code>gvec2f -&gt; gvec2f</code> Returns the hyperbolic arcsecant of each element of the vector <code>asech</code> <code>gvec3f -&gt; gvec3f</code> Returns the hyperbolic arcsecant of each element of the vector <code>asech</code> <code>gvec4f -&gt; gvec4f</code> Returns the hyperbolic arcsecant of each element of the vector <code>acsch</code> <code>gf32 -&gt; gf32</code> Returns the hyperbolic arccosecant of the value <code>acsch</code> <code>gvec2f -&gt; gvec2f</code> Returns the hyperbolic arccosecant of each element of the vector <code>acsch</code> <code>gvec3f -&gt; gvec3f</code> Returns the hyperbolic arccosecant of each element of the vector <code>acsch</code> <code>gvec4f -&gt; gvec4f</code> Returns the hyperbolic arccosecant of each element of the vector <code>acoth</code> <code>gf32 -&gt; gf32</code> Returns the hyperbolic arccotangent of the value <code>acoth</code> <code>gvec2f -&gt; gvec2f</code> Returns the hyperbolic arccotangent of each element of the vector <code>acoth</code> <code>gvec3f -&gt; gvec3f</code> Returns the hyperbolic arccotangent of each element of the vector <code>acoth</code> <code>gvec4f -&gt; gvec4f</code> Returns the hyperbolic arccotangent of each element of the vector"},{"location":"built_ins/#gpgpu-comparison-functions","title":"GPGPU Comparison functions","text":"Name Type Description <code>geq{I, O}</code> <code>(I, I) -&gt; O</code> Manually constructs an equality check on the provided inputs. You probably won't use this directly <code>eq</code> <code>(gu32, gu32) -&gt; gbool</code> Returns <code>true</code> if the two <code>gu32</code>s are the same <code>eq{T}</code> <code>(gu32, T) -&gt; gbool</code> Casts the second value to <code>gu32</code> and returns <code>true</code> if it is the same as the first value <code>eq{T}</code> <code>(T, gu32) -&gt; gbool</code> Casts the first value to <code>gu32</code> and returns <code>true</code> if it is the same as the second value <code>eq</code> <code>(gi32, gi32) -&gt; gbool</code> Returns <code>true</code> if the two <code>gi32</code>s are the same <code>eq{T}</code> <code>(gi32, T) -&gt; gbool</code> Casts the second value to <code>gi32</code> and returns <code>true</code> if it is the same as the first value <code>eq{T}</code> <code>(T, gi32) -&gt; gbool</code> Casts the first value to <code>gi32</code> and returns <code>true</code> if it is the same as the second value <code>eq</code> <code>(gf32, gf32) -&gt; gbool</code> Returns <code>true</code> if the two <code>gf32</code>s are the same <code>eq{T}</code> <code>(gf32, T) -&gt; gbool</code> Casts the second value to <code>gf32</code> and returns <code>true</code> if it is the same as the first value <code>eq{T}</code> <code>(T, gf32) -&gt; gbool</code> Casts the first value to <code>gf32</code> and returns <code>true</code> if it is the same as the second value <code>eq</code> <code>(gbool, gbool) -&gt; gbool</code> Returns <code>true</code> if the two <code>gbool</code>s are the same <code>eq{T}</code> <code>(gbool, T) -&gt; gbool</code> Casts the second value to <code>gbool</code> and returns <code>true</code> if it is the same as the first value <code>eq{T}</code> <code>(T, gbool) -&gt; gbool</code> Casts the first value to <code>gbool</code> and returns <code>true</code> if it is the same as the second value <code>eq{T}</code> <code>(gvec2u, gvec2u) -&gt; gvec2b</code> Piecewise checks equality of the two vectors and stores the result as a new boolean vector <code>eq{T}</code> <code>(gvec2i, gvec2i) -&gt; gvec2b</code> Piecewise checks equality of the two vectors and stores the result as a new boolean vector <code>eq{T}</code> <code>(gvec2f, gvec2f) -&gt; gvec2b</code> Piecewise checks equality of the two vectors and stores the result as a new boolean vector <code>eq{T}</code> <code>(gvec2b, gvec2b) -&gt; gvec2b</code> Piecewise checks equality of the two vectors and stores the result as a new boolean vector <code>eq{T}</code> <code>(gvec3u, gvec3u) -&gt; gvec3b</code> Piecewise checks equality of the two vectors and stores the result as a new boolean vector <code>eq{T}</code> <code>(gvec3i, gvec3i) -&gt; gvec3b</code> Piecewise checks equality of the two vectors and stores the result as a new boolean vector <code>eq{T}</code> <code>(gvec3f, gvec3f) -&gt; gvec3b</code> Piecewise checks equality of the two vectors and stores the result as a new boolean vector <code>eq{T}</code> <code>(gvec3b, gvec3b) -&gt; gvec3b</code> Piecewise checks equality of the two vectors and stores the result as a new boolean vector <code>eq{T}</code> <code>(gvec4u, gvec4u) -&gt; gvec4b</code> Piecewise checks equality of the two vectors and stores the result as a new boolean vector <code>eq{T}</code> <code>(gvec4i, gvec4i) -&gt; gvec4b</code> Piecewise checks equality of the two vectors and stores the result as a new boolean vector <code>eq{T}</code> <code>(gvec4f, gvec4f) -&gt; gvec4b</code> Piecewise checks equality of the two vectors and stores the result as a new boolean vector <code>eq{T}</code> <code>(gvec4b, gvec4b) -&gt; gvec4b</code> Piecewise checks equality of the two vectors and stores the result as a new boolean vector <code>gneq{I, O}</code> <code>(I, I) -&gt; O</code> Manually constructs an inequality check on the provided inputs. You probably won't use this directly <code>neq</code> <code>(gu32, gu32) -&gt; gbool</code> Returns <code>true</code> if the two <code>gu32</code>s are different <code>neq{T}</code> <code>(gu32, T) -&gt; gbool</code> Casts the second value to <code>gu32</code> and returns <code>true</code> if it is different to the first value <code>neq{T}</code> <code>(T, gu32) -&gt; gbool</code> Casts the first value to <code>gu32</code> and returns <code>true</code> if it is different to the second value <code>neq</code> <code>(gi32, gi32) -&gt; gbool</code> Returns <code>true</code> if the two <code>gi32</code>s are different <code>neq{T}</code> <code>(gi32, T) -&gt; gbool</code> Casts the second value to <code>gi32</code> and returns <code>true</code> if it is different to the first value <code>neq{T}</code> <code>(T, gi32) -&gt; gbool</code> Casts the first value to <code>gi32</code> and returns <code>true</code> if it is different to the second value <code>neq</code> <code>(gf32, gf32) -&gt; gbool</code> Returns <code>true</code> if the two <code>gf32</code>s are different <code>neq{T}</code> <code>(gf32, T) -&gt; gbool</code> Casts the second value to <code>gf32</code> and returns <code>true</code> if it is different to the first value <code>neq{T}</code> <code>(T, gf32) -&gt; gbool</code> Casts the first value to <code>gf32</code> and returns <code>true</code> if it is different to the second value <code>neq</code> <code>(gbool, gbool) -&gt; gbool</code> Returns <code>true</code> if the two <code>gbool</code>s are different <code>neq{T}</code> <code>(gbool, T) -&gt; gbool</code> Casts the second value to <code>gbool</code> and returns <code>true</code> if it is different to the first value <code>neq{T}</code> <code>(T, gbool) -&gt; gbool</code> Casts the first value to <code>gbool</code> and returns <code>true</code> if it is different to the second value <code>neq{T}</code> <code>(gvec2u, gvec2u) -&gt; gvec2b</code> Piecewise checks inequality of the two vectors and stores the result as a new boolean vector <code>neq{T}</code> <code>(gvec2i, gvec2i) -&gt; gvec2b</code> Piecewise checks inequality of the two vectors and stores the result as a new boolean vector <code>neq{T}</code> <code>(gvec2f, gvec2f) -&gt; gvec2b</code> Piecewise checks inequality of the two vectors and stores the result as a new boolean vector <code>neq{T}</code> <code>(gvec2b, gvec2b) -&gt; gvec2b</code> Piecewise checks inequality of the two vectors and stores the result as a new boolean vector <code>neq{T}</code> <code>(gvec3u, gvec3u) -&gt; gvec3b</code> Piecewise checks inequality of the two vectors and stores the result as a new boolean vector <code>neq{T}</code> <code>(gvec3i, gvec3i) -&gt; gvec3b</code> Piecewise checks inequality of the two vectors and stores the result as a new boolean vector <code>neq{T}</code> <code>(gvec3f, gvec3f) -&gt; gvec3b</code> Piecewise checks inequality of the two vectors and stores the result as a new boolean vector <code>neq{T}</code> <code>(gvec3b, gvec3b) -&gt; gvec3b</code> Piecewise checks inequality of the two vectors and stores the result as a new boolean vector <code>neq{T}</code> <code>(gvec4u, gvec4u) -&gt; gvec4b</code> Piecewise checks inequality of the two vectors and stores the result as a new boolean vector <code>neq{T}</code> <code>(gvec4i, gvec4i) -&gt; gvec4b</code> Piecewise checks inequality of the two vectors and stores the result as a new boolean vector <code>neq{T}</code> <code>(gvec4f, gvec4f) -&gt; gvec4b</code> Piecewise checks inequality of the two vectors and stores the result as a new boolean vector <code>neq{T}</code> <code>(gvec4b, gvec4b) -&gt; gvec4b</code> Piecewise checks inequality of the two vectors and stores the result as a new boolean vector <code>glt{I, O}</code> <code>(I, I) -&gt; O</code> Manually constructs a less than check on the provided inputs. You probably won't use this directly <code>lt</code> <code>(gu32, gu32) -&gt; gbool</code> Returns <code>true</code> if the first <code>gu32</code> is less than the second <code>lt{T}</code> <code>(gu32, T) -&gt; gbool</code> Casts the second value to <code>gu32</code> and returns <code>true</code> if the first is less than it <code>lt{T}</code> <code>(T, gu32) -&gt; gbool</code> Casts the first value to <code>gu32</code> and returns <code>true</code> if it is less than the second <code>lt</code> <code>(gi32, gi32) -&gt; gbool</code> Returns <code>true</code> if the first <code>gi32</code> is less than the second <code>lt{T}</code> <code>(gi32, T) -&gt; gbool</code> Casts the second value to <code>gi32</code> and returns <code>true</code> if the first is less than it <code>lt{T}</code> <code>(T, gi32) -&gt; gbool</code> Casts the first value to <code>gi32</code> and returns <code>true</code> if it is less than the second <code>lt</code> <code>(gf32, gf32) -&gt; gbool</code> Returns <code>true</code> if the first <code>gf32</code> is less than the second <code>lt{T}</code> <code>(gf32, T) -&gt; gbool</code> Casts the second value to <code>gf32</code> and returns <code>true</code> if the first is less than it <code>lt{T}</code> <code>(T, gf32) -&gt; gbool</code> Casts the first value to <code>gf32</code> and returns <code>true</code> if it is less than the second <code>lt{T}</code> <code>(gvec2u, gvec2u) -&gt; gvec2b</code> Piecewise checks if the elements of the first vector are less than the second <code>lt{T}</code> <code>(gvec2i, gvec2i) -&gt; gvec2b</code> Piecewise checks if the elements of the first vector are less than the second <code>lt{T}</code> <code>(gvec2f, gvec2f) -&gt; gvec2b</code> Piecewise checks if the elements of the first vector are less than the second <code>lt{T}</code> <code>(gvec3u, gvec3u) -&gt; gvec3b</code> Piecewise checks if the elements of the first vector are less than the second <code>lt{T}</code> <code>(gvec3i, gvec3i) -&gt; gvec3b</code> Piecewise checks if the elements of the first vector are less than the second <code>lt{T}</code> <code>(gvec3f, gvec3f) -&gt; gvec3b</code> Piecewise checks if the elements of the first vector are less than the second <code>lt{T}</code> <code>(gvec4u, gvec4u) -&gt; gvec4b</code> Piecewise checks if the elements of the first vector are less than the second <code>lt{T}</code> <code>(gvec4i, gvec4i) -&gt; gvec4b</code> Piecewise checks if the elements of the first vector are less than the second <code>lt{T}</code> <code>(gvec4f, gvec4f) -&gt; gvec4b</code> Piecewise checks if the elements of the first vector are less than the second <code>glte{I, O}</code> <code>(I, I) -&gt; O</code> Manually constructs a less than or equals check on the provided inputs. You probably won't use this directly <code>lte</code> <code>(gu32, gu32) -&gt; gbool</code> Returns <code>true</code> if the first <code>gu32</code> is less than or equal to the second <code>lte{T}</code> <code>(gu32, T) -&gt; gbool</code> Casts the second value to <code>gu32</code> and returns <code>true</code> if the first is less than or equal to it <code>lte{T}</code> <code>(T, gu32) -&gt; gbool</code> Casts the first value to <code>gu32</code> and returns <code>true</code> if it is less than or equal to the second <code>lte</code> <code>(gi32, gi32) -&gt; gbool</code> Returns <code>true</code> if the first <code>gi32</code> is less than or equal to the second <code>lte{T}</code> <code>(gi32, T) -&gt; gbool</code> Casts the second value to <code>gi32</code> and returns <code>true</code> if the first is less than or equal to it <code>lte{T}</code> <code>(T, gi32) -&gt; gbool</code> Casts the first value to <code>gi32</code> and returns <code>true</code> if it is less than or equal to the second <code>lte</code> <code>(gf32, gf32) -&gt; gbool</code> Returns <code>true</code> if the first <code>gf32</code> is less than or equal to the second <code>lte{T}</code> <code>(gf32, T) -&gt; gbool</code> Casts the second value to <code>gf32</code> and returns <code>true</code> if the first is less than or equal to it <code>lte{T}</code> <code>(T, gf32) -&gt; gbool</code> Casts the first value to <code>gf32</code> and returns <code>true</code> if it is less than or equal to the second <code>lte{T}</code> <code>(gvec2u, gvec2u) -&gt; gvec2b</code> Piecewise checks if the elements of the first vector are less than or equal to the second <code>lte{T}</code> <code>(gvec2i, gvec2i) -&gt; gvec2b</code> Piecewise checks if the elements of the first vector are less than or equal to the second <code>lte{T}</code> <code>(gvec2f, gvec2f) -&gt; gvec2b</code> Piecewise checks if the elements of the first vector are less than or equal to the second <code>lte{T}</code> <code>(gvec3u, gvec3u) -&gt; gvec3b</code> Piecewise checks if the elements of the first vector are less than or equal to the second <code>lte{T}</code> <code>(gvec3i, gvec3i) -&gt; gvec3b</code> Piecewise checks if the elements of the first vector are less than or equal to the second <code>lte{T}</code> <code>(gvec3f, gvec3f) -&gt; gvec3b</code> Piecewise checks if the elements of the first vector are less than or equal to the second <code>lte{T}</code> <code>(gvec4u, gvec4u) -&gt; gvec4b</code> Piecewise checks if the elements of the first vector are less than or equal to the second <code>lte{T}</code> <code>(gvec4i, gvec4i) -&gt; gvec4b</code> Piecewise checks if the elements of the first vector are less than or equal to the second <code>lte{T}</code> <code>(gvec4f, gvec4f) -&gt; gvec4b</code> Piecewise checks if the elements of the first vector are less than or equal to the second <code>ggt{I, O}</code> <code>(I, I) -&gt; O</code> Manually constructs a greater than check on the provided inputs. You probably won't use this directly <code>gt</code> <code>(gu32, gu32) -&gt; gbool</code> Returns <code>true</code> if the first <code>gu32</code> is greater than the second <code>gt{T}</code> <code>(gu32, T) -&gt; gbool</code> Casts the second value to <code>gu32</code> and returns <code>true</code> if the first is greater than it <code>gt{T}</code> <code>(T, gu32) -&gt; gbool</code> Casts the first value to <code>gu32</code> and returns <code>true</code> if it is greater than the second <code>gt</code> <code>(gi32, gi32) -&gt; gbool</code> Returns <code>true</code> if the first <code>gi32</code> is greater than the second <code>gt{T}</code> <code>(gi32, T) -&gt; gbool</code> Casts the second value to <code>gi32</code> and returns <code>true</code> if the first is greater than it <code>gt{T}</code> <code>(T, gi32) -&gt; gbool</code> Casts the first value to <code>gi32</code> and returns <code>true</code> if it is greater than the second <code>gt</code> <code>(gf32, gf32) -&gt; gbool</code> Returns <code>true</code> if the first <code>gf32</code> is greater than the second <code>gt{T}</code> <code>(gf32, T) -&gt; gbool</code> Casts the second value to <code>gf32</code> and returns <code>true</code> if the first is greater than it <code>gt{T}</code> <code>(T, gf32) -&gt; gbool</code> Casts the first value to <code>gf32</code> and returns <code>true</code> if it is greater than the second <code>gt{T}</code> <code>(gvec2u, gvec2u) -&gt; gvec2b</code> Piecewise checks if the elements of the first vector are greater than the second <code>gt{T}</code> <code>(gvec2i, gvec2i) -&gt; gvec2b</code> Piecewise checks if the elements of the first vector are greater than the second <code>gt{T}</code> <code>(gvec2f, gvec2f) -&gt; gvec2b</code> Piecewise checks if the elements of the first vector are greater than the second <code>gt{T}</code> <code>(gvec3u, gvec3u) -&gt; gvec3b</code> Piecewise checks if the elements of the first vector are greater than the second <code>gt{T}</code> <code>(gvec3i, gvec3i) -&gt; gvec3b</code> Piecewise checks if the elements of the first vector are greater than the second <code>gt{T}</code> <code>(gvec3f, gvec3f) -&gt; gvec3b</code> Piecewise checks if the elements of the first vector are greater than the second <code>gt{T}</code> <code>(gvec4u, gvec4u) -&gt; gvec4b</code> Piecewise checks if the elements of the first vector are greater than the second <code>gt{T}</code> <code>(gvec4i, gvec4i) -&gt; gvec4b</code> Piecewise checks if the elements of the first vector are greater than the second <code>gt{T}</code> <code>(gvec4f, gvec4f) -&gt; gvec4b</code> Piecewise checks if the elements of the first vector are greater than the second <code>ggte{I, O}</code> <code>(I, I) -&gt; O</code> Manually constructs a greater than or equals check on the provided inputs. You probably won't use this directly <code>gte</code> <code>(gu32, gu32) -&gt; gbool</code> Returns <code>true</code> if the first <code>gu32</code> is greater than or equal to the second <code>gte{T}</code> <code>(gu32, T) -&gt; gbool</code> Casts the second value to <code>gu32</code> and returns <code>true</code> if the first is greater than or equal to it <code>gte{T}</code> <code>(T, gu32) -&gt; gbool</code> Casts the first value to <code>gu32</code> and returns <code>true</code> if it is greater than or equal to the second <code>gte</code> <code>(gi32, gi32) -&gt; gbool</code> Returns <code>true</code> if the first <code>gi32</code> is greater than or equal to the second <code>gte{T}</code> <code>(gi32, T) -&gt; gbool</code> Casts the second value to <code>gi32</code> and returns <code>true</code> if the first is greater than or equal to it <code>gte{T}</code> <code>(T, gi32) -&gt; gbool</code> Casts the first value to <code>gi32</code> and returns <code>true</code> if it is greater than or equal to the second <code>gte</code> <code>(gf32, gf32) -&gt; gbool</code> Returns <code>true</code> if the first <code>gf32</code> is greater than or equal to the second <code>gte{T}</code> <code>(gf32, T) -&gt; gbool</code> Casts the second value to <code>gf32</code> and returns <code>true</code> if the first is greater than or equal to it <code>gte{T}</code> <code>(T, gf32) -&gt; gbool</code> Casts the first value to <code>gf32</code> and returns <code>true</code> if it is greater than or equal to the second <code>gte{T}</code> <code>(gvec2u, gvec2u) -&gt; gvec2b</code> Piecewise checks if the elements of the first vector are greater than or equal to the second <code>gte{T}</code> <code>(gvec2i, gvec2i) -&gt; gvec2b</code> Piecewise checks if the elements of the first vector are greater than or equal to the second <code>gte{T}</code> <code>(gvec2f, gvec2f) -&gt; gvec2b</code> Piecewise checks if the elements of the first vector are greater than or equal to the second <code>gte{T}</code> <code>(gvec3u, gvec3u) -&gt; gvec3b</code> Piecewise checks if the elements of the first vector are greater than or equal to the second <code>gte{T}</code> <code>(gvec3i, gvec3i) -&gt; gvec3b</code> Piecewise checks if the elements of the first vector are greater than or equal to the second <code>gte{T}</code> <code>(gvec3f, gvec3f) -&gt; gvec3b</code> Piecewise checks if the elements of the first vector are greater than or equal to the second <code>gte{T}</code> <code>(gvec4u, gvec4u) -&gt; gvec4b</code> Piecewise checks if the elements of the first vector are greater than or equal to the second <code>gte{T}</code> <code>(gvec4i, gvec4i) -&gt; gvec4b</code> Piecewise checks if the elements of the first vector are greater than or equal to the second <code>gte{T}</code> <code>(gvec4f, gvec4f) -&gt; gvec4b</code> Piecewise checks if the elements of the first vector are greater than or equal to the second"},{"location":"built_ins/#gpgpu-conditional-functions","title":"GPGPU Conditional functions","text":"Name Type Description <code>if{T}</code> <code>(gbool, () -&gt; T, () -&gt; T) -&gt; T</code> Conditionally executes either the first or second function depending on the <code>gbool</code> value, returning the output of the function <code>if{T}</code> <code>(gbool, T, T) -&gt; T</code> Conditionally returns either the first or second value depending on the <code>gbool</code> value"},{"location":"built_ins/#gpgpu-boolean-and-bitwise-functions","title":"GPGPU Boolean and Bitwise functions","text":"Name Type Description <code>gnot{I}</code> <code>I -&gt; I</code> Manually constructs a boolean or bitwise not operation. You probably won't use this directly <code>not</code> <code>gu32 -&gt; gu32</code> Returns a bitwise not <code>not</code> <code>gi32 -&gt; gi32</code> Returns a bitwise not <code>not</code> <code>gbool -&gt; gbool</code> Returns a boolean not <code>not</code> <code>gvec2u -&gt; gvec2u</code> Returns a piecewise bitwise not <code>not</code> <code>gvec2i -&gt; gvec2i</code> Returns a piecewise bitwise not <code>not</code> <code>gvec2b -&gt; gvec2b</code> Returns a piecewise boolean not <code>not</code> <code>gvec3u -&gt; gvec3u</code> Returns a piecewise bitwise not <code>not</code> <code>gvec3i -&gt; gvec3i</code> Returns a piecewise bitwise not <code>not</code> <code>gvec3b -&gt; gvec3b</code> Returns a piecewise boolean not <code>not</code> <code>gvec4u -&gt; gvec4u</code> Returns a piecewise bitwise not <code>not</code> <code>gvec4i -&gt; gvec4i</code> Returns a piecewise bitwise not <code>not</code> <code>gvec4b -&gt; gvec4b</code> Returns a piecewise boolean not <code>gor{I}</code> <code>(I, I) -&gt; I</code> Manually constructs a boolean or bitwise or operation. You probably won't use this directly <code>or</code> <code>(gu32, gu32) -&gt; gu32</code> Returns a bitwise or <code>or{T}</code> <code>(gu32, T) -&gt; gu32</code> Casts the second value to <code>gu32</code> and performs a bitwise or operation <code>or{T}</code> <code>(T, gu32) -&gt; gu32</code> Casts the first value to <code>gu32</code> and performs a bitwise or operation <code>or</code> <code>(gi32, gi32) -&gt; gi32</code> Returns a bitwise or <code>or{T}</code> <code>(gi32, T) -&gt; gi32</code> Casts the second value to <code>gi32</code> and performs a bitwise or operation <code>or{T}</code> <code>(T, gi32) -&gt; gi32</code> Casts the first value to <code>gi32</code> and performs a bitwise or operation <code>or</code> <code>(gbool, gbool) -&gt; gbool</code> Returns a boolean or <code>or{T}</code> <code>(gbool, T) -&gt; gbool</code> Casts the second value to <code>gbool</code> and performs a boolean or operation <code>or{T}</code> <code>(T, gbool) -&gt; gbool</code> Casts the first value to <code>gbool</code> and performs a boolean or operation <code>or</code> <code>(gvec2u, gvec2u) -&gt; gvec2u</code> Performs a bitwise or piecewise across both vectors <code>or</code> <code>(gvec2i, gvec2i) -&gt; gvec2i</code> Performs a bitwise or piecewise across both vectors <code>or</code> <code>(gvec2b, gvec2b) -&gt; gvec2b</code> Performs a boolean or piecewise across both vectors <code>or</code> <code>(gvec3u, gvec3u) -&gt; gvec3u</code> Performs a bitwise or piecewise across both vectors <code>or</code> <code>(gvec3i, gvec3i) -&gt; gvec3i</code> Performs a bitwise or piecewise across both vectors <code>or</code> <code>(gvec3b, gvec3b) -&gt; gvec3b</code> Performs a boolean or piecewise across both vectors <code>or</code> <code>(gvec4u, gvec4u) -&gt; gvec4u</code> Performs a bitwise or piecewise across both vectors <code>or</code> <code>(gvec4i, gvec4i) -&gt; gvec4i</code> Performs a bitwise or piecewise across both vectors <code>or</code> <code>(gvec4b, gvec4b) -&gt; gvec4b</code> Performs a boolean or piecewise across both vectors <code>gand{I}</code> <code>(I, I) -&gt; I</code> Manually constructs a boolean or bitwise and operation. You probably won't use this directly <code>and</code> <code>(gu32, gu32) -&gt; gu32</code> Returns a bitwise and <code>and{T}</code> <code>(gu32, T) -&gt; gu32</code> Casts the second value to <code>gu32</code> and performs a bitwise and operation <code>and{T}</code> <code>(T, gu32) -&gt; gu32</code> Casts the first value to <code>gu32</code> and performs a bitwise and operation <code>and</code> <code>(gi32, gi32) -&gt; gi32</code> Returns a bitwise and <code>and{T}</code> <code>(gi32, T) -&gt; gi32</code> Casts the second value to <code>gi32</code> and performs a bitwise and operation <code>and{T}</code> <code>(T, gi32) -&gt; gi32</code> Casts the first value to <code>gi32</code> and performs a bitwise and operation <code>and</code> <code>(gbool, gbool) -&gt; gbool</code> Returns a boolean and <code>and{T}</code> <code>(gbool, T) -&gt; gbool</code> Casts the second value to <code>gbool</code> and performs a boolean and operation <code>and{T}</code> <code>(T, gbool) -&gt; gbool</code> Casts the first value to <code>gbool</code> and performs a boolean and operation <code>and</code> <code>(gvec2u, gvec2u) -&gt; gvec2u</code> Performs a bitwise and piecewise across both vectors <code>and</code> <code>(gvec2i, gvec2i) -&gt; gvec2i</code> Performs a bitwise and piecewise across both vectors <code>and</code> <code>(gvec2b, gvec2b) -&gt; gvec2b</code> Performs a boolean and piecewise across both vectors <code>and</code> <code>(gvec3u, gvec3u) -&gt; gvec3u</code> Performs a bitwise and piecewise across both vectors <code>and</code> <code>(gvec3i, gvec3i) -&gt; gvec3i</code> Performs a bitwise and piecewise across both vectors <code>and</code> <code>(gvec3b, gvec3b) -&gt; gvec3b</code> Performs a boolean and piecewise across both vectors <code>and</code> <code>(gvec4u, gvec4u) -&gt; gvec4u</code> Performs a bitwise and piecewise across both vectors <code>and</code> <code>(gvec4i, gvec4i) -&gt; gvec4i</code> Performs a bitwise and piecewise across both vectors <code>and</code> <code>(gvec4b, gvec4b) -&gt; gvec4b</code> Performs a boolean and piecewise across both vectors <code>gxor{I}</code> <code>(I, I) -&gt; I</code> Manually constructs a bitwise xor operation. You probably won't use this directly <code>xor</code> <code>(gu32, gu32) -&gt; gu32</code> Returns a bitwise xor <code>xor{T}</code> <code>(gu32, T) -&gt; gu32</code> Casts the second value to <code>gu32</code> and performs a bitwise xor operation <code>xor{T}</code> <code>(T, gu32) -&gt; gu32</code> Casts the first value to <code>gu32</code> and performs a bitwise xor operation <code>xor</code> <code>(gi32, gi32) -&gt; gi32</code> Returns a bitwise xor <code>xor{T}</code> <code>(gi32, T) -&gt; gi32</code> Casts the second value to <code>gi32</code> and performs a bitwise xor operation <code>xor{T}</code> <code>(T, gi32) -&gt; gi32</code> Casts the first value to <code>gi32</code> and performs a bitwise xor operation <code>xor</code> <code>(gvec2u, gvec2u) -&gt; gvec2u</code> Performs a bitwise xor piecewise across both vectors <code>xor</code> <code>(gvec2i, gvec2i) -&gt; gvec2i</code> Performs a bitwise xor piecewise across both vectors <code>xor</code> <code>(gvec3u, gvec3u) -&gt; gvec3u</code> Performs a bitwise xor piecewise across both vectors <code>xor</code> <code>(gvec3i, gvec3i) -&gt; gvec3i</code> Performs a bitwise xor piecewise across both vectors <code>xor</code> <code>(gvec4u, gvec4u) -&gt; gvec4u</code> Performs a bitwise xor piecewise across both vectors <code>xor</code> <code>(gvec4i, gvec4i) -&gt; gvec4i</code> Performs a bitwise xor piecewise across both vectors <code>gshl{I}</code> <code>(I, I) -&gt; I</code> Manually constructs a shift left operation. You probably won't use this directly <code>shl</code> <code>(gu32, gu32) -&gt; gu32</code> Returns the first value shifted left as specified by the second value <code>shl{T}</code> <code>(gu32, T) -&gt; gu32</code> Casts the second value to <code>gu32</code> and shifts the first value left as specified by the second <code>shl{T}</code> <code>(T, gu32) -&gt; gu32</code> Casts the first value to <code>gu32</code> and shifts it left as specified by the second value <code>shl</code> <code>(gi32, gi32) -&gt; gi32</code> Returns the first value shifted left as specified by the second value <code>shl{T}</code> <code>(gi32, T) -&gt; gi32</code> Casts the second value to <code>gu32</code> and shifts the first value left as specified by the second <code>shl{T}</code> <code>(T, gi32) -&gt; gi32</code> Casts the first value to <code>gu32</code> and shifts it left as specified by the second value <code>shl</code> <code>(gvec2u, gvec2u) -&gt; gvec2u</code> Performs a shift left piecewise shifting the first vector as specified by the second <code>shl</code> <code>(gvec2i, gvec2i) -&gt; gvec2i</code> Performs a shift left piecewise shifting the first vector as specified by the second <code>shl</code> <code>(gvec3u, gvec3u) -&gt; gvec3u</code> Performs a shift left piecewise shifting the first vector as specified by the second <code>shl</code> <code>(gvec3i, gvec3i) -&gt; gvec3i</code> Performs a shift left piecewise shifting the first vector as specified by the second <code>shl</code> <code>(gvec4u, gvec4u) -&gt; gvec4u</code> Performs a shift left piecewise shifting the first vector as specified by the second <code>shl</code> <code>(gvec4i, gvec4i) -&gt; gvec4i</code> Performs a shift left piecewise shifting the first vector as specified by the second <code>gshr{I}</code> <code>(I, I) -&gt; I</code> Manually constructs a shift right operation. You probably won't use this directly <code>shr</code> <code>(gu32, gu32) -&gt; gu32</code> Returns the first value shifted right as specified by the second value <code>shr{T}</code> <code>(gu32, T) -&gt; gu32</code> Casts the second value to <code>gu32</code> and shifts the first value right as specified by the second <code>shr{T}</code> <code>(T, gu32) -&gt; gu32</code> Casts the first value to <code>gu32</code> and shifts it right as specified by the second value <code>shr</code> <code>(gi32, gi32) -&gt; gi32</code> Returns the first value shifted right as specified by the second value <code>shr{T}</code> <code>(gi32, T) -&gt; gi32</code> Casts the second value to <code>gu32</code> and shifts the first value right as specified by the second <code>shr{T}</code> <code>(T, gi32) -&gt; gi32</code> Casts the first value to <code>gu32</code> and shifts it right as specified by the second value <code>shr</code> <code>(gvec2u, gvec2u) -&gt; gvec2u</code> Performs a shift right piecewise shifting the first vector as specified by the second <code>shr</code> <code>(gvec2i, gvec2i) -&gt; gvec2i</code> Performs a shift right piecewise shifting the first vector as specified by the second <code>shr</code> <code>(gvec3u, gvec3u) -&gt; gvec3u</code> Performs a shift right piecewise shifting the first vector as specified by the second <code>shr</code> <code>(gvec3i, gvec3i) -&gt; gvec3i</code> Performs a shift right piecewise shifting the first vector as specified by the second <code>shr</code> <code>(gvec4u, gvec4u) -&gt; gvec4u</code> Performs a shift right piecewise shifting the first vector as specified by the second <code>shr</code> <code>(gvec4i, gvec4i) -&gt; gvec4i</code> Performs a shift right piecewise shifting the first vector as specified by the second"},{"location":"built_ins/#gpgpu-bitcasting-functions","title":"GPGPU Bitcasting functions","text":"Name Type Description <code>gbitcast{I, O}</code> <code>I -&gt; O</code> Manually constructs a bitcast operation on the input. You probably won't use this directly <code>asU32</code> <code>gu32 -&gt; gu32</code> Returns the original value back <code>asU32</code> <code>gi32 -&gt; gu32</code> Bitcasts the <code>gi32</code> to a <code>gu32</code> <code>asU32</code> <code>gf32 -&gt; gu32</code> Bitcasts the <code>gf32</code> to a <code>gu32</code> <code>asI32</code> <code>gu32 -&gt; gi32</code> Bitcasts the <code>gu32</code> to a <code>gi32</code> <code>asI32</code> <code>gi32 -&gt; gi32</code> Returns the original value back <code>asI32</code> <code>gf32 -&gt; gi32</code> Bitcasts the <code>gf32</code> to a <code>gi32</code> <code>asF32</code> <code>gu32 -&gt; gf32</code> Bitcasts the <code>gu32</code> to a <code>gf32</code> <code>asF32</code> <code>gi32 -&gt; gf32</code> Bitcasts the <code>gi32</code> to a <code>gf32</code> <code>asF32</code> <code>gf32 -&gt; gf32</code> Returns the original value back <code>asVec2u</code> <code>gvec2u -&gt; gvec2u</code> Returns the original value back <code>asVec2u</code> <code>gvec2i -&gt; gvec2u</code> Bitcasts each <code>gi32</code> to a <code>gu32</code> <code>asVec2u</code> <code>gvec2f -&gt; gvec2u</code> Bitcasts each <code>gf32</code> to a <code>gu32</code> <code>asVec2i</code> <code>gvec2u -&gt; gvec2i</code> Bitcasts each <code>gu32</code> to a <code>gi32</code> <code>asVec2i</code> <code>gvec2i -&gt; gvec2i</code> Returns the original value back <code>asVec2i</code> <code>gvec2f -&gt; gvec2i</code> Bitcasts each <code>gf32</code> to a <code>gi32</code> <code>asVec2f</code> <code>gvec2u -&gt; gvec2f</code> Bitcasts each <code>gu32</code> to a <code>gf32</code> <code>asVec2f</code> <code>gvec2i -&gt; gvec2f</code> Bitcasts each <code>gi32</code> to a <code>gf32</code> <code>asVec2f</code> <code>gvec2f -&gt; gvec2f</code> Returns the original value back <code>asVec3u</code> <code>gvec3u -&gt; gvec3u</code> Returns the original value back <code>asVec3u</code> <code>gvec3i -&gt; gvec3u</code> Bitcasts each <code>gi32</code> to a <code>gu32</code> <code>asVec3u</code> <code>gvec3f -&gt; gvec3u</code> Bitcasts each <code>gf32</code> to a <code>gu32</code> <code>asVec3i</code> <code>gvec3u -&gt; gvec3i</code> Bitcasts each <code>gu32</code> to a <code>gi32</code> <code>asVec3i</code> <code>gvec3i -&gt; gvec3i</code> Returns the original value back <code>asVec3i</code> <code>gvec3f -&gt; gvec3i</code> Bitcasts each <code>gf32</code> to a <code>gi32</code> <code>asVec3f</code> <code>gvec3u -&gt; gvec3f</code> Bitcasts each <code>gu32</code> to a <code>gf32</code> <code>asVec3f</code> <code>gvec3i -&gt; gvec3f</code> Bitcasts each <code>gi32</code> to a <code>gf32</code> <code>asVec3f</code> <code>gvec3f -&gt; gvec3f</code> Returns the original value back <code>asVec4u</code> <code>gvec4u -&gt; gvec4u</code> Returns the original value back <code>asVec4u</code> <code>gvec4i -&gt; gvec4u</code> Bitcasts each <code>gi32</code> to a <code>gu32</code> <code>asVec4u</code> <code>gvec4f -&gt; gvec4u</code> Bitcasts each <code>gf32</code> to a <code>gu32</code> <code>asVec4i</code> <code>gvec4u -&gt; gvec4i</code> Bitcasts each <code>gu32</code> to a <code>gi32</code> <code>asVec4i</code> <code>gvec4i -&gt; gvec4i</code> Returns the original value back <code>asVec4i</code> <code>gvec4f -&gt; gvec4i</code> Bitcasts each <code>gf32</code> to a <code>gi32</code> <code>asVec4f</code> <code>gvec4u -&gt; gvec4f</code> Bitcasts each <code>gu32</code> to a <code>gf32</code> <code>asVec4f</code> <code>gvec4i -&gt; gvec4f</code> Bitcasts each <code>gi32</code> to a <code>gf32</code> <code>asVec4f</code> <code>gvec4f -&gt; gvec4f</code> Returns the original value back"},{"location":"built_ins/#cpu-and-gpgpu-miscellaneous-vector-functions","title":"CPU and GPGPU miscellaneous Vector functions","text":"Name Type Description <code>gevery{I}</code> <code>I -&gt; gbool</code> Manually constructs an every call on the input. You probably won't use this directly <code>every</code> <code>gvec2b -&gt; gbool</code> Returns <code>true</code> if every element of the vector is <code>true</code> <code>every</code> <code>gvec3b -&gt; gbool</code> Returns <code>true</code> if every element of the vector is <code>true</code> <code>every</code> <code>gvec4b -&gt; gbool</code> Returns <code>true</code> if every element of the vector is <code>true</code> <code>gsome{I}</code> <code>I -&gt; gbool</code> Manually constructs a some call on the input. You probably won't use this directly <code>some</code> <code>gvec2b -&gt; gbool</code> Returns <code>true</code> if any element of the vector is <code>true</code> <code>some</code> <code>gvec3b -&gt; gbool</code> Returns <code>true</code> if any element of the vector is <code>true</code> <code>some</code> <code>gvec4b -&gt; gbool</code> Returns <code>true</code> if any element of the vector is <code>true</code> <code>piecewiseIf{C, T}</code> <code>(C, T, T) -&gt; T</code> Manually constructs a piecewise if call on the input. You probably won't use this directly <code>if</code> <code>(gvec2b, gvec2u, gvec2u) -&gt; gvec2u</code> Returns a new vector selecting values from the last two vectors based on the value of the first <code>if</code> <code>(gvec2b, gvec2i, gvec2i) -&gt; gvec2i</code> Returns a new vector selecting values from the last two vectors based on the value of the first <code>if</code> <code>(gvec2b, gvec2f, gvec2f) -&gt; gvec2f</code> Returns a new vector selecting values from the last two vectors based on the value of the first <code>if</code> <code>(gvec2b, gvec2b, gvec2b) -&gt; gvec2b</code> Returns a new vector selecting values from the last two vectors based on the value of the first <code>if</code> <code>(gvec3b, gvec3u, gvec3u) -&gt; gvec3u</code> Returns a new vector selecting values from the last two vectors based on the value of the first <code>if</code> <code>(gvec3b, gvec3i, gvec3i) -&gt; gvec3i</code> Returns a new vector selecting values from the last two vectors based on the value of the first <code>if</code> <code>(gvec3b, gvec3f, gvec3f) -&gt; gvec3f</code> Returns a new vector selecting values from the last two vectors based on the value of the first <code>if</code> <code>(gvec3b, gvec3b, gvec3b) -&gt; gvec3b</code> Returns a new vector selecting values from the last two vectors based on the value of the first <code>if</code> <code>(gvec4b, gvec4u, gvec4u) -&gt; gvec4u</code> Returns a new vector selecting values from the last two vectors based on the value of the first <code>if</code> <code>(gvec4b, gvec4i, gvec4i) -&gt; gvec4i</code> Returns a new vector selecting values from the last two vectors based on the value of the first <code>if</code> <code>(gvec4b, gvec4f, gvec4f) -&gt; gvec4f</code> Returns a new vector selecting values from the last two vectors based on the value of the first <code>if</code> <code>(gvec4b, gvec4b, gvec4b) -&gt; gvec4b</code> Returns a new vector selecting values from the last two vectors based on the value of the first <code>pack4x8snorm</code> <code>gvec4f -&gt; gu32</code> Packs four floats from -1 to 1 into a singular <code>gu32</code> <code>pack4x8snorm</code> <code>f32[4] -&gt; u32</code> Packs four floats from -1 to 1 into a singular <code>u32</code> <code>pack4x8unorm</code> <code>gvec4f -&gt; gu32</code> Packs four floats from 0 to 1 into a singular <code>gu32</code> <code>pack4x8unorm</code> <code>f32[4] -&gt; u32</code> Packs four floats from 0 to 1 into a singular <code>u32</code> <code>pack2x16snorm</code> <code>gvec2f -&gt; gu32</code> Packs two floats (at half precision) from -1 to 1 into a singular <code>gu32</code> <code>pack2x16snorm</code> <code>f32[2] -&gt; u32</code> Packs two floats (at half precision) from -1 to 1 into a singular <code>u32</code> <code>pack2x16unorm</code> <code>gvec2f -&gt; gu32</code> Packs two floats (at half precision) from 0 to 1 into a singular <code>gu32</code> <code>pack2x16unorm</code> <code>f32[2] -&gt; u32</code> Packs two floats (at half precision) from 0 to 1 into a singular <code>u32</code> <code>pack2x16float</code> <code>gvec2f -&gt; gu32</code> Packs two floats (at half precision) into a singular <code>u32</code> <code>unpack4x8snorm</code> <code>gu32 -&gt; gvec4f</code> Unpacks four floats from -1 to 1 from a singular <code>gu32</code> <code>unpack4x8snorm</code> <code>u32 -&gt; f32[4]</code> Unpacks four floats from -1 to 1 from a singular <code>u32</code> <code>unpack4x8unorm</code> <code>gu32 -&gt; gvec4f</code> Unpacks four floats from 0 to 1 from a singular <code>gu32</code> <code>unpack4x8unorm</code> <code>u32 -&gt; f32[4]</code> Unpacks four floats from 0 to 1 from a singular <code>u32</code> <code>unpack2x16snorm</code> <code>gu32 -&gt; gvec2f</code> Unpacks two floats (at half precision) from -1 to 1 from a singular <code>gu32</code> <code>unpack2x16snorm</code> <code>u32 -&gt; f32[2]</code> Unpacks two floats (at half precision) from -1 to 1 from a singular <code>u32</code> <code>unpack2x16unorm</code> <code>gu32 -&gt; gvec2f</code> Unpacks two floats (at half precision) from 0 to 1 from a singular <code>gu32</code> <code>unpack2x16unorm</code> <code>u32 -&gt; f32[2]</code> Unpacks two floats (at half precision) from 0 to 1 from a singular <code>u32</code> <code>unpack2x16float</code> <code>gu32 -&gt; gvec2f</code> Unpacks two floats (at half precision) from a singular <code>u32</code>"},{"location":"built_ins/#gbuffer-specific-functions","title":"GBuffer-specific functions","text":"Name Type Description <code>storageBarrier</code> <code>() -&gt; storageBarrier</code> Special function that requires all parallel execution to synchronize after writing to a storage buffer. Intentionally broken by Metal (MacOS), use with caution <code>map{G, G2}</code> <code>(GBuffer, G -&gt; G2) -&gt; GBuffer</code> Construct a new GBuffer mapping the contents from one GPU type <code>G</code> to another <code>G2</code> <code>map{G, G2}</code> <code>(GBuffer, (G, gu32) -&gt; G2) -&gt; GBuffer</code> Construct a new GBuffer mapping the contents from one GPU type <code>G</code> to another <code>G2</code>, receiving the buffer index <code>gu32</code> as well"},{"location":"built_ins/#gpu-rendering-related-functions","title":"GPU rendering-related functions","text":"Name Type Description <code>window</code> <code>(Mut{(Mut{Window}) -&gt; ()}, Mut{(Mut{Window}) -&gt; u32[]}, Frame -&gt; GPGPU[]) -&gt; ()!</code> A special function that takes three callback functions, the first is for initially configuring the window to render, the second is run on each frame getting the current state of the window and generating the contents of a context buffer, and the third takes the rendering frame and returns a list of GPGPU shaders to execute and populate the framebuffer <code>width</code> <code>Window -&gt; u32</code> Returns the width (in pixels) of the rendering portion of the window (not including window decorations, if applicable) <code>height</code> <code>Window -&gt; u32</code> Returns the height (in pixels) of the rendering portion of the window (not including window decorations, if applicable) <code>bufferWidth</code> <code>Window -&gt; u32</code> Returns the width (in pixels) of the framebuffer backing the rendering portion of the window. This is usually slightly larger than the actual width, to reach a fixed interval of 64-bytes and make the buffer a valid GPU texture <code>mouseX</code> <code>Window -&gt; u32</code> The current X position (in pixels) of the mouse relative to the window's top-left corner, increasing from left to right <code>mouseY</code> <code>Window -&gt; u32</code> The current Y position (in pixels) of the mouse relative to the window's top-left corner, increasing from top to bottom <code>cursorVisible</code> <code>Mut{Window} -&gt; ()</code> A side-effect function that makes the mouse cursor visible when over the window <code>cursorInvisible</code> <code>Mut{Window} -&gt; ()</code> A side-effect function that makes the mouse cursor invisible when over the window <code>transparent</code> <code>Mut{Window} -&gt; ()</code> A side-effect function that makes the window rendering area transparent. Only safely callable during the initial configuration callback, but will work on some platforms in the per-frame window state callback function <code>opaque</code> <code>Mut{Window} -&gt; ()</code> A side-effect function that makes the window rendering area opaque. Pointless on most platforms since this is the default, but for platforms where this state can be updated per-frame, it can be used to disable transparency <code>runtime</code> <code>Window -&gt; u32</code> Returns the total amount of time the window has been running, in <code>f32</code> seconds, but given as a <code>u32</code> for convenience in inserting into the context array <code>context</code> <code>Frame -&gt; GBuffer{u32}</code> Returns the GPU buffer holding the context for the current frame as set up by the prior callback function on the CPU side <code>framebuffer</code> <code>Frame -&gt; GBuffer{u32}</code> Returns the GPU buffer that will be copied to the window. Actual rendering work goes here. Each pixel is a <code>u32</code> of packed 8-bit integers in BGRA order (at least on all hardware that has been tested so far; making this both efficient and easier is planned for the future) <code>pixel</code> <code>Frame -&gt;</code>gvec2u` Returns a representation of the current pixel X, Y coordinates the third callback is being required to render. For now properly assigning the right framebuffer index based on the pixel X, Y values is an exercise for the reader"},{"location":"built_ins/#process-exit-related-functions","title":"Process Exit-related functions","text":"Name Type Description <code>ExitCode</code> <code>u8 -&gt; ExitCode</code> Converts a <code>u8</code> into an exit code. <code>u8</code> directly maps to POSIX exit codes <code>ExitCode</code> <code>u16 -&gt; ExitCode</code> Converts a <code>u16</code> into an exit code. Only the first 8-bits are used <code>ExitCode</code> <code>u32 -&gt; ExitCode</code> Converts a <code>u32</code> into an exit code. Only the first 8-bits are used <code>ExitCode</code> <code>u64 -&gt; ExitCode</code> Converts a <code>u64</code> into an exit code. Only the first 8-bits are used <code>ExitCode</code> <code>i8 -&gt; ExitCode</code> Converts a <code>i8</code> into an exit code. Only the first 7-bits are used <code>ExitCode</code> <code>i16 -&gt; ExitCode</code> Converts a <code>i16</code> into an exit code. Only the first 8-bits are used <code>ExitCode</code> <code>i32 -&gt; ExitCode</code> Converts a <code>i32</code> into an exit code. Only the first 8-bits are used <code>ExitCode</code> <code>i64 -&gt; ExitCode</code> Converts a <code>i64</code> into an exit code. Only the first 8-bits are used"},{"location":"built_ins/#stdoutstderr-related-functions","title":"Stdout/stderr-related functions","text":"Name Type Description <code>print{T}</code> <code>T -&gt; ()</code> Converts the provided value into a string representation and feeds it to <code>stdout</code> with a newline appended <code>eprint{T}</code> <code>T -&gt; ()</code> Converts the provided value into a string representation and feeds it to <code>stderr</code> with a newline appended <code>stdout</code> <code>string -&gt; ()</code> Writes a raw string to <code>stdout</code> without any mutation <code>stderr</code> <code>string -&gt; ()</code> Writes a raw string to <code>stderr</code> without any mutation"},{"location":"built_ins/#testing-related-functions","title":"Testing-related functions","text":"<p>Note</p> <p>The testing functions only exist when running <code>alan test sourcefile.ln</code>. Under normal compilation these do not exist. The intention is to allow code to have a different behavior when compiled as a test and not require a separate set of test files.</p> Name Type Description Explicit <code>Testing</code> <code>Array{string} -&gt; Testing</code> Manual construction of a <code>Testing</code> type \u274c <code>Testing</code> <code>() -&gt; Testing</code> The normal way to initialize a new <code>Testing</code> type \u2705 <code>describe</code> <code>string -&gt; Testing</code> Construction of a <code>Testing</code> type by a fluent describe block \u2705 <code>describe</code> <code>(string, Testing -&gt; ()) -&gt; Testing</code> Construction of a <code>Testing</code> type by a callback-style describe block \u2705 <code>describe</code> <code>(string, Testing -&gt; Testing) -&gt; Testing</code> Construction of a <code>Testing</code> type by a one-liner callback-style describe block \u2705 <code>describe</code> <code>(Testing, string) -&gt; Testing</code> Adding a new fluent describe block to a <code>Testing</code> value \u2705 <code>describe</code> <code>(Testing, string, Testing -&gt; ()) -&gt; Testing</code> Adding a new callback-style describe block to a <code>Testing</code> value \u2705 <code>describe</code> <code>(Testing, string, Testing -&gt; Testing) -&gt; Testing</code> Adding a new one-liner callback-style describe block to a <code>Testing</code> value \u2705 <code>it</code> <code>(Testing, string) -&gt; Testing</code> Adding a new fluent it block to a <code>Testing</code> value \u2705 <code>it</code> <code>(Testing, string, Testing -&gt; ()) -&gt; Testing</code> Adding a new callback-style it block to a <code>Testing</code> value \u2705 <code>it</code> <code>(Testing, string, Testing -&gt; Testing) -&gt; Testing</code> Adding a new one-liner call-back style it block to a <code>Testing</code> value \u2705 <code>assert{T}</code> <code>(Testing, (T, T) -&gt; bool, T, T) -&gt; Testing</code> Adding an assertion to the <code>Testing</code> value. Second arg is the comparator fn for the actual (3rd) and expected (4th) values \u2705 <code>report</code> <code>Testing -&gt; ()</code> Report the result of the test \u2705"},{"location":"built_ins/#operators","title":"Operators","text":"<p>Like the Type Operators above, the built-in types in Alan are bound to functions by name, specifying the symbol, precedence and prefix/infix/postfix type. Prefix and Postfix are for functions that take only one argument while Infix are for functions that take two arguments. Functions with the same name but the wrong number of arguments will not be bound to an operator. Generic functions that have the same name may also be bound by the name, but only if the generic types can be inferred automatically from the input argument types. Generic functions that cannot be inferred will never be bound into an operator.</p> <p>Also like the Type Operators, you cannot export the operator definitions, but you can define new operator definitions with a single line and you can define new functions with the same name as an existing operator, so you can overload them easily.</p> Name -fix Symbol Precedence <code>add</code> Infix <code>+</code> 5 <code>sub</code> Infix <code>-</code> 5 <code>neg</code> Prefix <code>-</code> 8 <code>mul</code> Infix <code>*</code> 6 <code>cross</code> Infix <code>&gt;&lt;</code> 6 <code>dot</code> Infix <code>*.</code> 6 <code>div</code> Infix <code>/</code> 6 <code>mod</code> Infix <code>%</code> 6 <code>pow</code> Infix <code>**</code> 7 <code>and</code> Infix <code>&amp;</code> 3 <code>and</code> Infix <code>&amp;&amp;</code> 3 <code>or</code> Infix <code>|</code> 2 <code>or</code> Infix <code>||</code> 2 <code>getOr</code> Infix <code>??</code> 8 <code>getOrExit</code> Postfix <code>!!</code> 8 <code>Maybe</code> Postfix <code>?</code> 9 <code>Fallible</code> Postfix <code>!</code> 9 <code>xor</code> Infix <code>^</code> 2 <code>not</code> Prefix <code>!</code> 4 <code>nand</code> Infix <code>!&amp;</code> 3 <code>nor</code> Infix <code>!|</code> 2 <code>xnor</code> Infix <code>!^</code> 2 <code>eq</code> Infix <code>==</code> 4 <code>neq</code> Infix <code>!=</code> 4 <code>lt</code> Infix <code>&lt;</code> 4 <code>lte</code> Infix <code>&lt;=</code> 4 <code>gt</code> Infix <code>&gt;</code> 4 <code>gte</code> Infix <code>&gt;=</code> 4 <code>len</code> Infix <code>#</code> 1 <code>shl</code> Infix <code>&lt;&lt;</code> 5 <code>shr</code> Infix <code>&gt;&gt;</code> 5 <code>wrl</code> Infix <code>&lt;&lt;&lt;</code> 5 <code>wrr</code> Infix <code>&gt;&gt;&gt;</code> 5 <code>store</code> Infix <code>=</code> 0"},{"location":"other/","title":"Other?","text":""},{"location":"overview/","title":"An Overview of Alan","text":"<p>If you've written code in a popular, high-level typed programming language like Typescript, Swift, Rust, and to a less extent a class-based language like C#, it should be pretty easy to get up-to-speed with Alan.</p>"},{"location":"overview/#properties-of-the-language","title":"Properties of the Language","text":"<p>Alan is strictly-typed, with a type system based on the Curry-Howard correspondence. This means values are not nullable by default, though you can explicitly add that back in with the <code>Maybe{T}</code> generic type (using Julia's generic syntax style to allow <code>&lt;</code> and <code>&gt;</code> to be used as operators in the type system, more on that later), or simply combine it with the Typescript-style <code>myType | void</code> enumeration.</p>"},{"location":"overview/#memory","title":"Memory","text":"<p>Memory allocation and deallocation is handled for you, and values are passed-by-reference to functions, though you can <code>var.clone()</code> any variable to make sure you're working with a separate copy.</p>"},{"location":"overview/#functions","title":"Functions","text":"<p>Functions are currently fully typed, with the form <code>fn optionalName (arg1: Type1, arg2: Type2) -&gt; ReturnType</code>, while a function type for higher-order functions (functions that are passed other functions to call) is just the type portion: <code>(Type1, Type2) -&gt; ReturnType</code>. The return type can be inferred for all function definitions except when binding into the platform language (where the inference logic doesn't work). The function type used by higher-order functions always requires the return type to be specified. For function definitions that the return type can be inferred, it still is, with the return type acting as a compiler check and allowing the compiler to indicate the expected and actual return type to you.</p>"},{"location":"overview/#variables","title":"Variables","text":"<p>Variable declarations are type inferred, however. You can just <code>let foo = 5;</code> or <code>const bar = \"bay\";</code> and it will determine the correct type for the variable. Unlike most languages that have type inference for variables, there are no exceptions here: it will always infer the correct type for the variable. How? This is because Alan is not a true Turing-complete language.</p>"},{"location":"overview/#no-recursion-unbounded-iteration","title":"No Recursion / Unbounded Iteration","text":"<p>Alan does not allow recursive functions or types (though you are allowed to <code>bind</code> such things fromm the host language), and it only has guarded looping constructs, such as calling <code>map</code> on <code>Array</code>s, but no generalized <code>while</code> or <code>for</code> loops.</p> <p>Because of this (and because bound functions and types are required to be fully typed on Alan's side), the impact on the typing of variable is fully discovered during compilation, so you never need to specify the type. You are allowed to do, so, though, as an assertion to the compiler to fail if the generated type does not match your expectations.</p>"},{"location":"overview/#generic-types-and-functions","title":"Generic Types and Functions","text":"<p>Types and Functions can be generic, which allows the \"realization\" of the concrete type or function to happen later. Like Rust, these generic types and functions produce distinct types and functions afterwards, so a generic function operating on 100 different types in your codebase will generate 100 different functions in the resulting binary.</p>"},{"location":"overview/#conditional-compilation-generic-keywords","title":"Conditional Compilation / Generic Keywords","text":"<p>Unlike most languages, the top-level keywords in an Alan source file are optionally generic, accepting a compile-time boolean to determine whether or not they are actually evaluated during compilation. This is combined with compile-time types to access files and environment variables and perform comparisons within the type system to enable conditional compilation, such as <code>fn{Test} ...</code> to define a function that only exists when <code>alan test ...</code> is run, or <code>type{Windows} ...</code> to define a platform-specific variant of a type.</p> <p>All top-level keywords have this feature, but the keywords within a function or type definition do not, but you can simply define the same function or type twice, once for the default and once for the optional variant, where the variant can override the default definition, based on the order it appears in the evaluation.</p>"},{"location":"overview/#function-and-type-dispatch","title":"Function (and Type) Dispatch","text":"<p>In Alan, duplicate definitions have a simple tie-breaker: the most recent definition (furthest down the source file) wins. So if you were to make a Windows-specific type or function, you would define it after you define the default case.</p> <p>But what is considered a duplicate is more fine-grained than most languages. In most languages you can only define a specific function name once, but Alan's function dispatch also considers the input argument types when choosing a function to call, so you can define an <code>fn add(a: i64, b: i64) -&gt; i64 ...</code> and an <code>fn add(a: i32, b: i32) -&gt; i32</code> and they will not collide with each other, both can be used based on the input arguments given.</p>"},{"location":"overview/#closure-functions","title":"Closure Functions","text":"<p>Closure functions exist in Alan, but with a slight twist: they enclose external variables, but the references to the enclosed variables are immutable. If you want to mutate the value you must first <code>clone</code> it, which then guarantees that it will not affect the value in the outer scope. This makes closures more \"pure\" and also makes it possible to use them in parallel algorithms, which you can explicitly opt into swapping <code>map</code> with <code>parmap</code>, and the intention is to automatically swap when the compiler can be sure there will be a performance benefit.</p>"},{"location":"overview/#modules","title":"Modules","text":"<p>Alan uses a module-style of code organization, with each source file being a different module, where these files are able to export values for use by other modules and import values from other modules. The module resolution logic of the Alan compiler makes defining overrides for your own dependencies simpler (more on that later), and combined with the conditional compilation above, it's trivial to swap out for mocks of your dependencies by having an <code>import{Test}</code> statement after your <code>import</code> statement.</p>"},{"location":"overview/#methods-and-operators-as-syntactic-sugar","title":"Methods and Operators as Syntactic Sugar","text":"<p>And that's it for the foundation of the language. The rest of the features of the language are simply syntactic sugar. When you call a function on a variable, you could call it as <code>foo(bar)</code> or <code>bar.foo()</code> or even <code>bar.foo</code> (because that function is effectively a property of the input variable, and this is actually how all struct-like variable properties are implemented under the hood, with the compiler then recognizing and rewriting back to the simple pointer offset arithmetic later).</p> <p>If the <code>foo</code> function was bound to a prefix or postfix operator, say <code>@</code>, you could also call it as <code>@bar</code> or <code>bar@</code> and that will also call the function.</p> <p>Two argument functions can be called with <code>foo(bar, baz)</code> or <code>bar.foo(baz)</code>, and if bound to an infix <code>@</code> as <code>bar @ baz</code>.</p>"},{"location":"overview/#type-operators-also-syntactic-sugar","title":"Type Operators also Syntactic Sugar","text":"<p>Types work similarly. A type defined <code>Foo{T}</code> can be called as <code>Foo{Bar}</code> or it could be bound to a type prefix or postfix operator, say <code>@</code>, and become <code>@Bar</code> or <code>Bar@</code>. And a two-arg type <code>Foo{A, B}</code> can be called as <code>Foo{Bar, Baz}</code> or bound to an infix operator, say <code>@</code>, and become <code>Bar @ Baz</code>. There is no method syntax for types right now, but could easily be added if desired.</p> <p>In fact, all of the type syntax is built on top of just this: <code>|</code> is just an operator for the <code>Either{A, B}</code> type to construct a sum type, and even <code>,</code> is an operator for the <code>Tuple{A, B}</code> type to construct a product type, etc.</p>"},{"location":"overview/#type-constructors-and-accessors-are-just-functions","title":"Type Constructors and Accessors are just Functions","text":"<p>When you want to construct a struct-like product type, such as:</p> A simple product type<pre><code>type Foo =\n  bar: i64,\n  baz: string;\n</code></pre> <p>You simply use the type name as a function, with the arguments matching the types of the <code>Tuple</code>: <code>let foo = Foo(5, 'baz')</code>. To access the values out of it, the <code>Field</code> names are used, eg <code>foo.bar</code> or <code>baz(foo)</code> to access it.</p> <p>For sum types such as:</p> A simple sum type<pre><code>type Foo = i64 | string;\n</code></pre> <p>You construct it by passing one or the other value type: <code>let foo1 = Foo(5); let foo2 = Foo(\"baz\");</code>. Then you can get the integer by calling <code>foo1.i64.getOrExit</code>.</p> <p>This one is a bit more complicated. Since the type can be either an <code>i64</code> or a <code>string</code>, when you call the <code>i64</code> property it can't always return an <code>i64</code>. It instead returns an <code>i64?</code> (or <code>Maybe{i64}</code> or <code>i64 | void</code>). The <code>Maybe{T}</code> type has a <code>getOrExit</code> function that will return the wrapped value or terminate the program if it is not present.</p> <p>You could also call <code>foo1.i64.getOr(3)</code> for a non-terminating call where you provide a default value if the desired value is not present, and you can call <code>foo1.i64.exists</code> to return a boolean <code>true</code> or <code>false</code> to decide whether or not <code>foo1</code> has an <code>i64</code> value or not, which you can use in a conditional statement, instead.</p> <p>All of the foundational types produce constructors and accessors to work with them, and as they are all standard functions in the language, you can use them as methods or even operators in certain circumstances, eg <code>5?</code> immediately creates a <code>Maybe{i64}</code> with a value of <code>5</code> stored within it.</p> <p>But what if you wanted to construct a type without giving it a name to call? The type operators overlap (significantly) with the normal operators within a function, so to eliminate the ambiguity, an inline-defined type needs to be wrapped with <code>{}</code> when constructing it, eg <code>{i64 | string}(5)</code> produces the same sum type with a value of <code>5</code>.</p> <p>Generic types can be called without the outer <code>{}</code> if called by name instead of operator, eg <code>Array{i64}(1, 2, 3)</code> works and is equivalent to <code>{i64[]}(1, 2, 3)</code>.</p> <p>Generic type constructor functions (as well as generic functions) can sometimes have their generic type inferred (only when the generic types can be inferred from the input argument types and do not depend on the return type). This is true for Arrays, so you could also just write <code>Array(1, 2, 3)</code> in this case.</p>"},{"location":"overview/#syntax-as-syntactic-sugar","title":"Syntax as Syntactic Sugar","text":"<p>Many other syntactic constructs in the language are also syntactic sugar.</p> <p>Arrays can be defined with <code>[val1, val2, ...]</code> syntax instead of <code>Array{i64}(val1, val2, ...)</code>.</p> <p>Arrays can be accessed with <code>myArray[myIndex]</code> in place of <code>myArray.get(myIndex)</code>. Unlike in Rust, these are identical so you will need to unwrap the <code>Maybe{T}</code> that it returns, but you can opt into the \"crash on error\" by slapping <code>.getOrExit</code> on the end.</p> <p>This bracket accessor syntax works for three-or-more arguments, as well. A <code>myMatrix[col, row]</code> would be equivalent to <code>myMatrix.get(col, row)</code>, making matrix operations clearer and more idiomatic.</p> <p>Re-assignment to a variable with <code>foo = bar</code> is equivalent to <code>foo.store(bar)</code>. (Not <code>set</code> so as not to be confused with the <code>Set</code> constructor function for sets. So the re-assignment could itself return a value, which could then be operated on, such as determining if the assignment actually succeeded with a <code>Fallible{T}</code> return type.</p> <p>It is planned for conditionals to also have such syntactic sugar, with <code>if conditional { trueStatements; } else { falseStatements }</code> being transformed into <code>cond(conditional, fn { trueStatements; }, fn { falseStatements })</code> (with rewriting conditional returns to absorb the statements following the conditional in the non-return branch, as all functions in Alan must execute every statement). But for now there is only the set of <code>cond</code> functions you can call for conditional logic. (May or may not rename <code>cond</code> to <code>if</code>, as well.)</p> <p>A <code>for .. in</code> syntax is not planned, because while it would still be controlled, it would heavily imply that mutation of the outer scope is allowed, which makes automatic parallelization of the loop impossible due to the state dependency between iterations that would fail when execution order is no longer guaranteed. It feels like a potential footgun for those familiar with other languages to have the syntax but have it work differently to the other languages, though with it being blocked at compile time, I am not 100% against it and could be convinced to add it.</p>"},{"location":"overview/#extensible-syntax-behavior","title":"Extensible Syntax Behavior","text":"<p>Because the vast majority of syntax just boils down to function calls (operators, array accessors, conditionals), and functions are dispatched by name and argument types, it is easy to alter the behavior of the syntax as you see fit. If you want to make string concatenation use <code>+</code>, you just need to define <code>fn add(a: string, b: string) = a.concat(b);</code> and now any module that has this in scope will allow <code>'Hello, ' + \"World!\"</code> to just work.</p> <p>Alan uses this for the GPGPU-related types. An <code>i32</code> is a 4-byte integer value, while a <code>gi32</code> is a complex type representing the AST to generate a WGSL shader. There are three <code>add</code> functions defined with that <code>gi32</code> type in mind. <code>fn add(a: gi32, b: gi32) -&gt; gi32</code> to produce an updated shader AST combining the AST fragments of the other two <code>gi32</code>s, while <code>fn add(a: gi32, b: i32) -&gt; gi32</code> and <code>fn add(a: i32, b: gi32) -&gt; gi32</code> lets you seamlessly mix in some \"normal\" integers you computed on the CPU into the shader definition without needing to explicitly cast it.</p>"},{"location":"overview/#minimized-extensibility-blast-radius","title":"Minimized Extensibility Blast Radius","text":"<p>This is not such a big deal, but there's also extra functionality for <code>cond</code> to accept a <code>gbool</code> conditional type instead of just a <code>bool</code> type, and this one behaves very differently: At AST generation time, we can't know which path will be followed on the GPU; in fact, we probably want it to follow both paths across the entire set of data we're operating on depending on the particular value, so this <code>cond</code> evaluates both the true and false callbacks and returns a new AST node to produce the conditional we want the GPU to execute.</p> <p>There is no ALGOL-like language (that I am aware of) that allows for this kind of extensibility to the meaning of the syntax. This kind of extensibility can be abused, but it is also the only way to truly integrate GPU and CPU computing seamlessly.</p> <p>But unlike other languages that have attempted to allow this kind of extensibility, Alan keeps the \"blast radius\" much lower -- you have to opt-in to the behavior by either writing the function yourself or explicitly <code>import</code>ing the function that overrides the syntax behavior, so it's very clear to anyone reading the code what might be different from what you're expecting.</p>"},{"location":"overview/#maximized-fluency","title":"Maximized Fluency","text":"<p>Unlike prototype pollution in Javascript, adding a new method to a type you're working with in the current source file has zero impact on what methods are available to that same type in a different file. There is no risk of accidentally altering the behavior of code far away from where the new behavior was added, but all of the benefits of being able to easily execute methods or access \"properties\" from a type that weren't included in the original definition as a developer persist, and the explicitness within the language's grammar about this makes figuring out what such-and-such method does trivial.</p> <p>If you've defined a new type and want array accessor syntax to work for it, you just need to define a <code>get</code> function and then it just works. If you're a developer looking at array accessor syntax, you know you just need to find the <code>get</code> functions for that type to see what it's actually doing under-the-hood.</p> <p>If you've created a union type, say <code>type maybeStrInt = string | i64 | void</code>, you've set the initial definition to <code>void</code> with a bare construction: <code>let myVal = maybeStrInt();</code> and later on you re-assign <code>myVal = 5;</code>, you know that the automatically-generatd <code>store</code> function for the <code>maybeStrInt</code> type defined the store functions of: <code>fn store(a: maybeStrInt, b: maybeStrInt)</code>, <code>fn store(a: maybeStrInt, b: string)</code>, <code>fn (a: maybeStrInt, b: i64)</code>, and <code>fn (a: maybeStrInt)</code> (last one for the <code>void</code> path) so you can easily update the value and have it auto-cast wrap into your type.</p> <p>You can make the code as terse as you want, but you are required to leave an explicit declaration in your code somewhere such that anyone familiar with the small core of rules for Alan's syntax can see what you did, and these changes cannot infect any other source file without an explicit opt-in via an <code>import</code> statement at the top.</p> <p>Teams can go as deep as they want on their own DSL without needing to worry much on getting new developers up to speed.</p>"},{"location":"standard_library/","title":"The Standard Library","text":"<p>Alan is still very early in development, so the standard library outside of the root scope is still very bare bones. There are only two standard library modules you can import: <code>@std/fs</code> and <code>@std/seq</code>. The number of types and functions defined in these is also very minimal at the moment.</p>"},{"location":"standard_library/#stdfs","title":"<code>@std/fs</code>","text":"<p>This is the standard library for working with the filesystem.</p>"},{"location":"standard_library/#types","title":"Types","text":"Type Description <code>File</code> Represents a file in the file system"},{"location":"standard_library/#functions","title":"Functions","text":"Name Type Description Explicit <code>File</code> <code>string -&gt; File</code> Takes the path to a file and returns a <code>File</code> type. Performs no validation on construction (the file could be deleted between type construction and access, so it's just all deferred to when it is used) \u274c <code>string</code> <code>File -&gt; string!</code> Reads the contents of the file to a string, or fails if the file does not exist or is not readable \u2705"},{"location":"standard_library/#stdseq","title":"<code>@std/seq</code>","text":"<p>This is the standard library for performing sequential computation. It's isolated from the core of the language because mistakes with these tools can lead to infinite loops, deadlocks, etc. Most of the time, you don't need it as the built-in controlled iterative tools that <code>Buffer</code>, <code>Array</code>, <code>Dict</code>, <code>Set</code>, and <code>Tree</code> have are all you need.</p> <p>There are no new types here, only functions.</p>"},{"location":"standard_library/#functions_1","title":"Functions","text":"Name Type Description <code>while</code> <code>(() -&gt; bool, () -&gt; ()) -&gt; ()</code> This provides a classic while loop functionality, but through a slightly functional notation. The first function is executed at the beginning of the loop to determine if the second function will be executed and then return to the first function again, or if it will exit the loop. The second function is the loop body. Both of these functions rely on closures mutating state to work correctly. <code>iter{T}</code> <code>(Mut{i64 -&gt; T}, i64) -&gt; T[]</code> This provides a common pattern usually implemented with a for loop: an iterator. The function body accepts the iterator index value from 0 to one less than the provided maximum value and is executed that many times. It's return value is stored into an array. The callback is marked mutable so it can mutate the outer scope (not that it can mutate the iterator value) <code>iter</code> <code>(Mut{i64 -&gt; ()}, i64) -&gt; ()</code> This is a slightly optimized version of the iterator above, but it does not build an array if the callback function does not return anything. When writing looping, mutable code, this can often be the case, so the optimization is worth it."},{"location":"blog/","title":"Articles","text":""},{"location":"getting_started/","title":"Getting Started","text":"<p>It is planned to have a web compiler in the future to automatically generate Javascript that can be evaluated and run, which would allow you to try out Alan with zero steps, but for now, you need to install it from source.</p>"},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust v1.76.0 or higher (recommend rustup to install this)</li> <li>Git (Windows users should probably use this, Mac and Linux users ought to know how to install git)</li> </ul>"},{"location":"getting_started/#source-installation","title":"Source Installation","text":"<p>Currently, the only way to install <code>alan</code> is to build it from source:</p> Installation shell commands<pre><code>git clone https://github.com/alantech/alan\ncd alan\ncargo install --path .\n</code></pre>"},{"location":"getting_started/#usage","title":"Usage","text":"<p>Let's make a Hello, World! program:</p> Hello World shell commands<pre><code>echo 'export fn main = print(\"Hello, World!\");' &gt; hello_world.ln\nalan compile hello_world.ln\n./hello_world\n</code></pre> <p>This should print something like:</p> <pre><code>Done! Took 1.13sec\nHello, World!\n</code></pre> <p>The first line being the compiler telling you how long it took to build the program and the second line being the actual program output.</p>"},{"location":"learn_alan/","title":"Learn Alan","text":"<p>Let's go through some examples of Alan code, starting from the classic <code>\"Hello, World!\"</code> to advanced types and GPGPU computing.</p>"},{"location":"learn_alan/#hello-world","title":"Hello, World!","text":"<p>In Alan, you write to the terminal with <code>print</code>, and the entry point to all Alan programs is a function named <code>main</code> that must be <code>export</code>ed so it is public and callable. It can look like this:</p> <pre><code>export fn main() {\n  print(\"Hello, World!\");\n}\n</code></pre> <p>The function takes no arguments and we didn't declare what it returns, but we could have declared that it returned nothing by instead writing:</p> <pre><code>export fn main() -&gt; void {\n  print(\"Hello, World!\");\n}\n</code></pre> <p><code>void</code> is itself a simple alias for <code>()</code> - a grouping of nothing, which coincidentally is what the arguments were, making this the same thing:</p> <pre><code>export fn main() -&gt; () {\n  print(\"Hello, World!\");\n}\n</code></pre> <p>When a function takes no input and returns no output (making it a purely side-effect function), we can elide all of that type information and just write:</p> <pre><code>export fn main {\n  print(\"Hello, World!\");\n}\n</code></pre> <p>And when a function consists of a single statement, we can state that the function is equal to that statement, and we can reduce it to just:</p> <pre><code>export fn main = print(\"Hello, World!\");\n</code></pre> <p>Which is the version of the <code>\"Hello, World!\"</code> program included in the Getting Started guide.</p>"},{"location":"learn_alan/#method-and-property-syntax","title":"Method and Property Syntax","text":"<p>In Alan, there are no methods on classes or properties on types. There are only functions. But you can choose to use any function with method syntax if that improves the legibility, and certain functions can be used with property syntax, which is a special case of method syntax.</p> <p>Method syntax allows you to specify the first argument, followed by a dot (<code>.</code>), then followed by the function name and parenthesis.</p> <pre><code>export fn main {\n  \"Hello, World!\".print();\n}\n</code></pre> <p>If there's more than one argument to a function, the remaining arguments are included in the parenthesis.</p> <pre><code>export fn main {\n  1.add(2).print(); // Prints 3\n}\n</code></pre> <p>When the function takes a single argument, it may also be used in property syntax, where the parenthesis are elided.</p> <pre><code>export fn main = \"Hello, World!\".print;\n</code></pre> <p>This makes more sense for the accessor functions on your types, but can also be useful to allow a \"property\" to continue to exist for a type even when the value is no longer directly stored in the type.</p>"},{"location":"learn_alan/#variables","title":"Variables","text":"<p>In Alan, variables are declared with <code>let</code> and <code>const</code>. <code>let</code> variables may have their value changed, while <code>const</code> variables are immutable the moment they are assigned. This means <code>let</code> variables can be re-assigned, while <code>const</code> cannot.</p> <pre><code>export fn main {\n  let message = \"Hello, World!\"; // Ok\n  print(message); // Prints Hello, World!\n  const response = \"Hello to you, developer!\"; // Ok\n  print(response); // Prints Hello to you, developer!\n  message = \"Goodbye, World!\"; // Ok\n  print(message); // Prints Goodbye, World!\n  response = \"Goodbye, developer!\"; // Compiler error\n  ...\n</code></pre> <p>Tip</p> <p>For developers coming from Javascript, the behavior of <code>const</code> is stricter. Even if you don't re-assign the variable but instead just wish to mutate it, like <code>pop</code>ing a value off of an array, a variable defined <code>const</code> will fail to compile in that situation.</p> <p>There is a built-in <code>clone</code> function in Alan that lets you make a copy of any variable, so if you find yourself wanting to mutate a value that was provided as a <code>const</code>, you can simply <code>let</code> assign its <code>clone</code>.</p> <pre><code>let myMutableVariable = myConstant.clone();\n</code></pre>"},{"location":"learn_alan/#mutable-arguments","title":"Mutable Arguments","text":"<p>Relatedly, when you pass variables to a function in Alan, that function can declare whether or not it wants to mutate the variable while running. In that case, either a bare value needs to be passed in at this point (and the mutation ignored), or the variable passed in must be a <code>let</code> variable, not a <code>const</code>.</p> <p>By default all functions in Alan get their own copies of the variables passed in, so if they mutate it but do not return that mutation, the mutation is lost after the function call is complete.</p> <p>If you want that mutation to persist past the function call and don't want to make it the return value, you must declare that you are mutating the original variable by wrapping the variable's type in <code>Mut{T}</code>.</p> <pre><code>fn increment(a: Mut{i64}, b: i64) {\n  a = a.clone() + b;\n}\n\nexport fn main {\n  let five = 3;\n  five.print;\n  five.increment(2);\n  five.print;\n}\n</code></pre> <p>which will print 3, followed by 5. In this example, <code>i64</code> is the \"primitive type\" of the integers, and <code>Mut{i64}</code> is a realized \"generic type\" indicating that we want to be able to mutate the integer that was passed into our function. We'll go over all of these, starting with primitive types.</p> <p>Note</p> <p>Arguments in Alan are conceptually call-by-value by default, though it passes immutable references (<code>&amp;</code>) when compiling via Rust rather than full copies of the data. If the variable is mutated within that scope then it will make a copy of that variable via <code>clone</code> instead of producing a compiler error as Rust would do in a similar circumstance. All arguments to a function are treated as if they were <code>let</code> bound.</p> <p>When <code>Mut{T}</code> is applied to an argument it switches semantically to call-by-reference, using a mutable reference (<code>&amp;mut</code>) when compiling via Rust.</p> <p>Alan does not generate functions that take ownership of the provided argument like Rust does, primarily because this concept is foreign to most developers, but the function binding logic does support calling functions implemented in Rust that do this via the <code>Own{T}</code> generic type. Under the hood it is calling <code>clone</code> for you automatically to prevent an unexpected semantic drift, though that may be optimized away if you never use that variable again in a future version of the compiler.</p>"},{"location":"learn_alan/#primitive-types","title":"Primitive Types","text":"<p>Alan has many built-in types, but a few of them are considered \"primitive.\" These are types that have a special representation in the language itself: <code>int</code>, <code>float</code>, <code>bool</code>, <code>string</code>, and <code>void</code>.</p> <p>Note</p> <p><code>int</code> and <code>float</code> are currently actually <code>i64</code> and <code>f64</code>. It is planned to have automatic coercion of the integer and float syntactic constructs into the \"best\" int and float type as determined by type inference, but this has not yet been done. They are always automatically coerced to their 64-bit representations and the user must explicitly cast to a smaller type if desired.</p>"},{"location":"learn_alan/#integers","title":"Integers","text":"<p>Integers in Alan have several different valid representations: Base 10, Base 2, Base 8, and Base 16.</p> <p>Base 10 are simply the regular 10 digits, <code>0..9</code> in any order desired.</p> <pre><code>let five = 5;\n</code></pre> <p>Base 2, 8, and 16 require a leading <code>0</code> followed by <code>b</code>, <code>o</code>, and <code>x</code>, respectively, and then the digits involved.</p> <pre><code>let two     = 0b10;\nlet eight   = 0o10;\nlet sixteen = 0x10;\n</code></pre> <p>For all of the integer types, underscores are allowed to be inserted to act as separators for easier reading of the numbers:</p> <pre><code>let million = 1_000_000;\nlet lakh = 1_00_000;\n</code></pre> <p>Alan doesn't care where the understores are inserted, so place them anywhere that makes sense to you. The only restriction is that you can't have a leading underscore.</p> <p>Because the other base types are generally used when doing bitwise arithmetic, they do not have a negative representation, only base-10 has this syntactic feature:</p> <pre><code>let negative_five = -5;\n</code></pre>"},{"location":"learn_alan/#floats","title":"Floats","text":"<p>Floating-point numbers have two representations: Decimal and Scientific Notation.</p> <pre><code>let decimal    = 12.34;\nlet scientific = 1.234e1;\n</code></pre> <p>In scientific notation, the <code>e</code> separates the base number from the exponent in the formula <code>base * 10^exponent</code>, and is conventionally written with a singular digit followed by the decimal point then followed by the remaining digits.</p> <p>Both decimal and scientific notation allow for negative numbers, while scientific notation also allows for negative exponents.</p> <pre><code>let decimal    = -0.02;\nlet scientific = -2e-2;\n</code></pre>"},{"location":"learn_alan/#booleans","title":"Booleans","text":"<p>Booleans are simply the bare keywords <code>true</code> and <code>false</code>. Other types do not automatically coerce into booleans, so there's no \"truthy\" <code>0</code> is <code>false</code>, <code>&gt;=1</code> is <code>true</code> kind of behavior in the language. (At least, by default. More on that later.)</p>"},{"location":"learn_alan/#strings","title":"Strings","text":"<p>Strings in Alan can be written with either single-quotes (<code>'</code>) or double-quotes (<code>\"</code>), escaping is done with backslash (<code>\\</code>) so you can still write a single-quote in a single-quoted string with (<code>\\'</code>) and vice-versa for double-quotes (<code>\\\"</code>). Therefore to write a backslash you need two of them (<code>\\\\</code>).</p> <p>This should feel familiar for many developers out there, but what may be less familiar is that all strings are multi-line, so:</p> <pre><code>\"Hello,\nWorld!\"\n</code></pre> <p>is valid. You can still write <code>\\n</code> instead of a literal newline if that makes the string look nicer to you, but it isn't necessary.</p>"},{"location":"learn_alan/#void","title":"Void","text":"<p>The <code>void</code> type represents nothing (but it likes to stare). It's not useful on its own, but can be made useful in conjunction with sum types (more on that later). It's also an alias for <code>()</code>, an empty tuple (more on tuples later).</p> <p>Suffice it to say, you're not likely to work with the <code>void</code> type directly, but it's very useful in keeping bugs out of your code.</p>"},{"location":"learn_alan/#generic-types","title":"Generic Types","text":"<p>Generic types are types that take other types as arguments to produce a new type.</p> <p>As we saw in a previous example, there's a type called <code>Mut{T}</code> that takes one argument, <code>T</code>, which produces a new type indicating that we want changes to this type to be reflected in the original variable that was passed in.</p> <p>There are many built-in generic types that have particular meanings, from which you can assemble the type you need to store your data, and the most common of these are covered below.</p> <p>But before we get to those, we need to introduce one more concept. If you needed to write the generic type invocation every time you need that type it would be very cumbersome to manage, which is where type aliases come in.</p>"},{"location":"learn_alan/#type-aliases","title":"Type Aliases","text":"<p>Types are defined similarly to single-statement functions, but with <code>type</code> instead of <code>fn</code>.</p> <pre><code>type Foo = i64;\n</code></pre> <p>This is the simplest type definition in Alan, a type alias. It provides zero type safety guards over using the original type that is aliased. The compiler strips all aliasing when checking whether or not an input value can be passed to the function in a function call, so only use them if it is more convenient in your code or clearer to read.</p> <p>Similarly, you can define your own generic type like this:</p> <pre><code>type Bar{T} = T;\n</code></pre> <p>which is similarly reduced back to whatever type <code>T</code> you passed into the <code>Bar</code> generic type, adding nothing on its own to the type safety of your code.</p> <p>They do become more convenient when defining your own types, though.</p>"},{"location":"learn_alan/#product-types-tuples-and-structs","title":"Product Types (Tuples and Structs)","text":"<p>Product Types let you group multiple values together and pass them around together in your code.</p>"},{"location":"learn_alan/#tuples","title":"Tuples","text":"<p>The simplest is a tuple.</p> <pre><code>type myTuple = i64, string;\n</code></pre> <p>Note</p> <p>All type statements in Alan are resolved into a functional style. <code>type myTuple = i64, string;</code> can also be written as <code>type myTuple = Tuple{i64, string};</code> The <code>,</code> symbol, except within the generic argument parameterization, is a type operator for the <code>Tuple{A, B}</code> type function.</p> <p>You can define your own type functions (AKA generic types) and type operators to extend type system, but be careful about legibility of the resulting code.</p> <p>When you define types in Alan, constructor and accessor functions are created automatically for you to create types and retrieve values from them. <code>myTuple</code> automatically defines a constructor function named <code>myTuple</code>, and accessor functions <code>0</code> and <code>1</code> to access the individual elements of the tuple.</p> <p>You can use the <code>myTuple</code> type like this:</p> <pre><code>type myTuple = i64, string;\n\nexport fn main {\n  let testTuple = myTuple(1, \"test\");\n  testTuple.0.print; // Prints 1\n  testTuple.1.print; // Prints test\n}\n</code></pre> <p>Note</p> <p>The grammar of Alan disallows defining a function that starts with a number to avoid ambiguity with numeric constants, which makes tuple accessor functions special. That makes them the only functions that can only be called with accessor syntax, as calling them as regular functions is similarly ambiguous.</p> <p>This also demonstrates why type aliases are simply aliases and not explicitly used for type checking, as tuples can be anonymously constructed:</p> <pre><code>export fn main {\n  let testTuple = (1, \"test\"); // Constructs an identical type as `myTuple`\n  testTuple.0.print; // Prints 1\n  testTuple.1.print; // Prints test\n}\n</code></pre> <p>Note</p> <p>This syntax is not yet implemented, but intended to be implemented before Alan v0.2.0 releases. TODO: Delete this note!</p>"},{"location":"learn_alan/#structs","title":"Structs","text":"<p>Structs are the same as tuples, except they have names for the different sub-types that you can use to access them. A simple struct is defined as:</p> <pre><code>type myStruct = foo: i64, bar: string;\n</code></pre> <p>Statements (both type statements and function statements) are allowed to be multi-line, so this can also be written as:</p> <pre><code>type myStruct =\n  foo: i64,\n  bar: string;\n</code></pre> <p>You can then use the <code>myStruct</code> type like this:</p> <pre><code>export fn main {\n  let testStruct = myStruct(1, \"test\");\n  testStruct.foo.print; // Prints 1\n  testStruct.bar.print; // Prints test\n}\n</code></pre> <p>As you can see, construction of the type is identical, while property accessing now goes by the field names for each struct type.</p> <p>Note</p> <p>The <code>myStruct</code> function that the compiler generates names the first and second argument <code>foo</code> and <code>bar</code>, respectively, and it is intended in a future release of Alan to allow calling functions where arguments are passed in any order, labeled by the argument names. This would allow struct-like constructor functions to be called like:</p> <pre><code>let testStruct = myStruct(\n  foo: 1,\n  bar: \"test\",\n);\n</code></pre> <p>which would be more familiar for users coming from other languages and more forgiving of argument order.</p>"},{"location":"learn_alan/#structuples","title":"Structuples?","text":"<p>The field names in structs are just a syntactic sugar. You may also still access the values with the tuple-specific numeric property accessors.</p> <pre><code>type myStruct = foo: i64, bar: string;\n\nexport fn main {\n  let testStruct = myStruct(1, \"test\");\n  testStruct.foo.print; // Prints 1\n  testStruct.1.print; // Prints test\n}\n</code></pre> <p>You can also mix-and-match labeling fields in your \"struct.\"</p> <pre><code>type myStructTupleHybrid = i64, bar: string;\n\nexport fn main {\n  let testHybrid = myStructTupleHybrid(1, \"test\");\n  test.0.print; // Prints 1\n  test.bar.print: // Prints test\n}\n</code></pre> <p>Under the hood, they all become tuples and the field names are just syntactic sugar for you.</p> <p>Why's it called a 'Product Type'?</p> <p>If you consider a type as a Set of all possible values, then a <code>bool</code> is a Set of two possible values: <code>true</code>, and <code>false</code>.</p> <p>It then follows that a tuple <code>bool, bool</code> has four possible values: <code>true, true</code>, <code>true, false</code>, <code>false, true</code>, and <code>false, false</code>. Then a tuple <code>bool, bool, bool</code> has eight possible values, etc. So tuples and structs are larger Sets whose sizes are the products (multiplications) of the sizes of all of the input Sets.</p>"},{"location":"learn_alan/#anonymous-type-construction","title":"Anonymous Type Construction","text":"<p>Struct-style syntax shows how type aliases make it more convenient to use them. If we didn't have the aliasing mechanism, we would need to include the full definition of the struct on every construction. The following is valid (but awkward) syntax to do so:</p> <pre><code>export fn main {\n  let myAwkwardStruct = {foo: i64, bar: string}(1, \"test\");\n  myAwkwardStruct.foo.print; // Prints 1\n  myAwkwardStruct.bar.print; // Prints test\n}\n</code></pre> <p>You can directly construct a type definition by wrapping it in curly braces (<code>{}</code>). This may be useful for a type you want to keep fully internal to a function definition and not ever share it at all with any other code in your codebase, but is more likely to be used to allow you to construct a generic type inside a generic function. (More on that, later.)</p>"},{"location":"learn_alan/#type-properties","title":"Type Properties","text":"<p>Similarly to how you can access tuple fields by number and struct fields by name, you can do the same thing with the product type itself to access the sub-types from it.</p> <p>So using the hybrid type as an example:</p> <pre><code>type myStructTupleHybrid = i64, bar: string;\n\ntype firstField = myStructTupleHybrid.0; // Equivalent to `i64`\ntype secondField = myStructTupleHybrid.bar; // Equivalent to `string`\n</code></pre> <p>This may not seem useful, and in this example it is more verbose than the actual types involved, but it can be useful when working with generic types, covered later.</p>"},{"location":"learn_alan/#sum-types-type-unions-maybe-fallible-and-tagged-unions","title":"Sum Types (Type Unions, Maybe, Fallible, and Tagged Unions)","text":"<p>Sum Types let you define values that are one of set of potential values.</p>"},{"location":"learn_alan/#type-unions","title":"Type Unions","text":"<p>The simplest version is a type union.</p> <pre><code>type intOrString = i64 | string;\n</code></pre> <p>Note</p> <p>Equivalent to <code>type intOrString = Either{i64, string};</code></p> <p>This type differs from the product types in that it creates multiple constructor functions. In this case two of them, one for each constituent type:</p> <pre><code>type intOrString = i64 | string;\n\nexport fn main {\n  let mightBeInt = intOrString(5);\n  let mightBeStr = intOrString('test');\n}\n</code></pre> <p>Both constructor functions get the same name as the type while the function dispatch logic figures out which one to call based on the input type provided. If you provide a value that doesn't match any of the constituent types, it will fail to compile.</p> <pre><code>type intOrString = i64 | string;\n\nexport fn main {\n  let mightBeBool = intOrString(true); // Fails to compile\n}\n</code></pre> <p>But if you want, you can make a custom constructor function for any type that converts into the type, by just defining that function.</p> <pre><code>type intOrString = i64 | string;\n\nfn intOrString(b: bool) -&gt; intOrString = b.string.intOrString;\n// For most functions, you don't need to specify the return type. This also works:\n// fn intOrString(b: bool) = b.string.intOrString;\n\nexport fn main {\n  let mightBeBool = intOrString(true); // Now works\n}\n</code></pre> <p>It also creates two accessor functions, one for each constituent type:</p> <pre><code>type intOrString = i64 | string;\n\nexport fn main {\n  let mightBeInt = intOrString(5);\n  mightBeInt.i64.exists.print; // Prints true\n  mightBeInt.string.exists.print; // Prints false\n\n  let mightBeStr = intOrString('test');\n  mightBeStr.i64.exists.print; // Prints false\n  mightBeStr.string.exists.print; // Prints true\n}\n</code></pre> <p>The accessor functions get the names of the types, but they don't return that type directly. The actual stored value may or may not be the type you're requesting, so what it returns instead is a <code>Maybe{T}</code> type.</p>"},{"location":"learn_alan/#the-maybe-type","title":"The Maybe Type","text":"<p>You can create your own <code>Maybe</code> type easily by just adding a <code>?</code> to the end of the type.</p> <pre><code>type maybeInt = i64?;\n</code></pre> <p>It's short enough that maybe you'll choose to just use it anonymously when you need it.</p> <pre><code>export fn main {\n  let maybeVal = {i64?}(5);\n  ...\n</code></pre> <p>This type is actually just</p> <pre><code>type Maybe{T} = Either{T, ()};\n</code></pre> <p>making it another type union, but it has a few special functions for it that make it possible to actually acquire the inner value and not iterate through an infinite set of property accessors that return new <code>Maybe{T}</code> values. These are <code>exists</code>, <code>getOr</code>, and <code>getOrExit</code>.</p> <ul> <li><code>exists</code> returns a boolean telling you whether or not the <code>Maybe</code> has an actual value, and is the one used in the examples above.</li> <li><code>getOrExit</code> returns the value within the <code>Maybe</code> or it immediately shuts down the program. Only use this if you're absolutely certain of the consequences.</li> <li><code>getOr</code> is a function that takes two arguments, the <code>Maybe</code> and a default value if there's no value inside. This is the safer option to take, but only if your code can actually deal with a default value correctly.</li> </ul> <p>Replacing the <code>exists</code> in the prior example with <code>getOr</code> calls gives us:</p> <pre><code>type intOrString = i64 | string;\n\nexport fn main {\n  let mightBeInt = intOrString(5);\n  mightBeInt.i64.getOr(3).print; // Prints 5\n  mightBeInt.string.getOr('value').print; // Prints value\n\n  let mightBeStr = intOrString('test');\n  mightBeStr.i64.getOr(3).print; // Prints 3\n  mightBeStr.string.getOr('value').print; // Prints test\n}\n</code></pre>"},{"location":"learn_alan/#the-fallible-type","title":"The Fallible Type","text":"<p>There is a type that is closely related to the <code>Maybe</code> type, but is slightly different. That's the <code>Fallible{T}</code> type.</p> <p>It's defined as:</p> <pre><code>type Fallible{T} = Either{T, Error};\n</code></pre> <p>and has the same three functions, <code>exists</code>, <code>getOr</code>, and <code>getOrExit</code>, but also the <code>Error</code> accessor function. It's useful when you have an operation that should normally do the right thing, but could fail, and that you may want to get the details of why it failed.</p> <p>You can construct a fallible type with a postfix <code>!</code> on the base type name.</p> <pre><code>export fn main {\n  let usuallyInt = {i64!}(5);\n  ...\n</code></pre> <p>Some of the built-in functions return <code>Fallible{T}</code> values, such as the integer construction functions when accepting a <code>string</code> as the input type. <code>i32(\"blargh\")</code> should not return a valid integer.</p>"},{"location":"learn_alan/#tagged-unions","title":"Tagged Unions","text":"<p>As Structs are to Tuples, so Tagged Unions are to Type Unions. Field names on sum types are also allowed, and they affect the constructor and accessor behavior. They also let us distinguish between <code>i64</code> and... <code>i64</code>.</p> <pre><code>type intInput = computed: i64 | parsed: i64 | gigo: string;\n</code></pre> <p>Here we have a type representing an integer input, perhaps from an old-school web form. We distinguish between values that were computed server-side from values parsed from the client side and... other values that weren't parseable.</p> <p>We can access the inner types by the field names, <code>computed</code>, <code>parsed</code>, and <code>gigo</code>, and they'll return <code>Maybe{i64}</code> and <code>Maybe{string}</code>, depending on which one is called.</p> <p>But we can't have the constructor function just be <code>fn intInput(i64) -&gt; intInput</code> and <code>fn intInput(string) -&gt; intInput</code>. Which <code>i64</code> would we be assigning to?</p> <p>In this situation, we need to re-apply the field name within the constructor function call, eg:</p> <pre><code>let value = intInput({computed: i64}(5));\n</code></pre> <p>This is a bit awkward looking, but works. Type aliases can help here, though.</p> <pre><code>type computed = computed: i64;\ntype parsed = parsed: i64;\ntype gigo = gigo: string;\ntype intInput = computed | parsed | gigo;\n\nexport fn main {\n  let value = intInput(computed(5));\n}\n</code></pre> <p>Giving the labeled types their own alias then lets us use it in the type union and use each piece as a constructor function makes this more ergonomic to use at the cost of more type definitions.</p> <p>This also demonstrates how tagged unions in Alan are equivalent to single-value product types.</p>"},{"location":"learn_alan/#type-properties-again","title":"Type Properties (Again)","text":"<p>As with product types, sum types can also have their sub-types accessed via properties, both numeric, and when possible, by field name.</p> <p>Returning to the first tagged union example, we can see how this works:</p> <pre><code>type intInput = computed: i64 | parsed: i64 | gigo: string;\n\ntype firstField = intInput.computed; // Resolves to `i64`\ntype secondField = intInput.1; // Resolves to `parsed: i64`\ntype secondFieldName = intInput.1.0 // Resolves to `\"parsed\"`\ntype secondFieldType = intInput.1.1 // Resolves to `i64`\n</code></pre> <p>There is a slight difference when accessing by field name versus a numeric index. When you access by field name, it grabs the type within the field definition, but when you access by numeric index it returns it with the field still attached if there is such a thing. You can then separately access the field's name and underlying type with <code>.0</code> and <code>.1</code> on that, respectively.</p> <p>This can be useful when introspecting a generic type provided to you, perhaps for debugging purposes.</p> <p>Why's it called a 'Sum Type'?</p> <p>Similar to the reasoning behind Product Types, a Sum type is composed of multiple Sets, but the allowed value can only be from one of the Sets at a time. So a <code>bool</code> is a set of two possible values: <code>true</code>, and <code>false</code>, while a <code>u8</code> is the set of all natural numbers from <code>0</code> to <code>255</code> (256 in total), so a type <code>bool | u8</code> would be 2 + 256 = 258 distinct values.</p>"},{"location":"learn_alan/#buffer-types","title":"Buffer Types","text":"<p>A Buffer Type is a special version of a Tuple, where every element is exactly the same type. It let's you save some typing.</p> <pre><code>type fiveInts = i64[5]; // Equivalent to Buffer{i64, 5}\n</code></pre> <p>This produces two different types of constructor functions as well as the integer-ordered property accessors. One constructor function requires an argument value for each location, and the other takes a single value and assigns it to every location.</p> <pre><code>let individual = {i64[5]}(1, 2, 3, 4, 5);\nlet collective = {i64[5]}(6);\n\nindividual.0; // 1\nindividual.1; // 2\ncollective.2; // 6\n...\n</code></pre> <p>Because all of the types are the same, you may also use the array accessor syntax to get the value, which allows you to choose the value at runtime. Because the computed value may be out-of-bounds, this syntax returns a <code>Maybe</code>-wrapped output instead of the bare value.</p> <pre><code>let individual = {i64[5]}(1, 2, 3, 4, 5);\nindividual[0]; // Maybe{i64}(1)\nindividual[1]; // Maybe{i64}(2)\nindividual[6]; // Maybe{i64}(void)\nindividual[someOtherIntVariable]; // Maybe{i64}\n</code></pre> <p>Note</p> <p>The Array Accessor syntax is syntactic sugar on a call to the function <code>get</code>, where the first argument is the variable the accessor syntax is applied to, and the contents of the accessor syntax are the remaining arguments.</p> <p>This means <code>buf[idx]</code> is equivalent to <code>buf.get(idx)</code> or <code>get(buf, idx)</code>, and <code>matrix[col, row]</code> is equivalent to <code>matrix.get(col, row)</code>.</p> <p>To access the value you'll need to call <code>getOr</code> or <code>getOrExit</code> like with any <code>Maybe</code> type.</p> <p>You can also use the array assignment syntax to update a value.</p> <pre><code>let count = {i64[3]}(1, 2, 5);\ncount[2] = 3;\ncount.print; // Prints [1, 2, 3]\n</code></pre> <p>Note</p> <p>This is syntactic sugar for the <code>store</code> function. If you want to confirm that the assignment actually works, you can call that function and check it's return value.</p> <pre><code>let count = {i64[3]}(1, 2, 3);\ncount.store(5, 5).Error.exists.print; // Prints true, it failed to store a value out-of-bounds\n</code></pre>"},{"location":"learn_alan/#array-types","title":"Array Types","text":"<p>An Array type is like a Buffer type in that all elements of an array are the same type, but the size of the array is not known at compile time and can even change during run time. Arrays can be constructed with any number of arguments, as the constructor function is variadic, but values can only be accessed with the array accessor syntax.</p> <p>Arrays may also be constructed with the array constructor syntax, which elides the need to specify the array type (it is inferred from its contents).</p> <pre><code>type manyInts = i64[]; // Equivalent to Array{i64}\n\nexport fn main {\n  let vals = manyInts(1, 2, 5);\n  let betterVals = [1, 2, 3];\n  betterVals[0]; // Maybe{i64}(1)\n  betterVals[3]; // Maybe{i64}(void)\n}\n</code></pre> <p>Arrays can be altered with the array assignment syntax just like buffers:</p> <pre><code>let count = [1, 2, 5];\ncount[2] = 3;\ncount.print; // Prints [1, 2, 3]\n</code></pre> <p>You similarly can't <code>store</code> values out-of-bounds for an array. If you wish to grow the array, you should <code>push</code> the new value onto the array rather than attempting to write to a non-existent index.</p> <pre><code>let count = [1, 2, 3];\ncount.store(5, 5).Error.exists.print; // Prints true, 5 is out-of-bounds for the array and the value was not stored.\n</code></pre>"},{"location":"learn_alan/#set-types","title":"Set Types","text":"<p>A Set type is like an Array type, but each element in a set type is unique. Unlike arrays there is no specific ordering so you can't access values directly, but you can convert a Set into an Array if you need to iterate through all of its values. You can also convert an Array into a Set during Set construction.</p> <pre><code>export fn main {\n  let uniqueFibonacci = Set{i64}([1, 1, 2, 3, 5, 8]);\n  uniqueFibonacci.Array.print; // Prints [1, 2, 3, 5, 8] but maybe not in that order\n}\n</code></pre> <p>Sets can have new values added to them with the <code>store</code> function.</p> <pre><code>uniqueFibonacci.store(13);\n</code></pre> <p>Note</p> <p>Because the two-argument <code>store</code> function is bound to <code>=</code>, you can technically add new values to a Set with just <code>setName = newValue</code>, but this is super confusing, so don't do that.</p>"},{"location":"learn_alan/#dictionary-types","title":"Dictionary Types","text":"<p>A Dictionary Type lets you create a mapping of keys to values. You can use array accessor syntax to get a value by providing the key. You can also convert it into an Array of Tuples of key-value pairs to iterate over. Unlike Sets, Dictionaries maintain their insertion order when converted back into an Array.</p> <p>The constructor function needs the key and value type defined, but if you construct it with an initial key-value pair, they can be inferred.</p> <pre><code>export fn main {\n  let myDict = Dict(\"test\", 1); // Equivalent to Dict{string, i64}(\"test\", 1)\n  myDict[\"test\"]; // Maybe{i64}(1)\n  myDict[\"huh?\"]; // Maybe{i64}(void)\n  myDict.Array; // [(\"test\", 1)]\n}\n</code></pre> <p>New values can be inserted into dictionaries with the array assignment syntax.</p> <pre><code>let myDict = Dict{string, i64}();\nmyDict[\"test\"] = 1;\nmyDict.Array; // [(\"test\", 1)]\n</code></pre> <p>Note</p> <p>Calls to <code>store</code> always succeed for Dictionaries, so there is no need to check.</p>"},{"location":"learn_alan/#the-gbuffer-and-gpgpu-types","title":"The GBuffer and GPGPU Types","text":"<p>In Alan, there's one more buffer-like type, the <code>GBuffer{T}</code> type. This type is constructed from either a <code>Buffer</code> or <code>Array</code>. The type sits in-between the two in that its length is not known at compile time, but it cannot be changed once constructed. This represents a block of memory on the GPU, which you can set at construction time (from a buffer or array).</p> <p>This type cannot be accessed directly at all, it must be explicitly <code>read</code> back into an array before it can be accessed, but it can be included in a <code>GPGPU</code> execution plan and mutated by that GPGPU compute. The <code>GPGPU</code> type can be worked with directly, but most of the time is hidden behind functions that manipulate the <code>GBuffer</code> type.</p> <pre><code>export fn main {\n  GBuffer([1.i32, 2.i32, 3.i32, 4.i32])\n    .map(fn (val: gi32) = val * 2)\n    .read\n    .print; // Prints [2, 4, 6, 8]\n}\n</code></pre> <p>Here we also see both higher-order functions (passing functions to other functions) and the GPU primitive types, which are conceptually identical to the actual primitive types, but are not accessible in normal CPU compute (as they represent work on the GPU) and are much narrower in scope (only booleans and 32-bit integers and floats as primitive types).</p>"},{"location":"learn_alan/#higher-order-functions-and-generic-functions","title":"Higher-Order Functions and Generic Functions","text":""},{"location":"learn_alan/#higher-order-functions","title":"Higher-Order Functions","text":"<p>You can create functions that accept other functions as an argument and then call it in the course of its operation to create re-usable patterns of behavior that you can then use in other situations.</p> <p>Just the type portion of the function definition needs to be provided.</p> <pre><code>// \"Doubles\" the string by concatenating it to itself\nfn doublestring(s: string) = s.concat(s);\n\n// Accepts a function that transforms a string and then returns a\n// string that documents that change\nfn stringChanger(s: string, changer: (string) -&gt; string) {\n  return s.concat(\" becomes \").concat(changer(s));\n}\n\nexport fn main {\n  // Calling `doublestring`\n  let danceName = doublestring(\"can\");\n  // Call `stringChanger` with a string and the `doublestring` function\n  stringChanger(\"can\", doublestring).print;\n  // Call `stringChanger` with a string and a closure function that\n  // encloses the `danceName` variable defined above\n  stringChanger(\n    \"a person\",\n    fn (s: string) = s\n      .concat(\" who can dance the \")\n      .concat(danceName)\n      .concat(\" through practice\")\n  ).print;\n}\n</code></pre> <p>We can now pass in the <code>foostring</code> function as well as an anonymous closure function that uses the <code>changed</code> variable itself to produce a new output. The full output of this example when compiled and run looks like:</p> <pre><code>$ alan compile changer.ln\nDone! Took 0.67sec\n$ ./changer\ncan becomes cancan\na person becomes a person who can dance the cancan through practice\n</code></pre> <p>The same <code>stringChanger</code> function produced different outputs based on the behavior of the function it was provided.</p> <p>Note that the function definitions usually skipped the <code>-&gt;</code> symbol and return type, leaving it up to the compiler to infer the return type of the function involved. In this example this was done in every situation Alan can infer the return type, while the singular place it remains is where it's always required: when defining the kind of function a higher-order function takes as an input.</p>"},{"location":"learn_alan/#function-type-digression","title":"Function Type Digression","text":"<p>The type for a function is defined with <code>I -&gt; O</code> where the input type <code>I</code> turns into the output type <code>O</code>. Input type? Shouldn't that be types, for each argument?</p> <p>Well, for Alan, the traditional way you write a set of arguments and their types is identical to a struct-style tuple. A struct is a singular type, and constructing a tuple is identical to calling a function with a set of arguments matching the tuple args, because they are literally the same thing in Alan.</p> <p>This also means that, while definitely not recommended, if you wanted to do Go-style error handling by returning a tuple of <code>(value, error)</code> and then manually check if the error actually exists, you could define a function like:</p> <pre><code>fn goStyleIntParse(s: string) {\n  let result = s.i64;\n  return {i64, Error?}(result.i64.getOr(0), result.Error);\n}\n</code></pre> <p>And now you need to manually check if the <code>Error</code> exists in the output tuple before you can safely use the <code>i64</code>. But if you ever have a legitimate reason to return multiple values from a single function, it's perfectly possible.</p> <p>The reverse is also true, anything can be the input side of things, but how do you even access the values if you didn't give them field names? We can't exactly use the <code>0</code>, <code>1</code>, etc of tuple accessor syntax because they can't be properties of anything, so the compromise in this case is to prefix <code>arg</code> on these tuple names.</p> <pre><code>fn lazyFooString(string) -&gt; string = \"foo\".concat(arg0);\n// fn lazyFooString(string) = \"foo\".concat(arg0);\n\nexport fn main {\n  \"bar\".lazyFooString.print; // Prints foobar\n}\n</code></pre> <p>You don't technically need the parens in the definition, either. You can just put in some whitespace after the name to make it unambiguous.</p> <pre><code>fn lazyFooString string -&gt; string = \"foo\".concat(arg0);\nfn lazyFooString string = \"foo\".concat(arg0);\n\nexport fn main {\n  \"bar\".lazyFooString.print; // Prints foobar\n}\n</code></pre> <p>It's just conventional to have parens because that's what the majority of popular programming languages do.</p>"},{"location":"learn_alan/#generic-functions","title":"Generic Functions","text":"<p>Generic Functions are functions where the types of data they're operating on aren't known at the time the function is written. They are often most useful in conjunction with Higher-Order Functions, where the function passed to the generic function determines the output type involved. You specify names for the unknown types inside of <code>{}</code> just after the function name.</p> <pre><code>fn fma{T, U}(arr: Array{T}, f: T -&gt; bool, m: T -&gt; U, r: (U, U) -&gt; U) -&gt; U? {\n  return arr.filter(f).map(m).reduce(r);\n}\n</code></pre> <p>This function takes an array of any type <code>T</code>, first filters out irrelevant parts with a filter function <code>f</code> that takes <code>T</code> and returns a <code>bool</code> to determine if it stays or goes. Then it passes it to a map function <code>m</code> that takes type <code>T</code> and converts it into type <code>U</code>, and finally gives it to the reducer function <code>r</code> that takes two values of type <code>U</code> and returns a singular <code>U</code>. The output of this whole chain is a <code>Maybe</code> type, specifically <code>U?</code>, because the input array might be empty. The final return type is optional, but is less \"obvious\" with this code, so is good to include for better clarity for this function. It also acts as a safeguard -- the compiler will fail to compile your code if the annotated return type does not match the return type it infers, which can help prevent unexpected changes in behavior when refactoring your codebase.</p> <p>By convention, the type variables in generic functions (and generic types) are written with singular uppercase letters to make them stand out from normal variables and types.</p>"},{"location":"learn_alan/#default-value-digression","title":"Default Value Digression","text":"<p>We didn't use the generic types anywhere but in the type of the function, but suppose <code>U</code> has a default constructor function that can be called without any arguments. We could then get a default value to fall back on and eliminate the <code>Maybe</code> from the return type signature here.</p> <pre><code>fn fma{T, U}(arr: Array{T}, f: T -&gt; bool, m: T -&gt; U, r: (U, U) -&gt; U) -&gt; U {\n  return arr.filter(f).map(m).reduce(r).getOr({U}());\n}\n</code></pre> <p>We can get a reference to whatever the actual type ends up being by wrapping it in <code>{}</code> within the body, and then we immediately invoke it with the parens <code>()</code> afterwards.</p> <p>Default values can often be dangerous in a production system because they can hide a mistake in the code where a value was not initialized correctly, so the vast majority of types in Alan do not support it (the <code>Maybe</code> type is the exception. <code>Maybe{i64}()</code> produces a <code>Maybe</code>-wrapped <code>void</code> value). But you can easily add that to the language, scoped to just the source file you're currently working in, by defining a zero-arg constructor function for any type. Eg:</p> <pre><code>fn i64 = 0;\n</code></pre> <p>Now this type has a zero-arg constructor, so if we wanted to use <code>fma</code> to return, say, the total length of all captial words in a string, we could do something like:</p> <pre><code>fn capcount(s: string) = s.split(\" \").fma(fn (s: string) = s &lt; \"a\", len, add);\n\nexport fn main {\n  \"Hello there! How are you doing this fine Monday morning?\".capcount.print; // Prints 14\n  \"foo bar baz\".capcount.print; // Prints 0\n}\n</code></pre> <p>Assuming the default <code>i64</code> constructor function and the more recent <code>fma</code> definition are already defined.</p> <p>We use string ordering to figure out which strings begin with capital letters (because their first character is earlier in ASCII and unicode ordering than the lowercase letters) and keep only those, then we compute the <code>len</code> of each substring, then we add them together, and finally print the output number. Because <code>i64</code> now has a default constructor, even when we called it a second time with only lowercase words, we'll get the expected value of <code>0</code> in this situation.</p>"},{"location":"learn_alan/#compile-time-computation-conditional-types-and-conditional-compilation","title":"Compile-Time Computation, Conditional Types, and Conditional Compilation","text":"<p>As was shown with <code>Buffer</code>s when defining the size of buffer instances, the type system can work with constant primitive types. The type system includes integers, floats, booleans, and strings. These types can also be manipulated at compile time to generate the actual value to use.</p>"},{"location":"learn_alan/#compile-time-computation","title":"Compile-Time Computation","text":"<p>While declaring a buffer of <code>i64[1 + 2]</code> will give you a buffer of three elements, that's not generally useful. (Though sometimes you do want to include a bunch of explicit arithmetic to show where some constant value came from.) This feature is more meant for use with generic types. For instance, the <code>concat</code> function for buffers has a type signature of:</p> <pre><code>export fn concat{T, S, N}(a: Buffer{T, S}, b: Buffer{T, N}) -&gt; Buffer{T, S + N} {\n  ...\n</code></pre> <p>The output buffer length is computed from the lengths of the two input buffers.</p> <p>Beyond addition there are all of the arithmetic operations, as well as the comparison operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>), and so on.</p> <p>There are also some special compile-time types to provide data at compile-time that may be useful.</p> <ul> <li><code>Env{K}</code> returns the string environment variable for the given string key (or aborts compilation if not present)</li> <li><code>FileStr{F}</code> returns the contents of a file as a string for a given file path (or aborts compilation)</li> <li><code>If{C, A, B}</code> resolves as type <code>A</code> if <code>C</code> is <code>true</code>, and as <code>B</code> if <code>C</code> is false.</li> </ul>"},{"location":"learn_alan/#conditional-types","title":"Conditional Types","text":"<p>The <code>If{C, A, B}</code> type is the primary conditional type in Alan, letting you choose which type to actually resolve as. This could be for a variety of reasons; automatically swapping between <code>Buffer</code>, <code>Array</code>, or <code>GBuffer</code> based on the size of the data to be processed, or swapping out filesystem type depending on the operating system you're running on.</p> <p>For example, a <code>Path</code> type could be defined like:</p> <pre><code>type Path =\n  hasDrives: If{Windows, true, false},\n  separator: If{Windows, \"\\\\\", \"/\"},\n  path: string;\n</code></pre> <p>When a field in a product type resolves to a constant type value, Alan removes it from the actual product type that is constructed but keeps the accessor function for it that returns the primitive type with that value, and the compiler converts any calls to that function directly into the constant in the code, making it effectively zero-cost to \"annotate\" your types with metadata that can be determined at compile-time for all instances of that type.</p> <p>This usually only applies for things like the target operation system, processor architecture, or build type (test, debug, release), but there's no restriction on what it can be used for.</p>"},{"location":"learn_alan/#tagged-types-digression","title":"Tagged Types Digression","text":"<p>An internal type for implementing the GPU types, <code>WgpuType{N}</code>, is used with <code>N</code> being the <code>wgsl</code> name of the type (which differs from the Alan name for the type) and is a constant string. Eg:</p> <pre><code>type gu32 = WgpuType{\"u32\"};\n</code></pre> <p>This isn't conditional, but allows the type to be \"tagged\" with metadata to use at run time.</p>"},{"location":"learn_alan/#conditional-compilation","title":"Conditional Compilation","text":"<p><code>If{C, A, B}</code> is useful in combination with the <code>Env{K}</code> type to have features enabled or disabled during compilation, but when the type or function they're associated with differs significantly, sprinkling conditionals everywhere can make your code harder to read, so Alan has a unique feature (as far as we're aware) to allow top-level keywords to be optionally generic, accepting a single compile-time boolean type as the argument to determine whether or not to include it in the compilation process at all.</p> <p>The <code>Path</code> example could be written as:</p> <pre><code>type Path = hasDrives: false, separator: \"/\", path: string;\ntype{Windows} Path = hasDrive: true, separator \"\\\\\", path: string;\n</code></pre> <p>Here we're relying on the \"last definition wins\" tiebreaker for identical definitions. For non-Windows platforms the first <code>Path</code> is the only one so it sticks around, while on Windows, both are defined but the Windows-specific one is defined second so it overrides the first definition.</p> <p>But this works any keyword in the top-level of the source file, so <code>fn{Test}</code> defines a function that only exists during testing, <code>export{Windows}</code> exports something only for the Windows platform, etc.</p> <p>Conditional compilation in Alan simply requires tagging the code that you want to be compiled only in certain circumstances with the condition that it should be compiled. That's it.</p>"},{"location":"learn_alan/#operators-and-type-operators","title":"Operators and Type Operators","text":"<p>It has been alluded to in prior sections that operators are just functions and type operators are just generic types (aka type functions), and that is the case.</p> <p>Alan defines a mapping of certain operator symbols to certain functions and type operator symbols to certain generic types, so <code>1 + 2</code> inside of a function is equivalent to <code>add(1, 2)</code> and the same inside of a type is equivalent to <code>Add{1, 2}</code>.</p> <p>There is also a defined precedence between operators, so multiplying <code>*</code> is converted to a functional form before adding <code>+</code>.</p> <p>Specifically, multiplying is given a precedence of <code>4</code> and adding a precedence of <code>3</code>. When processing a statement (type or function), the statement is scanned for the highest precedence operator, with ties resolving to the left-most operator, then converting it and the surrounding sub-statement segments into a function call, and repeating the process until only function calls remain in the statement.</p> You can faintly hear mad cackling coming from the old Symbolics headquarters... <p>Operators can only be one or two argument functions (or generic types). For two arguments, the operator is an <code>infix</code> operator placed between its two operands, while for one argument, the operator may be bound as a <code>prefix</code> or <code>postfix</code> operator. Prefix operators come before the value they operate on, eg <code>-x</code> maps to <code>neg(x)</code>, and postfix operators come after the value they operate on, eg <code>i64?</code> maps to <code>Maybe{i64}</code>.</p>"},{"location":"learn_alan/#augmenting-operators","title":"Augmenting Operators","text":"<p>As operators and type operators simply map to functions and generic types (type functions), you can augment the behavior of an operator by defining a new function with the same name as one of the operators' mapped function names, but for a new type.</p> <p>In standard Alan, the following doesn't compile:</p> <pre><code>export fn main {\n  print(\"Hello, \" + \"World!\");\n}\n</code></pre> <p>But it can be made to work pretty easily:</p> <pre><code>fn add(a: string, b: string) = a.concat(b);\n\nexport fn main {\n  print(\"Hello, \" + \"World!\");\n}\n</code></pre> <p>Note</p> <p>This pattern of string construction is generally frowned upon nowadays, primarily because in Javascript and other dynamic languages it leads to weird math errors where <code>\"Hello\" + 2</code> works, though even with the augmentation described above that would still fail to compile in Alan.</p> <p>But the other reason why is because it requires a lot of memory allocation and memory copying that template-based string construction avoids, making the template-based approach faster for all but the most trivial of examples.</p> <p>This behavior is more useful for your own custom types, for instance:</p> <pre><code>type Vec{T, L} = If{\n  L &lt; 5,\n  T[L],\n  Fail{\"Vector CPU extensions only work for vectors of length 4 or less\"}};\n</code></pre> <p>A wrapper around a buffer type constrained to lengths 1-4 that you then execute specialized functions on would be nicer to work with if you can use arithmetic operators on it for parallelized addition, multiplication, etc.</p> <p>Just defining:</p> <pre><code>fn add{T, L}(a: Vec{T, L}, b: Vec{T, L}) -&gt; Vec{T, L} {\n  ...\n</code></pre> <p>will then include this function in the set the <code>+</code> operator could resolve to.</p> <p>The other way operators can be augmented is by altering the function they bind to and/or the precedence they're set at.</p> <p>Warning</p> <p>While this change will only be visible within the specific file you've made this alteration to or any other file that <code>import</code>s this change, changing the precedence or binding of an operator can be VERY confusing to anyone reading the code in your file. Do not do this lightly.</p> <p>The syntax to alter an operator is:</p> <pre><code>infix &lt;fnName&gt; as &lt;symbol&gt; precedence &lt;N&gt;;\nprefix &lt;fnName&gt; as &lt;symbol&gt; precedence &lt;N&gt;;\npostfix &lt;fnName&gt; as &lt;symbol&gt; precedence &lt;N&gt;;\n</code></pre> <p>So we can drop the precedence of the prefix negation operator (<code>-</code>) by writing:</p> <pre><code>prefix neg as - precedence 0;\n</code></pre> <p>Or change the infix addition operator (<code>+</code>) to <code>concat</code> by writing:</p> <pre><code>infix concat as + precedence 3;\n</code></pre> <p>The syntax for type operators is identical, except that it is preceded by the <code>type</code> keyword:</p> <pre><code>type infix &lt;typeName&gt; as &lt;symbol&gt; precedence &lt;N&gt;;\ntype prefix &lt;typeName&gt; as &lt;symbol&gt; precedence &lt;N&gt;;\ntype postfix &lt;typeName&gt; as &lt;symbol&gt; precedence &lt;N&gt;;\n</code></pre> <p>So you could swap the precedence of the <code>Function</code> and <code>Tuple</code> type operators by writing:</p> <pre><code>type infix Function as -&gt; precedence 0;\ntype infix Tuple as , precedence 3;\n</code></pre> <p>This would let you define a function that takes multiple arguments without needing to group those arguments with parenthesis:</p> <pre><code>foo: i64, bar: bool -&gt; string\n</code></pre> <p>But then requires you to wrap the entirety of the function type in parenthesis when using it as a type within a higher-order function:</p> <pre><code>fn someFn normalArg: i64, fnArg: (foo: i64, bar: bool -&gt; string) -&gt; string[]\n</code></pre> <p>This looks weird and produces surprising syntax, so you really shouldn't do this.</p>"},{"location":"learn_alan/#defining-new-operators","title":"Defining New Operators","text":"<p>But this same syntax can be used for defining new operators, which is more acceptable, especially if your code is defining a DSL that makes sense for your particular use-case and the developers you are collaborating with.</p> <p>Returning to the vector example, instead of defining an <code>add</code> function and using <code>+</code>, we could do what Julia does where there's a <code>.+</code> operator that does piecewise addition.</p> <p>Then we just need to define the <code>piecewiseAdd</code> function:</p> <pre><code>fn piecewiseAdd{T, L}(a: Vec{T, L}, b: Vec{T, L}) -&gt; Vec{T, L} {\n  ...\n</code></pre> <p>And create the <code>.+</code> operator:</p> <pre><code>infix piecewiseAdd as .+ precedence 3;\n</code></pre> <p>And we can now <code>vec1 .+ vec2</code> in our code. The benefits here are:</p> <ol> <li>Those who are familiar with the dotted-operator DSL from Julia can immediately understand that this is a piecewise addition between vectors or matrices, aiding our comprehension.</li> <li>Those who are not familiar with this syntax immediately know this is doing something non-standard, but can search for the text <code>.+ precedence</code> in the code to find the definition of this operator and then see what function is bound to the operator so they can then read up on what it's actually doing, as the mechanism for defining an operator is standardized. (And a language server could automatically figure this out for them and allow a go-to-definition for the operator.)</li> </ol>"},{"location":"learn_alan/#binding-functions-and-types-from-rust-or-javascript","title":"Binding Functions and Types from Rust (or Javascript)","text":"<p>Beyond defining functions and types in Alan, you may also bind functions and types to Rust or Javascript functions and types. This binding process trusts you completely that the binding has been specified correctly, so be sure that you're doing so.</p>"},{"location":"learn_alan/#binding-functions","title":"Binding Functions","text":"<p>The two function syntaxes we have covered up until now are the single-statement and multi-statement syntaxes.</p> <pre><code>fn foo(a: i64, b: i64, c: i64) = a * b + c;\nfn bar(a: i64, b: i64, c: i64) {\n  const d = a * b;\n  const e = a * c;\n  return a + b + c + d + e;\n}\n</code></pre> <p>But there is a third syntax:</p> <pre><code>fn baz \"baz\" :: (i64, i64, i64) -&gt; i64;\n</code></pre> <p>The <code>::</code> symbol is an alias for the <code>Call{N, F}</code> type, specifying a function call with the Rust function name as a string on the left, and the function type that it represents on the right. This <code>Call</code> type doesn't have any properties, but defines a single \"constructor\" function that takes the input specified and returns the output. This is used in conjunction with the function declaration syntax to give this \"constructor\" an easy-to-use name.</p> <p>Note</p> <p>The <code>Call{N, F}</code> type requires a fully-defined function type, including the return type, for any function being bound from Rust or Javascript. Alan's type inference cannot operate on a language it wasn't designed for, so it must be told all of the necessary information ahead of time to work.</p> <p>In fact, you could use this syntax with any type that produces an automatically-defined constructor function, so if you wanted to create an alias for a struct, but only when constructing it, you could do so:</p> <pre><code>type Record = value: string, count: i64;\n\nfn r Record;\n</code></pre> <p>This will produce a function <code>r</code> that takes a <code>string</code> and <code>i64</code> and generates a <code>Record</code> object. It's essentially shorthand for:</p> <pre><code>fn r (v: string, c: i64) = Record(v, c);\n</code></pre> <p>which reduces some redundant syntax, but also eliminates the wrapper function from the call stack.</p> <p>You can bind more than just Rust functions as Alan functions. Since functions in Alan are also methods, properties, and operators, these concepts in Rust are also bindable as functions (which you can then use as methods or properties automatically and can rebind to an operator if desired).</p> <pre><code>fn add Infix{\"+\"} :: (f32, f32) -&gt; f32;\n</code></pre> <p>This defines an <code>add</code> function for 32-bit floats, being bound to Rust's <code>+</code> operator and that function name <code>and</code> being bound to <code>+</code> within Alan.</p> <p>In Alan, values are passed by reference to functions, but in Rust, you can call functions in different ways, such as passing ownership to the function, passing a mutable reference, or simply dereferencing a reference. Therefore, you can annotate the function type for these bound functions, operators, etc, with <code>Own{T}</code>, <code>Deref{T}</code>, etc.</p> <pre><code>fn eq Infix{\"==\"} :: (Deref{i8}, Deref{i8}) -&gt; bool;\n</code></pre> <p>This defines an <code>eq</code> function for 8-bit integers, binding it to Rust's <code>==</code> operator, but indicating to Alan that it should dereference the arguments when passing them to the operator. These various generic types allow you to annotate the binding, eliminating the need for writing wrapper functions in Rust.</p>"},{"location":"learn_alan/#binding-functions-from-platform-specific-libraries","title":"Binding Functions from Platform-specific Libraries","text":"<p>There are a collection of types involved in specifying dependencies stored on crates.io and npm that you can use in conjunction with the <code>Call{N, F}</code> type to bind to 3rd party libraries in whichever host language you choose to compile to.</p> <p>These are:</p> <ul> <li><code>Import{N, D}</code> - specifying the name of the function or type to import from the dependency. Also bound as the <code>&lt;-</code> type operator.</li> <li><code>From{D}</code> - Special syntactic sugar that uses the name of the type or function declaration to determine the name of the type or function to import. Bound to the <code>&lt;--</code> type operator.</li> <li><code>Dependency{N, V}</code> - specifying the name and version (or raw git URL) of the dependency. Also bound as the <code>@</code> type operator.</li> <li><code>Rust{D}</code> - specifying that this is a Rust crate.</li> <li><code>Nodejs{D}</code> - specifying that this is an NPM package.</li> </ul> <p>Note</p> <p>It is intended for <code>Import{N, D}</code> and <code>From{D}</code> to both be bound to <code>&lt;-</code>, with <code>Import{N, D}</code> as an infix operator and <code>From{D}</code> as a prefix operator, but some refactoring is needed in the compiler to allow the same symbol to bind to different operators.</p> <p>You use three of the five of these types in place of the <code>N</code> argument of <code>Call{N, F}</code> to specify a platform-native library function or type to import. Eg:</p> <pre><code>fn{Rs} escape Call{Import{\"regex_syntax::escape\", Rust{Dependency{\"regex-syntax\", \"0.8.5\"}}}, Function{string, string}}; // Binds the `escape` function from `regex-syntax`\nfn{Rs} escape \"regex_syntax::escape\" &lt;- Rust{\"regex-syntax\" @ \"0.8.5\"} :: string -&gt; string; // Same binding but using type operators where possible\nfn{Js} yamlLoad Call{Import{\"js_yaml.load\", Nodejs{Dependency{\"js-yaml\", \"4.1.0\"}}}, Function{string, JSObject}}; // Binds the `load` function from `js-yaml` (Alan doesn't have a JSObject type, yet, so good luck with that part!)\nfn{Js} yamlLoad \"js_yaml.load\" &lt;- Nodejs{\"js-yaml\" @ \"4.1.0\"} :: string -&gt; JSObject; // Same binding but using type operators where possible\n</code></pre> <p>Note</p> <p>The conditional compilation on the function definitions when importing libraries native to the platform language is highly recommended to prevent compilation failures if/when your code is targeting a different platform language.</p> <p>Ideally if you need native code, you have paired <code>fn{Rs}</code> and <code>fn{Js}</code> bindings so your code can seamlessly compile to the browser as well as natively. Alan's root scope and standard library follow this advice.</p> <p>For now, you must include the name of the library the function is coming from in the binding string for this to work. In Rust it's separated with <code>::</code> between the library name and the thing to import and in Javascript it is separated with <code>.</code>. In Javascript, the compiler automatically converts <code>-</code> in a package name to <code>_</code> for the variable name the package occupies.</p>"},{"location":"learn_alan/#binding-types","title":"Binding Types","text":"<p>Similarly, binding types is done with the <code>Binds{T, ...}</code> type.</p> <pre><code>type Foo = Binds{\"Foo\"};\ntype Bar{A, B} = Binds{\"Bar\", A, B}; // Becomes Bar&lt;A, B&gt; in Rust\n</code></pre> <p>Bound types are different from normal Alan types in that zero constructor and accessor functions are automatically defined for them. It is up to you <code>Call</code> Rust functions that create and work with this type.</p> <p>Warning</p> <p>In Alan, it is assumed that all types can be <code>clone</code>d and <code>hash</code>ed, and the Alan compiler will generate code with that assumption. It is highly recommended that types that can't be cloned are wrapped in <code>Rc&lt;T&gt;</code> or <code>Arc&lt;T&gt;</code> during the binding, and types that can't be hashed should be wrapped with the New Type Idiom and then <code>impl</code> the <code>Hash</code> and the <code>PartialEq</code> and <code>Eq</code> traits. If you need to do both, put the <code>Rc&lt;T&gt;</code> wrapping within the New Type wrapper.</p> <p>Bound functions and types are tricky to work with, but provide a zero-cost FFI to the existing Rust (and eventually Javascript) ecosystem of libraries. The syntax is pretty simple, but leaves correctness up to you, so tread lightly if you need it!</p> <p>Note</p> <p>When multiple target languages are supported in Alan, there will be global boolean type constants <code>Rs</code> and <code>Js</code> that you can use with conditional compilation to choose which <code>type</code> or <code>fn</code> definition is actually selected, eg:</p> <pre><code>type{Rs} i32 = Binds{\"i32\"};\ntype{Js} i32 = Binds{\"Number\"};\n</code></pre> <p>Libraries in Alan that need to bind into the target language should, if at all possible, have a binding for both target languages, but if they can't, or it doesn't make sense to (eg, process control access in Javascript or DOM access in Rust), then it would be best to implement a poison pill like this to block compilation in the wrong target language:</p> <pre><code>type{Rs} Dom = Fail{\"This library can only be used when compiled to Javascript, as Rust does not have a DOM.\"}\n</code></pre>"},{"location":"learn_alan/#binding-types-from-platform-specific-libraries","title":"Binding Types from Platform-specific Libraries","text":"<p>The same collection of types involved in binding functions from platform languages works identically for types. Well, sort-of identically. Javascript doesn't have types, so what happens there? The type is just an internal construct within the compiler to prevent you from accidentally assigning the wrong kind of value to the wrong variable, and is not emitted in the code generation at all. It just needs to be \"distinct\", so it's recommended to write it in a similar way, with Javascript class names being a decent analog to use.</p> <p>In neither Rust nor Javascript binding will constructor functions be automatically bound for these types; they're opaque to the compiler, so you also need to bind a function to construct them (and by convention that function name should match the type name, and this is where a Javascript library's class would actually be imported, as the constructor function).</p> <p>For Rust, though, these type bindings must be precise, not just unique, or the generated code will be incorrect. Similar to how import declaration takes the first generic argument of the <code>Call{N, F}</code> type, when you bind a type, it takes place of the first generic argument of the <code>Binds{T, ...}</code> type:</p> <pre><code>type{Rs} HashMap{K, V} = Binds{\"hashbrown::HashMap\" &lt;- Rust{\"hashbrown\" @ \"0.15.2\"}, K, V}; // Binding the hashbrown high-performance HashMap type\ntype{Js} Moment = Binds{\"Moment\" &lt;- Nodejs{\"moment\" @ \"2.30.1\"}}; // Binding the Moment datetime type\n</code></pre> <p>You can bind generic functions in Alan as you can see here, but technically what happens under the hood is that a concrete type is constructed for each set of generic arguments you used in your Alan code; the actual generic type is never emitted to the Rust compiler. This is the same thing Rust itself does when generating your binary, effectively duplicating the generic type for each concrete instance of it, so this should have no impact on the size of the resulting binary.</p>"},{"location":"learn_alan/#conditional-statements","title":"Conditional Statements","text":"<p>Currently in Alan, Conditional statements are implemented solely with the <code>if</code> functions, which take a boolean and one or two functions that take zero arguments and optionally return a value.</p> <p>If you provide just one function, it is run only if the condition is <code>true</code> and its return value is passed back through the <code>if</code> function wrapped in a <code>Maybe{T}</code> that you then need to check the value of.</p> <p>If you provide two functions, the first is run when <code>true</code> and the second is run when <code>false</code>. Both functions must return the same type, and the <code>if</code> function returns the value from either branch for you.</p> <p>Before Alan v0.2.0 is released a \"normal-looking\" conditional syntax is planned, allowing for early returns and etc, and will actually be implemented via rewriting your code to use the <code>if</code> function, instead, but this has not yet been done.</p>"},{"location":"learn_alan/#interfaces-aka-types-of-types","title":"Interfaces (AKA Types of Types)","text":"<p>Currently, when you pass \"bad\" types into generic functions or generic types that won't actually work, it will fail to compile as one would expect, but it fails deeper into the compilation and the resulting error message from the compiler is confusing.</p> <p>It is planned to allow generic types and generic functions to specify type constraints. These type constraints can be the names of generic types that the type must be constructed from or an <code>interface</code> type that declares a set of function types indicating how the type can be operated on, allowing a type-safe kind of \"duck typing.\"</p>"},{"location":"learn_alan/#importing-from-files-and-libraries","title":"Importing from Files and Libraries","text":"<p>In many languages, importing from other files and libraries is done with a special syntax, and this syntax is often a preamble placed at the beginning of a source file. This is true of Rust, Java, C#, Python, and modern module-aware Javascript, amongst many others. This general approach is the default across many languages.</p> <p>C is an example of a language that differs in this regard as importing is done through trickery in the C preprocessor, conditionally including the source of another file, usually a \"header\" file that simply declares the C functions that exist in another file that will be linked into the library or binary to be generated. Essentially, there is no such thing as modules in the language itself; it's just a construct within the preprocessor to order the source into one long set of source code to actually compile. Pre-module-aware Javascript was similar, and this is the second most common way for languages to \"deal\" with importing -- make it the developer's problem to handle.</p> <p>Alan differs from both of these. The authors of Alan have not seen the approach chosen in any other language, though it is most similar to Lisp: importing is done through the type system. There are 5 types involved in importing code from other files:</p> <pre><code>Import{N, D}\nFrom{D}\nDependency{N, V}\nRust{D}\nNode{D}\n</code></pre> <p>Of these, the first three have operators binding them.</p> <pre><code>N &lt;- D\n&lt;-- D\nN @ V\n</code></pre> <p>The <code>Import{N, D}</code>, or <code>N &lt;- D</code> type imports the named type or function from the specified dependency. The <code>N</code> parameter must resolve into a string, while the <code>D</code> parameter may be a string, a <code>Dependency{N, V}</code>, <code>Rust{D}</code> or <code>Node{D}</code>.</p> <p>When <code>D</code> is a string, it is treated as a path to another file on the filesystem. If the path is a relative path, it is relative to the current file. If it's an absolute path, the root of the path is anchored in the path where the <code>alan</code> command was invoked. Relative paths can also only reach within the filesystem tree contained by the path the <code>alan</code> command was invoked, to reduce/eliminate certain security vulnerabilities during compilation and to prevent accidentally writing code that is not properly encapsulated.</p> <p>Warning</p> <p>Passing a <code>Dpendency{N, V}</code> directly to an <code>Import{N, D}</code> is not yet implemented as the finer details of libraries have not yet been fleshed out.</p> <p>When <code>D</code> is <code>Rust{D}</code> or <code>Node{D}</code>, this indicates that the dependency is a native one to the Rust or Node.js platform, respectively, and this <code>D</code> must resolve to a <code>Dependency{N, V}</code> type. When done this way, <code>N</code> is the name of the module in <code>Cargo</code> or <code>NPM</code>, and <code>V</code> is the version, by default. However, <code>V</code> could also be the URL to a git repository, and that URL may have a <code>#</code> followed by a branch/tag name to specify the particular branch or tag to check out.</p> <p>When compiling natively, only <code>Rust{D}</code> may be used, and when bundling for the browser, only <code>Node{D}</code> may be used. Usage of the wrong native dependency type is an immediate compilation failure. Fortunately you can easily mask one or the other with conditional compilation and the built-in <code>Rs</code> and <code>Js</code> boolean type values.</p> <p>If the <code>Import{N, D}</code> is a type, you can make use of it in your own code by simply assigning it to an alias, eg:</p> <pre><code>type foo = Import{\"foo\", \"./foo.ln\"};\n</code></pre> <p>Similarly, as functions can be defined solely from a type, if <code>foo</code> were a function instead of a type, you could do:</p> <pre><code>fn foo Import{\"foo\", \"./foo.ln\"};\n</code></pre> <p>Importing in Alan requires explicitly declaring whether the value being imported is a function or a type, making the code more self-documenting when it is read later.</p> <p>Note</p> <p>There currently is no way to import operators or type operators, though this is intended to be implemented in the future. It has been a lower priority since operators and type operators are simple declarative statements so copy-pasting isn't too terrible.</p> <p>The <code>Import{N, D}</code> syntax is shorter with the <code>&lt;-</code> operator syntax:</p> <pre><code>type foo \"foo\" &lt;- \"./foo.ln\";\nfn foo \"foo\" &lt;- \"./foo.ln\";\n</code></pre> <p>This makes renaming types and functions from other files simply choosing a different name for the alias:</p> <pre><code>type foofoo \"foo\" &lt;- \"./foo.ln\";\nfn foofoo \"foo\" &lt;- \"./foo.ln\";\n</code></pre> <p>But for most use-cases, this feels redundant with the <code>foo \"foo\"</code> repetition, so the special <code>From{D}</code> type was defined:</p> <pre><code>type foo = From{\"./foo.ln\"};\nfn foo = From{\"./foo.ln\"};\n</code></pre> <pre><code>type foo &lt;-- \"./foo.ln\";\nfn foo &lt;-- \"./foo.ln\";\n</code></pre> <p>Note</p> <p>This is intended to be just <code>&lt;-</code> once disambiguating infix and prefix types of the same type symbol works.</p> <p>It has a little bit of compile-time magic built into it, grabbing the name of the type or function it is being assigned to and transforming it into an <code>Import</code> of that name and the specified dependency.</p> <p>Warning</p> <p>If <code>From{D}</code> is unable to find the type or function name, the <code>From</code> type instead becomes a compilation failure and the explicit <code>Import</code> syntax is required instead.</p> <p>This is possible if you use an imported type as part of a sum or product type directly,</p> <pre><code>type myTuple = string, From{\"./foo.ln\"}; // What type do you mean?\n</code></pre> <p>or if you are calling a function from another by defining the function type implicitly</p> <pre><code>fn getFoo(foo: string) {\n  {From{\"./foo.ln\"}}(foo); // What function do you mean?\n}\n</code></pre> <p>It could feel tedious to specify the import path or dependency name and version for every type and function you are importing, but you can simply assign the dependency a type alias to deal with it.</p> <p>The root scope includes a shim library for both Rust and Javascript to support the built-in functionality of the language that are assigned to the <code>RootBacking</code> name.</p> <pre><code>type{Rs} RootBacking = Rust{\"alan_std\" @ \"https://github.com/alantech/alan.git\"};\ntype{Js} RootBacking = Node{\"alan_std\" @ \"https://github.com/alantech/alan.git\"};\n</code></pre> <p>This is then used with the import syntax in built-in types:</p> <pre><code>type{Rs} Error = Binds{\"alan_std::AlanError\" &lt;- RootBacking};\ntype{Js} Error = Binds{\"alan_std.AlanError\" &lt;- RootBacking};\n</code></pre> <p>and functions:</p> <pre><code>fn{Rs} storageBuffer \"alan_std::storage_buffer_type\" &lt;- RootBacking :: () -&gt; BufferUsages;\nfn{Js} storageBuffer \"alan_std.storageBufferType\" &lt;- RootBacking :: () -&gt; BufferUsages;\n</code></pre> <p>Note</p> <p>Remember, because these are native function imports, Alan can't automatically figure out the type signature, so it needs to be wrapped in a <code>Call{N, F}</code>, which is the <code>::</code> operator. The type operator precedence order is defined such that no grouping parens are needed for this.</p> <p>By being baked into the type system itself, it can be extended naturally. You can make the module or function being imported be defined by a compile-time environment variable, for example, to provide compile-time options similar in concept to Rust features.</p> <p>It is also intended to eventually add a capabilities system to the import logic, preventing libraries from having access to the filesystem, or sockets, etc, to improve security, which will be done via other built-in types, but this has not been fleshed out, yet.</p>"},{"location":"learn_alan/#testing-your-code","title":"Testing your Code","text":"<p>The <code>Test</code> type exists to determine if your code is being compiled and run with <code>alan test</code>. You can use in during conditional compilation to define a <code>main</code> function that only exists during testing.</p> <pre><code>export fn{Test} main {\n  ...\n</code></pre> <p>This <code>Test</code> type also gates the existence of a built-in test suite for Alan. It consists of a <code>Testing</code> type used to set up a series of tests and support functions that create, mutate, and consume it.</p> <p><code>describe</code> is the first function and it creates a top-level group for tests. There are several variants for better ergonomics, but at its core it takes a string describing the subject of a group of tests and returns a <code>Testing</code> object. It may be chained fluently or be provided a closure function.</p> <p><code>it</code> is the next function. It takes a <code>Testing</code> object returned by a <code>describe</code> and specified a singular test topic, then returns the <code>Testing</code> object. It may also be chained fluently or be provided a closure function.</p> <p><code>assert</code> is the third function. It takes a <code>Testing</code> object from an <code>it</code> as well as a comparison function, followed by two values to be compared against. Generally the first of these two arguments is the \"actual\" value computed during the test by your code, while the last argument is the \"expected\" value that has been hardwired in your test suite.</p> <p><code>report</code> is the final function. It takes a <code>Testing</code> object and generates the test report, with color coding (red for failure, green for success, yellow for in-progress) and Unicode symbols (\u274e for failure, \u2705 for success, and \u2022\ufe0e for in-progress) to indicate test outcomes.</p> <p>At the moment, the test suite will early-exit on the first failure, but it's intended to make that optional in the future. Much (but not all) of Alan's features are tested using this test suite. That is currently the best source to understand its usage, but here's a trivial Alan app that only does something when you run <code>alan test</code> on it:</p> <pre><code>export fn getFoo = \"foo\";\nexport fn makeFooish (s: string) = getFoo().concat(s);\n\nexport fn{Test} main {\n  describe(\"Foo\")\n    .it(\"getFoo\")\n      .assert(eq, getFoo(), \"foo\")\n    .it(\"makeFooish\", fn (test: Mut{Testing}) {\n      let bar = \"bar\";\n      let bbb = bar.repeat(3);\n      test\n        .assert(eq, makeFooish(bar), \"foobar\")\n        .assert(eq, makeFooish(bbb), \"foobarbarbar\");\n    })\n    .report;\n}\n</code></pre> <p>Note that the closure function specifies the type as <code>Mut{Testing}</code> because the original <code>Testing</code> value is being mutated within the function and isn't returned back.</p> <p>The test suite being defined in a conditonally-compiled <code>main</code> function makes it an executable only during tests, while not a compilation target under normal circumstances, which makes it possible to define the test suite for a library in the same file as the library rather than require a separate file, which is useful for unit tests.</p> <p>It is planned to eventually have <code>alan test</code> with no compilation target provided to recursively search all <code>.ln</code> files in the <code>PWD</code> for files that have <code>export fn{Test} main</code> and run these tests sequentially.</p> <p>It is already possible to both <code>alan test foo.ln</code> and <code>alan test --js foo.ln</code> to execute the test suite both natively and inside of Node.js. This is planned to eventually move to testing within a headless browser once the headless browsers support WebGPU so the GPGPU logic can be tested in the browser context as well, but for now GPGPU testing must be done only natively (or with a very complicated setup on supported operating systems implemented in the Alan monorepo involving Node, Chrome, and Rust simultaneously, but only on MacOS).</p>"},{"location":"learn_alan/#want-to-learn-more","title":"Want to Learn More?","text":"<p>Every feature of the Alan language has now been covered. If you want to learn more, take a look at the built-in types, functions, and operators and the standard library.</p>"},{"location":"reference_guides/","title":"Reference Guides","text":"<ul> <li>An Overview of Alan</li> <li>Built-in Types, Functions, and Operators</li> <li>The Standard Library</li> </ul>"}]}