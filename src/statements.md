#### Statements

Within a function are multiple statements. The order of the statements defines their dependence on one another based on what they manipulate in their scope hierarchy. Currently the interpreter simply runs them sequentially, but soon (tm) it will use the scope manipulation to determine a dependency graph of the statements to determine running order without impacting the result (which will also allow multiple threads to be used to run a single function call if there is a performance advantage to doing so).

Statements must be on different lines, but statements can span multiple lines, as well. There are six types of statements: variable declarations, variable assignments, function calls, function returns, event emission, and conditionals (if statements).

##### Variable Declarations

There are two types of variables, constants and mutable variables. Constants are declared with these two syntaxes:

```
const varname: typename = constantOrFunctionCallOrExpression
const varname = constantOrFunctionCallOrExpression
```

The typename is optional as it can be inferred from the value being assigned. Providing the type can be useful to make sure your code is doing what you expected, though, and not using an unexpected type. By default all numeric constants are automatically the highest definition version possible. (`int64` or `float64`)

Any type that exists in the language can be assigned. Simple constants are simply declared, or produced via function calls or operator expressions. User-defined types can be assigned to constants through the use of a constructor function and calling it, through an expression involving operators that produces the user-defined type, or through the user-type literal syntax. Arrays and Maps have similar but slightly different syntaxes, as they deal with inherently plural data versus the struct-like user-defined types:

```
const simpleConstant: bool = true
const simpleConstant2 = "simple"
const expressionResult: int64 = 3 + 5 * 2 + fnCall2(3, 1)
const fnResult: someType = functioncall(3, 5)
const userTypeLiteral = new UserType {
  key = "val"
  foo = true
  bar = 3
}
const arrayTypeLiteral = new Array<int64> [ 1, 1, 2, 3, 5, 8, 13 ]
const mapTypeLiteral = new Map<bool, string> {
  true: "It's true!"
  false: "Nuh uh!"
}
```

All three complex type literals begin with the `new` keyword, followed by the type name, which must be a realized generic if it is a generic type. If the original generic type was an `Array` or `Map` it gets a special syntax. Arrays are surrounded by brackets (`[`, `]`) instead of curly braces (`{`, `}`) and are simply a comma-delimited list of values (they could also be generated by functions or operator expressions, or be a user-defined type literal). Maps are keep the curly braces, but the `key` and `value` pairs are separated by a colon (`:`) instead of an equal sign (`=`), which fits more closely to the Map/Object syntax popularized by JSON (but able to have more than just `string` values for the keys).

Beyond that, there is also the ability to assign the type name of another variable, but the constant *must* be a string in that case:

```
const typename: string = type otherVariable
```

For mutable variables, there are three syntaxes:

```
let varname: typename
let varname: typename = constantOrFunctionCallOrExpression 
let varname = constantOrFunctionCallOrExpression
```

The first syntax allows one to declare a variable without giving it any value (it will default to 0 or false or empty string, etc). The second syntax is identical to the constants syntax, but the first syntax *requires* the type to be declared as it would be unknown, otherwise.

##### Variable Assignments

This syntax only works with mutable variables:

```
varname = constantOrFunctionCallOrExpression
varname.propertyName = constantOrFunctionCallOrExpression
varname[integerOrMapKey] = constantOrFunctionCallOrExpression
```

Since the variable type is already known, it is no longer included. Anything that could be assigned at declaration time is assignable in future assignments. When re-assigning to the properties of user-defined types, you use the dot notation. When re-assigning to `Array`s or `Map`s, you use the array-accessor notation.

##### Function Calls

Because functions can have side effects that might be desirable, and functions defined within the scope of the current function could potentially mutate multiple variables, and so on, it's allowed to call them without storing a return value. It simply looks like this:

```
someFunction(arg1, arg2)
```

where the arguments themselves could be constants, variable names, other function calls, operator statements, and variable type selection.

##### Function Returns

A return statement sets the value of the return type for the function and ends execution:

```
return constantOrFunctionCallOrExpression
```

If the function has no return value, you can also trigger an exit without assigning a return value by simply stating:

```
return
```

##### Event Emission

A function can trigger new events to occur by emitting one:

```
emit eventName
emit eventName constantOrFunctionCallOrExpression
```

If the event is a void event (no arguments given to the handler functions) then you use the simple first syntax. If there is a value provided to the handler, then as with the other statements it could be a constant or variable name or function call or operator expression or type name of a variable that is provided.

##### Conditionals

Conditionals optionally run one block of code (or potentially another) based on a condition. Since this language is intended to run statements in dependency order, the scope the conditions run in are actually functions to prevent them from being run ahead of time. This also means all scopes once you enter a function scope are function scopes, which makes things simpler to reason about. If one of these functions returns a value, the outer function immediately returns that value from the conditional statement.

The conditional syntax is:

```
if booleanConstantOrFunctionCallOrExpression thenFunction
if booleanConstantOrFunctionCallOrExpression thenFunction else elseFunction
if booleanConstantOrFunctionCallOrExpression thenFunction else if ...
```

where the constant, function call, or operational expression *must* evaluate to a boolean (so no type checking, unless it is within an equality check against an expected type name).

Conditionals are one of the two places (the other being event handler declarations) where the `fn` may be omitted from a purely-side-effect function (no arguments, no return value), so the above can look exactly as one would expect:

```
if 1 == 2 {
  print("Wrong")
} else {
  print("Right")
}
```

The conditional has two anonymous functions declared inline. But it could just as easily be something like:

```
fn right() {
  print("Right")
}

fn wrong() {
  print("Wrong")
}

const condition: bool = 1 != 2

if condition right else wrong
```

